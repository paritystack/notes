<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++ - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-ae735e64.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-4d483330.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="c"><a class="header" href="#c">C++</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>C++ is an extension of C that adds object-oriented features and other enhancements.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li>Object-oriented programming</li>
<li>Generic programming support</li>
<li>Standard Template Library (STL)</li>
<li>Low-level memory manipulation</li>
<li>High performance</li>
</ul>
<h2 id="object-instantiation-patterns"><a class="header" href="#object-instantiation-patterns">Object Instantiation Patterns</a></h2>
<p>C++ provides multiple ways to create and initialize objects, each with different characteristics regarding memory management, lifetime, and performance.</p>
<h3 id="1-stack-allocation-automatic-storage"><a class="header" href="#1-stack-allocation-automatic-storage">1. <strong>Stack Allocation (Automatic Storage)</strong></a></h3>
<p>Objects created on the stack have automatic lifetime - they’re destroyed when they go out of scope.</p>
<pre><code class="language-cpp">class MyClass {
public:
    int value;
    MyClass(int v) : value(v) {
        std::cout &lt;&lt; "Constructor called: " &lt;&lt; value &lt;&lt; std::endl;
    }
    ~MyClass() {
        std::cout &lt;&lt; "Destructor called: " &lt;&lt; value &lt;&lt; std::endl;
    }
};

void example() {
    MyClass obj1(10);           // Stack allocation
    MyClass obj2 = MyClass(20); // Also stack allocation
    MyClass obj3{30};           // C++11 uniform initialization

    // All objects destroyed automatically when function exits
}
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Fast allocation/deallocation</li>
<li>Automatic cleanup (RAII)</li>
<li>No memory leaks</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Limited stack size</li>
<li>Objects can’t outlive their scope</li>
</ul>
<h3 id="2-heap-allocation-with-newdelete"><a class="header" href="#2-heap-allocation-with-newdelete">2. <strong>Heap Allocation with new/delete</strong></a></h3>
<p>Objects created on the heap persist until explicitly deleted.</p>
<pre><code class="language-cpp">// Single object
MyClass* ptr1 = new MyClass(100);  // Allocate on heap
// Use ptr1...
delete ptr1;  // Must manually delete
ptr1 = nullptr;  // Good practice

// Array of objects
MyClass* arr = new MyClass[5];  // Default constructor for each
// Use arr...
delete[] arr;  // Must use delete[] for arrays
arr = nullptr;

// With initialization (C++11)
MyClass* ptr2 = new MyClass{200};
delete ptr2;
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Objects can outlive their scope</li>
<li>Larger available memory</li>
<li>Dynamic sizing</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Manual memory management</li>
<li>Risk of memory leaks</li>
<li>Slower than stack allocation</li>
</ul>
<h3 id="3-smart-pointers-modern-c"><a class="header" href="#3-smart-pointers-modern-c">3. <strong>Smart Pointers (Modern C++)</strong></a></h3>
<p>Smart pointers provide automatic memory management for heap-allocated objects.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

// std::unique_ptr - exclusive ownership
{
    std::unique_ptr&lt;MyClass&gt; ptr1 = std::make_unique&lt;MyClass&gt;(10);
    // Automatically deleted when ptr1 goes out of scope
    // Cannot be copied, only moved

    auto ptr2 = std::make_unique&lt;MyClass&gt;(20);  // Using auto
    std::unique_ptr&lt;MyClass&gt; ptr3 = std::move(ptr2);  // Transfer ownership
    // ptr2 is now nullptr
}

// std::shared_ptr - shared ownership
{
    std::shared_ptr&lt;MyClass&gt; ptr1 = std::make_shared&lt;MyClass&gt;(30);
    {
        std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;  // Both own the object
        std::cout &lt;&lt; "Reference count: " &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;  // 2
    }  // ptr2 destroyed, object still exists
    std::cout &lt;&lt; "Reference count: " &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;  // 1
}  // Object deleted when last shared_ptr is destroyed

// Array with smart pointers (C++17)
auto arr = std::make_unique&lt;MyClass[]&gt;(5);
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Automatic memory management</li>
<li>Exception-safe</li>
<li>Clear ownership semantics</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Slight overhead (especially shared_ptr)</li>
<li>Reference counting overhead</li>
</ul>
<h3 id="4-initialization-patterns"><a class="header" href="#4-initialization-patterns">4. <strong>Initialization Patterns</strong></a></h3>
<p>C++ offers various initialization syntaxes with different behaviors.</p>
<pre><code class="language-cpp">class Point {
public:
    int x, y;
    Point() : x(0), y(0) {}
    Point(int x, int y) : x(x), y(y) {}
};

// Default initialization
Point p1;  // Calls default constructor: Point()

// Direct initialization
Point p2(10, 20);  // Calls Point(int, int)

// Copy initialization
Point p3 = Point(30, 40);  // May involve copy/move

// List initialization (Uniform initialization - C++11)
Point p4{50, 60};        // Direct list initialization
Point p5 = {70, 80};     // Copy list initialization
auto p6 = Point{90, 100}; // With auto

// Value initialization
Point p7{};     // Zero-initializes: x=0, y=0
Point* p8 = new Point();   // Value initialization on heap

// Aggregate initialization (for POD types)
struct Data {
    int a;
    double b;
    char c;
};

Data d1 = {1, 2.5, 'x'};   // C-style
Data d2{1, 2.5, 'x'};      // C++11 style
Data d3{.a=1, .b=2.5};     // C++20 designated initializers
</code></pre>
<h3 id="5-constructor-patterns"><a class="header" href="#5-constructor-patterns">5. <strong>Constructor Patterns</strong></a></h3>
<p>Different ways to call constructors for initialization.</p>
<pre><code class="language-cpp">class Resource {
private:
    int* data;
    size_t size;

public:
    // Default constructor
    Resource() : data(nullptr), size(0) {
        std::cout &lt;&lt; "Default constructor" &lt;&lt; std::endl;
    }

    // Parameterized constructor
    Resource(size_t sz) : data(new int[sz]), size(sz) {
        std::cout &lt;&lt; "Parameterized constructor" &lt;&lt; std::endl;
    }

    // Copy constructor
    Resource(const Resource&amp; other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
        std::cout &lt;&lt; "Copy constructor" &lt;&lt; std::endl;
    }

    // Move constructor (C++11)
    Resource(Resource&amp;&amp; other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
        std::cout &lt;&lt; "Move constructor" &lt;&lt; std::endl;
    }

    // Destructor
    ~Resource() {
        delete[] data;
        std::cout &lt;&lt; "Destructor" &lt;&lt; std::endl;
    }
};

// Usage examples
Resource r1;                      // Default constructor
Resource r2(100);                 // Parameterized constructor
Resource r3 = r2;                 // Copy constructor
Resource r4 = std::move(r2);      // Move constructor
Resource r5(std::move(r3));       // Move constructor (explicit)
</code></pre>
<h3 id="6-factory-pattern"><a class="header" href="#6-factory-pattern">6. <strong>Factory Pattern</strong></a></h3>
<p>Using factory functions for object creation.</p>
<pre><code class="language-cpp">class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}
    void draw() override { std::cout &lt;&lt; "Drawing circle" &lt;&lt; std::endl; }
};

class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    void draw() override { std::cout &lt;&lt; "Drawing rectangle" &lt;&lt; std::endl; }
};

// Factory function
std::unique_ptr&lt;Shape&gt; createShape(const std::string&amp; type) {
    if (type == "circle") {
        return std::make_unique&lt;Circle&gt;(5.0);
    } else if (type == "rectangle") {
        return std::make_unique&lt;Rectangle&gt;(4.0, 6.0);
    }
    return nullptr;
}

// Usage
auto shape = createShape("circle");
if (shape) {
    shape-&gt;draw();
}
</code></pre>
<h3 id="7-placement-new"><a class="header" href="#7-placement-new">7. <strong>Placement New</strong></a></h3>
<p>Constructing objects at a specific memory location.</p>
<pre><code class="language-cpp">#include &lt;new&gt;

// Pre-allocated buffer
alignas(MyClass) char buffer[sizeof(MyClass)];

// Construct object in buffer
MyClass* obj = new (buffer) MyClass(42);

// Use object
obj-&gt;value = 100;

// Must manually call destructor
obj-&gt;~MyClass();

// Common use case: memory pools
class MemoryPool {
    char buffer[1024];
public:
    template&lt;typename T, typename... Args&gt;
    T* construct(Args&amp;&amp;... args) {
        void* ptr = /* allocate from buffer */;
        return new (ptr) T(std::forward&lt;Args&gt;(args)...);
    }
};
</code></pre>
<h3 id="8-array-initialization-patterns"><a class="header" href="#8-array-initialization-patterns">8. <strong>Array Initialization Patterns</strong></a></h3>
<p>Different ways to create and initialize arrays of objects.</p>
<pre><code class="language-cpp">// Stack arrays
MyClass arr1[3];                    // Default constructor for each
MyClass arr2[3] = {MyClass(1), MyClass(2), MyClass(3)};  // Specific initialization
MyClass arr3[] = {MyClass(10), MyClass(20)};  // Size inferred

// Uniform initialization (C++11)
MyClass arr4[3] = {{1}, {2}, {3}};
MyClass arr5[3]{{1}, {2}, {3}};

// Heap arrays
MyClass* heap_arr1 = new MyClass[5];      // Default constructor
delete[] heap_arr1;

// std::array (C++11)
#include &lt;array&gt;
std::array&lt;MyClass, 3&gt; arr6 = {MyClass(1), MyClass(2), MyClass(3)};
std::array&lt;MyClass, 3&gt; arr7{MyClass(1), MyClass(2), MyClass(3)};

// std::vector (dynamic array)
#include &lt;vector&gt;
std::vector&lt;MyClass&gt; vec1;                // Empty vector
std::vector&lt;MyClass&gt; vec2(5);             // 5 default-constructed objects
std::vector&lt;MyClass&gt; vec3(5, MyClass(42)); // 5 copies of MyClass(42)
std::vector&lt;MyClass&gt; vec4{MyClass(1), MyClass(2), MyClass(3)};  // Initializer list
</code></pre>
<h3 id="9-emplace-construction"><a class="header" href="#9-emplace-construction">9. <strong>Emplace Construction</strong></a></h3>
<p>Constructing objects in-place within containers (C++11).</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;map&gt;

std::vector&lt;MyClass&gt; vec;

// push_back creates temporary and moves/copies it
vec.push_back(MyClass(10));

// emplace_back constructs directly in the vector (more efficient)
vec.emplace_back(20);  // Constructs MyClass(20) in-place

// Similarly for maps
std::map&lt;int, MyClass&gt; myMap;
myMap.emplace(1, MyClass(100));        // Creates pair in-place
myMap.try_emplace(2, 200);             // Even better, doesn't construct if key exists

// emplace with multiple arguments
struct Person {
    std::string name;
    int age;
    Person(std::string n, int a) : name(n), age(a) {}
};

std::vector&lt;Person&gt; people;
people.emplace_back("Alice", 30);  // Constructs Person directly in vector
</code></pre>
<h3 id="10-raii-pattern-resource-acquisition-is-initialization"><a class="header" href="#10-raii-pattern-resource-acquisition-is-initialization">10. <strong>RAII Pattern (Resource Acquisition Is Initialization)</strong></a></h3>
<p>Tying resource lifetime to object lifetime.</p>
<pre><code class="language-cpp">class FileHandler {
    FILE* file;
public:
    // Resource acquired in constructor
    FileHandler(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) throw std::runtime_error("Failed to open file");
    }

    // Resource released in destructor
    ~FileHandler() {
        if (file) {
            fclose(file);
        }
    }

    // Prevent copying
    FileHandler(const FileHandler&amp;) = delete;
    FileHandler&amp; operator=(const FileHandler&amp;) = delete;

    // Allow moving
    FileHandler(FileHandler&amp;&amp; other) noexcept : file(other.file) {
        other.file = nullptr;
    }

    FILE* get() { return file; }
};

// Usage - no need to manually close file
void processFile() {
    FileHandler handler("data.txt", "r");
    // Use handler.get()...
    // File automatically closed when handler goes out of scope
}
</code></pre>
<h3 id="11-copy-elision-and-rvo-return-value-optimization"><a class="header" href="#11-copy-elision-and-rvo-return-value-optimization">11. <strong>Copy Elision and RVO (Return Value Optimization)</strong></a></h3>
<p>The compiler can optimize away unnecessary copies.</p>
<pre><code class="language-cpp">MyClass createObject() {
    MyClass obj(100);
    return obj;  // RVO: object constructed directly in caller's space
}

MyClass obj1 = createObject();  // No copy/move, direct construction (C++17 guaranteed)

// Named Return Value Optimization (NRVO)
MyClass createNamed(int value) {
    MyClass result(value);
    // ... operations on result
    return result;  // May be optimized (not guaranteed)
}
</code></pre>
<h3 id="best-practices-for-object-instantiation"><a class="header" href="#best-practices-for-object-instantiation">Best Practices for Object Instantiation</a></h3>
<ol>
<li><strong>Prefer stack allocation</strong> when possible - it’s fastest and safest</li>
<li><strong>Use smart pointers</strong> instead of raw new/delete for heap allocation</li>
<li><strong>Use <code>std::make_unique</code> and <code>std::make_shared</code></strong> for creating smart pointers</li>
<li><strong>Use uniform initialization <code>{}</code></strong> to avoid most vexing parse and narrowing conversions</li>
<li><strong>Use <code>emplace</code> methods</strong> in containers for in-place construction</li>
<li><strong>Follow RAII principles</strong> for resource management</li>
<li><strong>Prefer <code>std::vector</code> and <code>std::array</code></strong> over raw arrays</li>
<li><strong>Avoid naked <code>new</code></strong> - use smart pointers or containers</li>
</ol>
<pre><code class="language-cpp">// Good practices example
void goodPractices() {
    // Stack allocation when lifetime is scoped
    MyClass local(42);

    // Smart pointers for heap allocation
    auto ptr = std::make_unique&lt;MyClass&gt;(100);

    // Uniform initialization
    MyClass obj{50};

    // Containers for collections
    std::vector&lt;MyClass&gt; vec;
    vec.emplace_back(10);
    vec.emplace_back(20);

    // RAII for resources
    std::ifstream file("data.txt");
    // File automatically closed
}
</code></pre>
<h2 id="c-strings-and-their-methods"><a class="header" href="#c-strings-and-their-methods">C++ Strings and Their Methods</a></h2>
<p>In C++, the <code>std::string</code> class provides a powerful and flexible way to handle strings. It offers a variety of methods for string manipulation, making it easier to perform common operations without dealing with low-level character arrays. Below are some of the most commonly used <code>std::string</code> methods in detail:</p>
<h3 id="1-constructors"><a class="header" href="#1-constructors">1. <strong>Constructors</strong></a></h3>
<p><code>std::string</code> offers multiple constructors to initialize strings in different ways.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

// Default constructor
std::string str1;

// Constructor with a C-string
std::string str2("Hello, World!");

// Constructor with a specific number of repeated characters
std::string str3(5, 'a'); // "aaaaa"

// Copy constructor
std::string str4(str2);

// Substring constructor
std::string str5(str2, 7, 5); // "World"
</code></pre>
<h3 id="2-size-and-capacity"><a class="header" href="#2-size-and-capacity">2. <strong>Size and Capacity</strong></a></h3>
<ul>
<li><code>size()</code> / <code>length()</code>: Returns the number of characters in the string.</li>
<li><code>capacity()</code>: Returns the size of the storage space currently allocated for the string.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Example";
size_t len = str.size(); // 7
size_t cap = str.capacity(); // Implementation-defined
</code></pre>
<h3 id="3-accessing-characters"><a class="header" href="#3-accessing-characters">3. <strong>Accessing Characters</strong></a></h3>
<ul>
<li><code>operator[]</code>: Accesses character at a specific index.</li>
<li><code>at()</code>: Accesses character at a specific index with bounds checking.</li>
<li><code>front()</code> / <code>back()</code>: Accesses the first and last characters.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello";
char ch = str[1]; // 'e'
char ch_at = str.at(2); // 'l'
char first = str.front(); // 'H'
char last = str.back(); // 'o'
</code></pre>
<h3 id="4-modifiers"><a class="header" href="#4-modifiers">4. <strong>Modifiers</strong></a></h3>
<ul>
<li><code>append()</code>: Adds characters to the end of the string.</li>
<li><code>clear()</code>: Removes all characters from the string.</li>
<li><code>insert()</code>: Inserts characters at a specified position.</li>
<li><code>erase()</code>: Removes characters from a specified position.</li>
<li><code>replace()</code>: Replaces part of the string with another string.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello";
str.append(", World!"); // "Hello, World!"
str.insert(5, " C++"); // "Hello C++, World!"
str.erase(5, 6); // "HelloWorld!"
str.replace(5, 5, " C++"); // "Hello C++!"
str.clear(); // ""
</code></pre>
<h3 id="5-substring-and-extracting"><a class="header" href="#5-substring-and-extracting">5. <strong>Substring and Extracting</strong></a></h3>
<ul>
<li><code>substr()</code>: Returns a substring starting from a specified position.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello, World!";
std::string sub = str.substr(7, 5); // "World"
</code></pre>
<h3 id="6-finding-characters-and-substrings"><a class="header" href="#6-finding-characters-and-substrings">6. <strong>Finding Characters and Substrings</strong></a></h3>
<ul>
<li><code>find()</code>: Searches for a substring or character and returns the position.</li>
<li><code>rfind()</code>: Searches for a substring or character from the end.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello, World!";
size_t pos = str.find("World"); // 7
size_t rpos = str.rfind('o'); // 8
</code></pre>
<h3 id="7-comparison"><a class="header" href="#7-comparison">7. <strong>Comparison</strong></a></h3>
<ul>
<li><code>compare()</code>: Compares two strings.</li>
</ul>
<pre><code class="language-cpp">std::string str1 = "apple";
std::string str2 = "banana";

int result = str1.compare(str2);
// result &lt; 0 since "apple" &lt; "banana"
</code></pre>
<h3 id="8-conversion-to-c-string"><a class="header" href="#8-conversion-to-c-string">8. <strong>Conversion to C-string</strong></a></h3>
<ul>
<li><code>c_str()</code>: Returns a C-style null-terminated string.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello";
const char* cstr = str.c_str();
</code></pre>
<h3 id="9-iterators"><a class="header" href="#9-iterators">9. <strong>Iterators</strong></a></h3>
<p><code>std::string</code> supports iterators to traverse the string.</p>
<pre><code class="language-cpp">std::string str = "Hello";
for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; ' ';
}
// Output: H e l l o 
</code></pre>
<h3 id="10-emplace-and-emplace_back"><a class="header" href="#10-emplace-and-emplace_back">10. <strong>Emplace and Emplace_back</strong></a></h3>
<ul>
<li><code>emplace()</code>: Constructs and inserts a substring.</li>
<li><code>emplace_back()</code>: Appends a character to the end of the string.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello";
str.emplace(str.size(), '!'); // "Hello!"
str.emplace_back('?'); // "Hello!?"
</code></pre>
<h3 id="11-swap"><a class="header" href="#11-swap">11. <strong>Swap</strong></a></h3>
<ul>
<li><code>swap()</code>: Swaps the contents of two strings.</li>
</ul>
<pre><code class="language-cpp">std::string str1 = "Hello";
std::string str2 = "World";
str1.swap(str2);
// str1 is now "World", str2 is now "Hello"
</code></pre>
<h3 id="12-transform"><a class="header" href="#12-transform">12. <strong>Transform</strong></a></h3>
<p>You can apply transformations to each character using algorithms.</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;

std::string str = "Hello";
std::transform(str.begin(), str.end(), str.begin(), ::toupper); // "HELLO"
</code></pre>
<h3 id="13-other-useful-methods"><a class="header" href="#13-other-useful-methods">13. <strong>Other Useful Methods</strong></a></h3>
<ul>
<li><code>empty()</code>: Checks if the string is empty.</li>
<li><code>find_first_of()</code> / <code>find_last_of()</code>: Finds the first/last occurrence of any character from a set.</li>
<li><code>find_first_not_of()</code> / <code>find_last_not_of()</code>: Finds the first/last character not in a set.</li>
</ul>
<pre><code class="language-cpp">std::string str = "Hello";
bool isEmpty = str.empty(); // false
size_t pos = str.find_first_of('e'); // 1
size_t not_pos = str.find_first_not_of('H'); // 1
</code></pre>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string greeting = "Hello";
    greeting += ", World!"; // Using operator +=
    
    std::cout &lt;&lt; greeting &lt;&lt; std::endl; // Output: Hello, World!
    
    // Find and replace
    size_t pos = greeting.find("World");
    if (pos != std::string::npos) {
        greeting.replace(pos, 5, "C++");
    }
    
    std::cout &lt;&lt; greeting &lt;&lt; std::endl; // Output: Hello, C++!
    
    return 0;
}
</code></pre>
<p>Understanding and utilizing these <code>std::string</code> methods can greatly enhance your ability to manipulate and manage text in C++ applications effectively.</p>
<h2 id="c-vectors-and-their-methods"><a class="header" href="#c-vectors-and-their-methods">C++ Vectors and Their Methods</a></h2>
<p>In C++, the <code>std::vector</code> class template provides a dynamic array that can resize itself automatically when elements are added or removed. It offers numerous methods to manipulate the data efficiently. Below are detailed explanations and examples of various <code>std::vector</code> methods:</p>
<h3 id="1-constructors-1"><a class="header" href="#1-constructors-1">1. <strong>Constructors</strong></a></h3>
<p><code>std::vector</code> offers multiple constructors to initialize vectors in different ways.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;

// Default constructor
std::vector&lt;int&gt; vec1;

// Constructor with a specific size
std::vector&lt;int&gt; vec2(5); // {0, 0, 0, 0, 0}

// Constructor with a specific size and initial value
std::vector&lt;int&gt; vec3(5, 10); // {10, 10, 10, 10, 10}

// Initializer list constructor
std::vector&lt;int&gt; vec4 = {1, 2, 3, 4, 5};

// Copy constructor
std::vector&lt;int&gt; vec5(vec4);
</code></pre>
<h3 id="2-size-and-capacity-1"><a class="header" href="#2-size-and-capacity-1">2. <strong>Size and Capacity</strong></a></h3>
<ul>
<li><code>size()</code>: Returns the number of elements in the vector.</li>
<li><code>capacity()</code>: Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.</li>
<li><code>empty()</code>: Checks whether the vector is empty.</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3};
size_t sz = vec.size(); // 3
size_t cap = vec.capacity(); // &gt;= 3
bool isEmpty = vec.empty(); // false
</code></pre>
<h3 id="3-element-access"><a class="header" href="#3-element-access">3. <strong>Element Access</strong></a></h3>
<ul>
<li><code>operator[]</code>: Accesses element at a specific index without bounds checking.</li>
<li><code>at()</code>: Accesses element at a specific index with bounds checking.</li>
<li><code>front()</code>: Accesses the first element.</li>
<li><code>back()</code>: Accesses the last element.</li>
<li><code>data()</code>: Returns a pointer to the underlying array.</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {10, 20, 30, 40, 50};
int first = vec[0]; // 10
int third = vec.at(2); // 30
int front = vec.front(); // 10
int back = vec.back(); // 50
int* ptr = vec.data(); // Pointer to the first element
</code></pre>
<h3 id="4-modifiers-1"><a class="header" href="#4-modifiers-1">4. <strong>Modifiers</strong></a></h3>
<ul>
<li><code>push_back()</code>: Adds an element to the end of the vector.</li>
<li><code>pop_back()</code>: Removes the last element of the vector.</li>
<li><code>insert()</code>: Inserts elements at a specified position.</li>
<li><code>erase()</code>: Removes elements from a specified position or range.</li>
<li><code>clear()</code>: Removes all elements from the vector.</li>
<li><code>resize()</code>: Changes the number of elements stored.</li>
<li><code>shrink_to_fit()</code>: Reduces capacity to fit the size.</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3};

// push_back
vec.push_back(4); // {1, 2, 3, 4}

// pop_back
vec.pop_back(); // {1, 2, 3}

// insert
vec.insert(vec.begin() + 1, 10); // {1, 10, 2, 3}

// erase single element
vec.erase(vec.begin() + 2); // {1, 10, 3}

// erase range
vec.erase(vec.begin(), vec.begin() + 1); // {10, 3}

// clear
vec.clear(); // {}

// resize
vec.resize(5, 100); // {100, 100, 100, 100, 100}

// shrink_to_fit
vec.shrink_to_fit();
</code></pre>
<h3 id="5-iterators"><a class="header" href="#5-iterators">5. <strong>Iterators</strong></a></h3>
<p>Vectors support iterators to traverse and manipulate elements.</p>
<ul>
<li><code>begin()</code>: Returns an iterator to the first element.</li>
<li><code>end()</code>: Returns an iterator to one past the last element.</li>
<li><code>rbegin()</code>: Returns a reverse iterator to the last element.</li>
<li><code>rend()</code>: Returns a reverse iterator to one before the first element.</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};

// Forward iteration
for(auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
}

// Reverse iteration
for(auto it = vec.rbegin(); it != vec.rend(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
}
</code></pre>
<h3 id="6-algorithms-support"><a class="header" href="#6-algorithms-support">6. <strong>Algorithms Support</strong></a></h3>
<p>Vectors work seamlessly with standard algorithms from the C++ Standard Library.</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;

std::vector&lt;int&gt; vec = {5, 3, 1, 4, 2};

// Sort the vector
std::sort(vec.begin(), vec.end()); // {1, 2, 3, 4, 5}

// Reverse the vector
std::reverse(vec.begin(), vec.end()); // {5, 4, 3, 2, 1}

// Find an element
auto it = std::find(vec.begin(), vec.end(), 3);
if(it != vec.end()) {
    std::cout &lt;&lt; "Found: " &lt;&lt; *it &lt;&lt; std::endl;
}
</code></pre>
<h3 id="7-capacity-management"><a class="header" href="#7-capacity-management">7. <strong>Capacity Management</strong></a></h3>
<ul>
<li><code>reserve()</code>: Increases the capacity of the vector to a value that’s greater or equal to the specified.</li>
<li><code>capacity()</code>: Explained earlier.</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec;
vec.reserve(100); // Reserve space for 100 elements
std::cout &lt;&lt; "Capacity: " &lt;&lt; vec.capacity() &lt;&lt; std::endl;
</code></pre>
<p>Understanding and utilizing <code>std::vector</code> and its various methods can significantly enhance the efficiency and flexibility of your C++ programs, allowing for dynamic memory management and rich data manipulation capabilities.</p>
<h3 id="4-maps"><a class="header" href="#4-maps">4. <strong>Maps</strong></a></h3>
<p>C++ provides the <code>std::map</code> container, which is an associative container that stores elements formed by a combination of a key and a value. <code>std::map</code> automatically sorts its elements by key and allows fast retrieval of individual elements based on their keys.</p>
<h4 id="constructors"><a class="header" href="#constructors">Constructors</a></h4>
<p><code>std::map</code> offers multiple constructors to initialize maps in different ways.</p>
<pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;string&gt;

// Default constructor
std::map&lt;int, std::string&gt; map1;

// Initializer list constructor
std::map&lt;int, std::string&gt; map2 = {
    {1, "one"},
    {2, "two"},
    {3, "three"}
};

// Range constructor
std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec = { {4, "four"}, {5, "five"} };
std::map&lt;int, std::string&gt; map3(vec.begin(), vec.end());

// Copy constructor
std::map&lt;int, std::string&gt; map4(map2);
</code></pre>
<h4 id="size-and-capacity"><a class="header" href="#size-and-capacity">Size and Capacity</a></h4>
<ul>
<li><code>size()</code>: Returns the number of elements in the map.</li>
<li><code>empty()</code>: Checks whether the map is empty.</li>
</ul>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; map = { {1, "one"}, {2, "two"}, {3, "three"} };
size_t sz = map.size(); // 3
bool isEmpty = map.empty(); // false
</code></pre>
<h4 id="element-access"><a class="header" href="#element-access">Element Access</a></h4>
<ul>
<li><code>operator[]</code>: Accesses or inserts elements with the given key.</li>
<li><code>at()</code>: Accesses elements with bounds checking.</li>
<li><code>find()</code>: Finds an element with a specific key.</li>
<li><code>count()</code>: Returns the number of elements with a specific key.</li>
</ul>
<pre><code class="language-cpp">// Using operator[]
map[4] = "four"; // Inserts if key 4 does not exist

// Using at()
try {
    std::string value = map.at(2); // "two"
} catch(const std::out_of_range&amp; e) {
    // Handle error
}

// Using find()
auto it = map.find(3);
if(it != map.end()) {
    std::cout &lt;&lt; "Found: " &lt;&lt; it-&gt;second &lt;&lt; std::endl; // "three"
}

// Using count()
if(map.count(5)) {
    std::cout &lt;&lt; "Key 5 exists." &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Key 5 does not exist." &lt;&lt; std::endl;
}
</code></pre>
<h4 id="inserting-elements"><a class="header" href="#inserting-elements">Inserting Elements</a></h4>
<ul>
<li><code>insert()</code>: Inserts elements into the map.</li>
<li><code>emplace()</code>: Constructs elements in-place.</li>
</ul>
<pre><code class="language-cpp">// Using insert()
map.insert({1, "one"});
map.insert(std::pair&lt;int, std::string&gt;(2, "two"));

// Using emplace()
map.emplace(3, "three");
</code></pre>
<h4 id="deleting-elements"><a class="header" href="#deleting-elements">Deleting Elements</a></h4>
<ul>
<li><code>erase()</code>: Removes elements by key or iterator.</li>
<li><code>clear()</code>: Removes all elements from the map.</li>
</ul>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; map = { {1, "one"}, {2, "two"}, {3, "three"} };

// Erase by key
map.erase(2);

// Erase by iterator
auto itErase = map.find(3);
if(itErase != map.end()) {
    map.erase(itErase);
}

// Clear all elements
map.clear();
</code></pre>
<h4 id="iterating-through-a-map"><a class="header" href="#iterating-through-a-map">Iterating Through a Map</a></h4>
<pre><code class="language-cpp">std::map&lt;int, std::string&gt; map = { {1, "one"}, {2, "two"}, {3, "three"} };

// Using iterator
for(auto it = map.begin(); it != map.end(); ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}

// Using range-based for loop
for(const auto&amp; pair : map) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; std::endl;
}
</code></pre>
<p>Understanding and utilizing <code>std::map</code> and its various methods can greatly enhance your ability to manage key-value pairs efficiently in C++ applications.</p>
<h3 id="4-smart-pointers"><a class="header" href="#4-smart-pointers">4. <strong>Smart Pointers</strong></a></h3>
<p>Smart pointers in C++ are template classes provided by the Standard Library that facilitate automatic and exception-safe memory management. They help manage dynamically allocated objects by ensuring that resources are properly released when they are no longer needed, thus preventing memory leaks and other related issues. C++ offers several types of smart pointers, each tailored to specific use cases and ownership semantics.</p>
<h4 id="types-of-smart-pointers"><a class="header" href="#types-of-smart-pointers">Types of Smart Pointers</a></h4>
<ol>
<li><strong><code>std::unique_ptr</code></strong></li>
<li><strong><code>std::shared_ptr</code></strong></li>
<li><strong><code>std::weak_ptr</code></strong></li>
</ol>
<hr>
<h4 id="1-stdunique_ptr"><a class="header" href="#1-stdunique_ptr">1. <code>std::unique_ptr</code></a></h4>
<p><code>std::unique_ptr</code> is a smart pointer that owns and manages another object through a pointer and disposes of that object when the <code>unique_ptr</code> goes out of scope. It ensures exclusive ownership, meaning that there can be only one <code>unique_ptr</code> instance owning a particular object at any given time.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Exclusive Ownership:</strong> Only one <code>std::unique_ptr</code> can own the object at a time.</li>
<li><strong>No Copying:</strong> <code>unique_ptr</code> cannot be copied to prevent multiple ownerships. However, it can be moved.</li>
<li><strong>Lightweight:</strong> Minimal overhead compared to raw pointers.</li>
</ul>
<p><strong>Usage Example:</strong></p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

int main() {
    // Creating a unique_ptr to an integer
    std::unique_ptr&lt;int&gt; ptr1(new int(10));
    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr1 &lt;&lt; std::endl; // Output: Value: 10

    // Transferring ownership using std::move
    std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1);
    if (!ptr1) {
        std::cout &lt;&lt; "ptr1 is now null." &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr2 &lt;&lt; std::endl; // Output: Value: 10

    // Automatic deletion when ptr2 goes out of scope
    return 0;
}
</code></pre>
<p><strong>Common Methods:</strong></p>
<ul>
<li><strong><code>get()</code></strong>: Returns the raw pointer.</li>
<li><strong><code>release()</code></strong>: Releases ownership of the managed object and returns the pointer.</li>
<li><strong><code>reset()</code></strong>: Deletes the currently managed object and takes ownership of a new one.</li>
<li><strong><code>operator*</code> and <code>operator-&gt;</code></strong>: Dereference operators to access the managed object.</li>
</ul>
<hr>
<h4 id="2-stdshared_ptr"><a class="header" href="#2-stdshared_ptr">2. <code>std::shared_ptr</code></a></h4>
<p><code>std::shared_ptr</code> is a smart pointer that maintains shared ownership of an object through a pointer. Multiple <code>shared_ptr</code> instances can own the same object, and the object is destroyed only when the last <code>shared_ptr</code> owning it is destroyed or reset.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Shared Ownership:</strong> Multiple <code>shared_ptr</code> instances can own the same object.</li>
<li><strong>Reference Counting:</strong> Keeps track of how many <code>shared_ptr</code> instances own the object.</li>
<li><strong>Thread-Safe Reference Counting:</strong> Safe to use in multi-threaded applications for reference counting operations.</li>
</ul>
<p><strong>Usage Example:</strong></p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

int main() {
    // Creating a shared_ptr to an integer
    std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(20);
    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr1 &lt;&lt; ", Count: " &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // Output: Value: 20, Count: 1

    // Creating another shared_ptr sharing the same object
    std::shared_ptr&lt;int&gt; ptr2 = ptr1;
    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr2 &lt;&lt; ", Count: " &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // Output: Value: 20, Count: 2

    // Resetting ptr1
    ptr1.reset();
    std::cout &lt;&lt; "ptr1 reset. Count: " &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; // Output: Count: 1

    // Automatic deletion when ptr2 goes out of scope
    return 0;
}
</code></pre>
<p><strong>Common Methods:</strong></p>
<ul>
<li><strong><code>use_count()</code></strong>: Returns the number of <code>shared_ptr</code> instances sharing ownership.</li>
<li><strong><code>unique()</code></strong>: Checks if the <code>shared_ptr</code> is the only owner.</li>
<li><strong><code>reset()</code></strong>: Releases ownership of the managed object.</li>
<li><strong><code>swap()</code></strong>: Exchanges the managed object with another <code>shared_ptr</code>.</li>
</ul>
<hr>
<h4 id="3-stdweak_ptr"><a class="header" href="#3-stdweak_ptr">3. <code>std::weak_ptr</code></a></h4>
<p><code>std::weak_ptr</code> is a smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <code>std::shared_ptr</code>. It is used to prevent circular references that can lead to memory leaks by allowing one part of the code to observe an object without affecting its lifetime.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Non-Owning:</strong> Does not contribute to the reference count.</li>
<li><strong>Avoids Circular References:</strong> Useful in scenarios like bidirectional relationships.</li>
<li><strong>Access Controlled:</strong> Must be converted to <code>std::shared_ptr</code> to access the managed object.</li>
</ul>
<p><strong>Usage Example:</strong></p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

struct Node {
    int value;
    std::shared_ptr&lt;Node&gt; next;
    std::weak_ptr&lt;Node&gt; prev; // Using weak_ptr to prevent circular reference

    Node(int val) : value(val), next(nullptr), prev() {}
};

int main() {
    auto node1 = std::make_shared&lt;Node&gt;(1);
    auto node2 = std::make_shared&lt;Node&gt;(2);

    node1-&gt;next = node2;
    node2-&gt;prev = node1; // weak_ptr does not increase reference count

    std::cout &lt;&lt; "Node1 value: " &lt;&lt; node1-&gt;value &lt;&lt; std::endl;
    std::cout &lt;&lt; "Node2 value: " &lt;&lt; node2-&gt;value &lt;&lt; std::endl;

    // Accessing the previous node
    if(auto prev = node2-&gt;prev.lock()) {
        std::cout &lt;&lt; "Node2's previous node value: " &lt;&lt; prev-&gt;value &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Previous node no longer exists." &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p><strong>Common Methods:</strong></p>
<ul>
<li><strong><code>lock()</code></strong>: Attempts to acquire a <code>std::shared_ptr</code> to the managed object.</li>
<li><strong><code>expired()</code></strong>: Checks if the managed object has been deleted.</li>
<li><strong><code>reset()</code></strong>: Releases the managed object reference.</li>
</ul>
<hr>
<h4 id="common-methods-across-smart-pointers"><a class="header" href="#common-methods-across-smart-pointers">Common Methods Across Smart Pointers</a></h4>
<p>While each smart pointer type has its specific methods, there are several common methods that they share:</p>
<ul>
<li>
<p><strong><code>get()</code></strong>: Returns the raw pointer managed by the smart pointer.</p>
<pre><code class="language-cpp">std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(100);
int* rawPtr = ptr.get();
std::cout &lt;&lt; "Raw pointer value: " &lt;&lt; *rawPtr &lt;&lt; std::endl; // Output: 100
</code></pre>
</li>
<li>
<p><strong><code>reset()</code></strong>: Releases the ownership of the managed object and optionally takes ownership of a new object.</p>
<pre><code class="language-cpp">std::shared_ptr&lt;int&gt; ptr = std::make_shared&lt;int&gt;(200);
ptr.reset(new int(300)); // Old object is deleted, ptr now owns the new object
std::cout &lt;&lt; "New value: " &lt;&lt; *ptr &lt;&lt; std::endl; // Output: 300
</code></pre>
</li>
<li>
<p><strong><code>swap()</code></strong>: Exchanges the managed objects of two smart pointers.</p>
<pre><code class="language-cpp">std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(400);
std::unique_ptr&lt;int&gt; ptr2 = std::make_unique&lt;int&gt;(500);
ptr1.swap(ptr2);
std::cout &lt;&lt; "ptr1: " &lt;&lt; *ptr1 &lt;&lt; ", ptr2: " &lt;&lt; *ptr2 &lt;&lt; std::endl; // Output: ptr1: 500, ptr2: 400
</code></pre>
</li>
<li>
<p><strong>Dereference Operators (<code>*</code> and <code>-&gt;</code>)</strong>: Access the managed object.</p>
<pre><code class="language-cpp">std::shared_ptr&lt;std::string&gt; ptr = std::make_shared&lt;std::string&gt;("Hello");
std::cout &lt;&lt; "String: " &lt;&lt; *ptr &lt;&lt; std::endl; // Output: Hello
std::cout &lt;&lt; "String length: " &lt;&lt; ptr-&gt;length() &lt;&lt; std::endl; // Output: 5
</code></pre>
</li>
</ul>
<hr>
<h4 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h4>
<ul>
<li>
<p><strong>Prefer <code>std::make_unique</code> and <code>std::make_shared</code>:</strong> These functions are exception-safe and more efficient.</p>
<pre><code class="language-cpp">auto ptr = std::make_unique&lt;MyClass&gt;();
auto sharedPtr = std::make_shared&lt;MyClass&gt;();
</code></pre>
</li>
<li>
<p><strong>Use <code>std::unique_ptr</code> When Ownership is Exclusive:</strong> It clearly signifies ownership semantics and incurs no overhead of reference counting.</p>
<pre><code class="language-cpp">std::unique_ptr&lt;Resource&gt; resource = std::make_unique&lt;Resource&gt;();
</code></pre>
</li>
<li>
<p><strong>Use <code>std::shared_ptr</code> When Ownership is Shared:</strong> Useful in scenarios where multiple parts of the program need to share access to the same resource.</p>
<pre><code class="language-cpp">std::shared_ptr&lt;Logger&gt; logger1 = std::make_shared&lt;Logger&gt;();
std::shared_ptr&lt;Logger&gt; logger2 = logger1;
</code></pre>
</li>
<li>
<p><strong>Avoid <code>std::shared_ptr</code> Unless Necessary:</strong> It introduces overhead due to reference counting. Use it only when shared ownership is required.</p>
</li>
<li>
<p><strong>Break Circular References with <code>std::weak_ptr</code>:</strong> When two objects share ownership via <code>std::shared_ptr</code>, use <code>std::weak_ptr</code> to prevent memory leaks.</p>
<pre><code class="language-cpp">struct A {
    std::shared_ptr&lt;B&gt; b_ptr;
};

struct B {
    std::weak_ptr&lt;A&gt; a_ptr; // weak_ptr breaks the circular reference
};
</code></pre>
</li>
</ul>
<hr>
<p>Understanding and effectively utilizing smart pointers is crucial for modern C++ programming. They not only simplify memory management but also enhance the safety and performance of applications by preventing common issues related to dynamic memory allocation.</p>
<h3 id="5-stdfunction-and-stdbind"><a class="header" href="#5-stdfunction-and-stdbind">5. <strong><code>std::function</code> and <code>std::bind</code></strong></a></h3>
<p><code>std::function</code> and <code>std::bind</code> are powerful utilities in the C++ Standard Library that facilitate higher-order programming by allowing functions to be treated as first-class objects. They enable the storage, modification, and invocation of functions in a flexible and generic manner, enhancing the capabilities of callback mechanisms, event handling, and functional programming paradigms in C++.</p>
<h4 id="stdfunction"><a class="header" href="#stdfunction"><code>std::function</code></a></h4>
<p><code>std::function</code> is a versatile, type-erased function wrapper that can store any callable target—such as free functions, member functions, lambda expressions, or other function objects—provided they match a specific function signature. This flexibility makes it an essential tool for designing callback interfaces and managing dynamic function invocation.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Type-Erasure:</strong> Abstracts away the specific type of the callable, allowing different types of callable objects to be stored in the same <code>std::function</code> variable.</li>
<li><strong>Copyable and Assignable:</strong> <code>std::function</code> instances can be copied and assigned, enabling their use in standard containers and algorithms.</li>
<li><strong>Invoke Any Callable:</strong> Can represent free functions, member functions, lambda expressions, and function objects.</li>
</ul>
<p><strong>Basic Usage Example:</strong></p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

// A free function
int add(int a, int b) {
    return a + b;
}

int main() {
    // Storing a free function in std::function
    std::function&lt;int(int, int)&gt; func = add;
    std::cout &lt;&lt; "add(2, 3) = " &lt;&lt; func(2, 3) &lt;&lt; std::endl; // Output: 5

    // Storing a lambda expression
    std::function&lt;int(int, int)&gt; lambdaFunc = [](int a, int b) -&gt; int {
        return a * b;
    };
    std::cout &lt;&lt; "lambdaFunc(2, 3) = " &lt;&lt; lambdaFunc(2, 3) &lt;&lt; std::endl; // Output: 6

    // Storing a member function (requires binding)
    struct Calculator {
        int subtract(int a, int b) const {
            return a - b;
        }
    };

    Calculator calc;
    std::function&lt;int(int, int)&gt; memberFunc = std::bind(&amp;Calculator::subtract, &amp;calc, std::placeholders::_1, std::placeholders::_2);
    std::cout &lt;&lt; "calc.subtract(5, 3) = " &lt;&lt; memberFunc(5, 3) &lt;&lt; std::endl; // Output: 2

    return 0;
}
</code></pre>
<p><strong>Common Methods:</strong></p>
<ul>
<li><strong><code>operator()</code></strong>: Invokes the stored callable.</li>
<li><strong><code>target()</code></strong>: Retrieves a pointer to the stored callable if it matches a specific type.</li>
<li><strong><code>reset()</code></strong>: Clears the stored callable, making the <code>std::function</code> empty.</li>
</ul>
<h4 id="stdbind"><a class="header" href="#stdbind"><code>std::bind</code></a></h4>
<p><code>std::bind</code> is a utility that allows you to create a new function object by binding some or all of the arguments of an existing function to specific values. This is particularly useful for adapting functions to match desired interfaces or for creating callbacks with pre-specified arguments.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Argument Binding:</strong> Fixes certain arguments of a function, producing a new function object with fewer parameters.</li>
<li><strong>Placeholders:</strong> Uses placeholders like <code>std::placeholders::_1</code> to indicate arguments that will be provided later.</li>
<li><strong>Supports Various Callables:</strong> Can bind free functions, member functions, and function objects.</li>
</ul>
<p><strong>Basic Usage Example:</strong></p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

// A free function
int multiply(int a, int b) {
    return a * b;
}

struct Calculator {
    int divide(int a, int b) const {
        if(b == 0) throw std::invalid_argument("Division by zero");
        return a / b;
    }
};

int main() {
    // Binding the first argument of multiply to 5
    auto timesFive = std::bind(multiply, 5, std::placeholders::_1);
    std::cout &lt;&lt; "multiply(5, 4) = " &lt;&lt; timesFive(4) &lt;&lt; std::endl; // Output: 20

    // Binding a member function with the object instance
    Calculator calc;
    auto divideBy = std::bind(&amp;Calculator::divide, &amp;calc, std::placeholders::_1, 2);
    std::cout &lt;&lt; "calc.divide(10, 2) = " &lt;&lt; divideBy(10) &lt;&lt; std::endl; // Output: 5

    return 0;
}
</code></pre>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li><strong>Creating Callbacks:</strong> Adapting functions to match callback interfaces that require a specific signature.</li>
<li><strong>Event Handling:</strong> Binding member functions of objects to event handlers with predefined arguments.</li>
<li><strong>Functional Programming:</strong> Enabling partial application and currying of functions for more functional-style code.</li>
</ul>
<p><strong>Advanced Usage Example:</strong></p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class Logger {
public:
    void log(const std::string&amp; message, int level) const {
        std::cout &lt;&lt; "Level " &lt;&lt; level &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl;
    }
};

int main() {
    Logger logger;

    // Binding the logger object and log level to create a simplified log function
    auto infoLog = std::bind(&amp;Logger::log, &amp;logger, std::placeholders::_1, 1);
    auto errorLog = std::bind(&amp;Logger::log, &amp;logger, std::placeholders::_1, 3);

    infoLog("This is an informational message."); // Output: Level 1: This is an informational message.
    errorLog("This is an error message."); // Output: Level 3: This is an error message.

    // Storing bind expressions in a std::vector of std::function
    std::vector&lt;std::function&lt;void(const std::string&amp;)&gt;&gt; logs;
    logs.push_back(infoLog);
    logs.push_back(errorLog);

    for(auto&amp; logFunc : logs) {
        logFunc("Logging through stored function.");
    }
    // Output:
    // Level 1: Logging through stored function.
    // Level 3: Logging through stored function.

    return 0;
}
</code></pre>
<p><strong>Best Practices:</strong></p>
<ul>
<li>
<p><strong>Prefer Lambda Expressions Over <code>std::bind</code>:</strong> Lambdas often provide clearer and more readable syntax compared to <code>std::bind</code>.</p>
<pre><code class="language-cpp">// Using std::bind
auto timesFive = std::bind(multiply, 5, std::placeholders::_1);

// Equivalent using a lambda
auto timesFiveLambda = [](int a) -&gt; int {
    return multiply(5, a);
};
</code></pre>
</li>
<li>
<p><strong>Use <code>std::function</code> for Flexibility:</strong> When storing or passing callable objects that may vary in type, use <code>std::function</code> to accommodate different callables.</p>
</li>
<li>
<p><strong>Avoid Unnecessary Bindings:</strong> Excessive use of <code>std::bind</code> can lead to less readable code. Assess whether a lambda or a direct function call may be more appropriate.</p>
</li>
</ul>
<p>By leveraging <code>std::function</code> and <code>std::bind</code>, developers can create more abstract, flexible, and reusable code components, facilitating sophisticated callback mechanisms and enhancing the expressive power of C++.</p>
<h2 id="c-in-competitive-programming"><a class="header" href="#c-in-competitive-programming">C++ in Competitive Programming</a></h2>
<p>Competitive programming demands not only a deep understanding of algorithms and data structures but also the ability to implement them efficiently within strict time and memory constraints. C++ is a favored language in this arena due to its performance, rich Standard Template Library (STL), and powerful language features. Below are various methods and techniques in C++ that are extensively used in competitive programming:</p>
<h3 id="1-fast-inputoutput"><a class="header" href="#1-fast-inputoutput">1. <strong>Fast Input/Output</strong></a></h3>
<p>Efficient handling of input and output can significantly reduce execution time, especially with large datasets.</p>
<ul>
<li>
<p><strong>Untie C++ Streams from C Streams:</strong></p>
<pre><code class="language-cpp">std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
</code></pre>
<p>Disabling the synchronization between C and C++ standard streams and untieing <code>cin</code> from <code>cout</code> can speed up I/O operations.</p>
</li>
<li>
<p><strong>Use of <code>scanf</code> and <code>printf</code>:</strong>
For even faster I/O, some competitors prefer using C-style I/O functions.</p>
</li>
</ul>
<h3 id="2-utilizing-the-standard-template-library-stl"><a class="header" href="#2-utilizing-the-standard-template-library-stl">2. <strong>Utilizing the Standard Template Library (STL)</strong></a></h3>
<p>The STL provides a suite of ready-to-use data structures and algorithms that can save time and reduce the likelihood of bugs.</p>
<ul>
<li>
<p><strong>Vectors (<code>std::vector</code>):</strong>
Dynamic arrays that allow for efficient random access and dynamic resizing.</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3};
vec.push_back(4);
</code></pre>
</li>
<li>
<p><strong>Pairs and Tuples (<code>std::pair</code>, <code>std::tuple</code>):</strong>
Useful for storing multiple related values.</p>
<pre><code class="language-cpp">std::pair&lt;int, int&gt; p = {1, 2};
std::tuple&lt;int, int, int&gt; t = {1, 2, 3};
</code></pre>
</li>
<li>
<p><strong>Sets and Maps (<code>std::set</code>, <code>std::map</code>):</strong>
Efficiently handle unique elements and key-value associations.</p>
</li>
<li>
<p><strong>Algorithms (<code>std::sort</code>, <code>std::binary_search</code>, etc.):</strong>
Implement common algorithms with optimized performance.</p>
</li>
</ul>
<h3 id="3-graph-representations-and-algorithms"><a class="header" href="#3-graph-representations-and-algorithms">3. <strong>Graph Representations and Algorithms</strong></a></h3>
<p>Graphs are a staple in competitive programming problems. Efficient representation and traversal are crucial.</p>
<ul>
<li>
<p><strong>Adjacency List:</strong></p>
<pre><code class="language-cpp">int n; // Number of nodes
std::vector&lt;std::vector&lt;int&gt;&gt; adj(n + 1);
adj[u].push_back(v);
adj[v].push_back(u); // For undirected graphs
</code></pre>
</li>
<li>
<p><strong>Depth-First Search (DFS) and Breadth-First Search (BFS):</strong>
Fundamental traversal techniques.</p>
</li>
<li>
<p><strong>Dijkstra’s and Floyd-Warshall Algorithms:</strong>
For shortest path problems.</p>
</li>
</ul>
<h3 id="4-dynamic-programming-dp"><a class="header" href="#4-dynamic-programming-dp">4. <strong>Dynamic Programming (DP)</strong></a></h3>
<p>DP is essential for solving optimization problems by breaking them down into simpler subproblems.</p>
<ul>
<li>
<p><strong>Memoization and Tabulation:</strong></p>
<pre><code class="language-cpp">// Example of Fibonacci using memoization
long long fib(int n, std::vector&lt;long long&gt; &amp;dp) {
    if(n &lt;= 1) return n;
    if(dp[n] != -1) return dp[n];
    return dp[n] = fib(n-1, dp) + fib(n-2, dp);
}
</code></pre>
</li>
<li>
<p><strong>State Optimization:</strong>
Reducing space complexity by optimizing states.</p>
</li>
</ul>
<h3 id="5-greedy-algorithms"><a class="header" href="#5-greedy-algorithms">5. <strong>Greedy Algorithms</strong></a></h3>
<p>These algorithms make the locally optimal choice at each step with the hope of finding the global optimum.</p>
<ul>
<li>
<p><strong>Interval Scheduling:</strong>
Selecting the maximum number of non-overlapping intervals.</p>
</li>
<li>
<p><strong>Huffman Coding:</strong>
For efficient encoding.</p>
</li>
</ul>
<h3 id="6-bit-manipulation"><a class="header" href="#6-bit-manipulation">6. <strong>Bit Manipulation</strong></a></h3>
<p>Bitwise operations can optimize certain calculations and are useful in problems involving subsets or binary representations.</p>
<ul>
<li>
<p><strong>Common Operations:</strong></p>
<ul>
<li>Setting a bit: <code>x | (1 &lt;&lt; pos)</code></li>
<li>Clearing a bit: <code>x &amp; ~(1 &lt;&lt; pos)</code></li>
<li>Toggling a bit: <code>x ^ (1 &lt;&lt; pos)</code></li>
</ul>
</li>
<li>
<p><strong>Bitmask DP:</strong>
Using bitmasks to represent states in DP.</p>
</li>
</ul>
<h3 id="7-number-theory"><a class="header" href="#7-number-theory">7. <strong>Number Theory</strong></a></h3>
<p>Many problems involve mathematical concepts such as primes, GCD, and modular arithmetic.</p>
<ul>
<li>
<p><strong>Sieve of Eratosthenes:</strong>
For finding all prime numbers up to a certain limit.</p>
<pre><code class="language-cpp">std::vector&lt;bool&gt; is_prime(n+1, true);
is_prime[0] = is_prime[1] = false;
for(int i=2; i*i &lt;= n; ++i){
    if(is_prime[i]){
        for(int j=i*i; j&lt;=n; j+=i){
            is_prime[j] = false;
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>Modular Exponentiation:</strong>
Efficiently computing large exponents under a modulus.</p>
<pre><code class="language-cpp">long long power(long long a, long long b, long long mod){
    long long res = 1;
    a %= mod;
    while(b &gt; 0){
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}
</code></pre>
</li>
</ul>
<h3 id="8-string-algorithms"><a class="header" href="#8-string-algorithms">8. <strong>String Algorithms</strong></a></h3>
<p>Handling and processing strings efficiently is vital in many problems.</p>
<ul>
<li>
<p><strong>KMP Algorithm:</strong>
For pattern matching with linear time complexity.</p>
</li>
<li>
<p><strong>Trie Data Structure:</strong>
Efficiently storing and searching a dynamic set of strings.</p>
</li>
</ul>
<h3 id="9-data-structures"><a class="header" href="#9-data-structures">9. <strong>Data Structures</strong></a></h3>
<p>Choosing the right data structure can make or break your solution.</p>
<ul>
<li>
<p><strong>Segment Trees and Binary Indexed Trees (Fenwick Trees):</strong>
For range queries and updates.</p>
</li>
<li>
<p><strong>Disjoint Set Union (DSU):</strong>
For efficiently handling union and find operations.</p>
<pre><code class="language-cpp">struct DSU {
    std::vector&lt;int&gt; parent;
    DSU(int n) : parent(n+1) { for(int i=0;i&lt;=n;i++) parent[i] = i; }
    int find_set(int x) { return parent[x] == x ? x : parent[x] = find_set(parent[x]); }
    void union_set(int x, int y) { parent[find_set(x)] = find_set(y); }
};
</code></pre>
</li>
<li>
<p><strong>Heaps (<code>std::priority_queue</code>):</strong>
Useful for efficiently retrieving the maximum or minimum element.</p>
</li>
</ul>
<h3 id="10-advanced-techniques"><a class="header" href="#10-advanced-techniques">10. <strong>Advanced Techniques</strong></a></h3>
<ul>
<li>
<p><strong>Meet in the Middle:</strong>
Breaking problems into two halves to reduce time complexity.</p>
</li>
<li>
<p><strong>Bitmasking and Enumeration:</strong>
Enumerating all subsets or combinations efficiently.</p>
</li>
</ul>
<h3 id="best-practices-1"><a class="header" href="#best-practices-1"><strong>Best Practices</strong></a></h3>
<ul>
<li>
<p><strong>Understand the Problem Thoroughly:</strong>
Carefully read and comprehend the problem constraints and requirements before jumping into coding.</p>
</li>
<li>
<p><strong>Practice Code Implementation:</strong>
Regularly practice implementing various algorithms and data structures to build speed and accuracy.</p>
</li>
<li>
<p><strong>Optimize and Test:</strong>
Continuously look for optimizations and thoroughly test your code against different cases to ensure correctness.</p>
</li>
<li>
<p><strong>Stay Updated:</strong>
Keep abreast of new algorithms and techniques emerging in the competitive programming community.</p>
</li>
</ul>
<p>By mastering these methods and leveraging C++’s powerful features, competitive programmers can efficiently tackle a wide array of challenging problems and excel in contests.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programming/c.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../programming/javascript.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programming/c.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../programming/javascript.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
