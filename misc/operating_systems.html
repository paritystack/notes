<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Operating Systems - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="operating-systems"><a class="header" href="#operating-systems">Operating Systems</a></h1>
<p>A comprehensive guide to operating system fundamentals, concepts, and implementations.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#operating-system-fundamentals">Operating System Fundamentals</a></li>
<li><a href="#process-management">Process Management</a></li>
<li><a href="#thread-management">Thread Management</a></li>
<li><a href="#memory-management">Memory Management</a></li>
<li><a href="#file-systems">File Systems</a></li>
<li><a href="#io-systems">I/O Systems</a></li>
<li><a href="#deadlocks">Deadlocks</a></li>
<li><a href="#security-and-protection">Security and Protection</a></li>
<li><a href="#os-architectures">OS Architectures</a></li>
<li><a href="#real-world-os-comparison">Real-World OS Comparison</a></li>
</ol>
<hr />
<h2 id="operating-system-fundamentals"><a class="header" href="#operating-system-fundamentals">Operating System Fundamentals</a></h2>
<p>An <strong>Operating System (OS)</strong> is system software that manages computer hardware and software resources and provides common services for computer programs.</p>
<h3 id="core-functions"><a class="header" href="#core-functions">Core Functions</a></h3>
<ol>
<li><strong>Resource Management</strong>: Manages CPU, memory, disk space, and I/O devices</li>
<li><strong>Process Management</strong>: Controls creation, scheduling, and termination of processes</li>
<li><strong>Memory Management</strong>: Allocates and deallocates memory space as needed</li>
<li><strong>File System Management</strong>: Organizes and manages data storage</li>
<li><strong>I/O Management</strong>: Controls input/output operations</li>
<li><strong>Security</strong>: Protects system resources from unauthorized access</li>
<li><strong>User Interface</strong>: Provides CLI or GUI for user interaction</li>
</ol>
<h3 id="os-goals"><a class="header" href="#os-goals">OS Goals</a></h3>
<ul>
<li><strong>Convenience</strong>: Make the computer system convenient to use</li>
<li><strong>Efficiency</strong>: Use system resources efficiently</li>
<li><strong>Ability to Evolve</strong>: Permit effective development, testing, and introduction of new system functions</li>
<li><strong>Reliability</strong>: System should be dependable and fault-tolerant</li>
<li><strong>Maintainability</strong>: Easy to maintain and update</li>
</ul>
<hr />
<h2 id="process-management"><a class="header" href="#process-management">Process Management</a></h2>
<p>A <strong>process</strong> is a program in execution. Process management involves handling multiple processes in a system.</p>
<h3 id="process-lifecycle"><a class="header" href="#process-lifecycle">Process Lifecycle</a></h3>
<p>Processes transition through several states during their lifetime:</p>
<ol>
<li><strong>New</strong>: Process is being created</li>
<li><strong>Ready</strong>: Process is waiting to be assigned to a processor</li>
<li><strong>Running</strong>: Instructions are being executed</li>
<li><strong>Waiting (Blocked)</strong>: Process is waiting for some event to occur (I/O completion, signal)</li>
<li><strong>Terminated</strong>: Process has finished execution</li>
</ol>
<p><strong>State Transition Diagram:</strong></p>
<pre><code>New → Ready → Running → Terminated
         ↑       ↓
         ←  Waiting
</code></pre>
<h3 id="process-control-block-pcb"><a class="header" href="#process-control-block-pcb">Process Control Block (PCB)</a></h3>
<p>Each process is represented by a PCB containing:</p>
<ul>
<li>Process ID (PID)</li>
<li>Process state</li>
<li>Program counter</li>
<li>CPU registers</li>
<li>CPU scheduling information</li>
<li>Memory management information</li>
<li>Accounting information</li>
<li>I/O status information</li>
</ul>
<h3 id="process-scheduling-algorithms"><a class="header" href="#process-scheduling-algorithms">Process Scheduling Algorithms</a></h3>
<p>Operating systems use various algorithms to decide which process runs next:</p>
<h4 id="1-first-come-first-served-fcfs"><a class="header" href="#1-first-come-first-served-fcfs">1. First-Come, First-Served (FCFS)</a></h4>
<ul>
<li><strong>Description</strong>: Processes are executed in the order they arrive</li>
<li><strong>Advantages</strong>: Simple to implement</li>
<li><strong>Disadvantages</strong>: Convoy effect (short processes wait for long ones)</li>
<li><strong>Preemptive</strong>: No</li>
</ul>
<h4 id="2-shortest-job-first-sjf"><a class="header" href="#2-shortest-job-first-sjf">2. Shortest Job First (SJF)</a></h4>
<ul>
<li><strong>Description</strong>: Process with shortest burst time is executed first</li>
<li><strong>Advantages</strong>: Minimal average waiting time</li>
<li><strong>Disadvantages</strong>: Difficult to predict burst time, starvation possible</li>
<li><strong>Preemptive</strong>: Can be (Shortest Remaining Time First - SRTF)</li>
</ul>
<h4 id="3-priority-scheduling"><a class="header" href="#3-priority-scheduling">3. Priority Scheduling</a></h4>
<ul>
<li><strong>Description</strong>: Each process has a priority; highest priority executes first</li>
<li><strong>Advantages</strong>: Important processes get CPU time</li>
<li><strong>Disadvantages</strong>: Starvation of low-priority processes</li>
<li><strong>Solution</strong>: Aging (gradually increase priority of waiting processes)</li>
<li><strong>Preemptive</strong>: Can be</li>
</ul>
<h4 id="4-round-robin-rr"><a class="header" href="#4-round-robin-rr">4. Round Robin (RR)</a></h4>
<ul>
<li><strong>Description</strong>: Each process gets a small time quantum in circular order</li>
<li><strong>Advantages</strong>: Fair, no starvation, good for time-sharing</li>
<li><strong>Disadvantages</strong>: Performance depends on time quantum size</li>
<li><strong>Preemptive</strong>: Yes</li>
</ul>
<h4 id="5-multilevel-queue-scheduling"><a class="header" href="#5-multilevel-queue-scheduling">5. Multilevel Queue Scheduling</a></h4>
<ul>
<li><strong>Description</strong>: Processes divided into multiple queues with different priorities</li>
<li><strong>Advantages</strong>: Flexible, can combine multiple algorithms</li>
<li><strong>Disadvantages</strong>: Processes cannot move between queues</li>
</ul>
<h4 id="6-multilevel-feedback-queue"><a class="header" href="#6-multilevel-feedback-queue">6. Multilevel Feedback Queue</a></h4>
<ul>
<li><strong>Description</strong>: Like multilevel queue but processes can move between queues</li>
<li><strong>Advantages</strong>: Adaptable, prevents starvation</li>
<li><strong>Disadvantages</strong>: Most complex to implement</li>
</ul>
<h3 id="context-switching"><a class="header" href="#context-switching">Context Switching</a></h3>
<p><strong>Context switching</strong> is the process of storing and restoring the state of a process so execution can resume from the same point later.</p>
<p><strong>Steps:</strong></p>
<ol>
<li>Save the context of the currently running process (registers, program counter, etc.)</li>
<li>Update the PCB with the current state</li>
<li>Move PCB to appropriate queue</li>
<li>Select a new process for execution</li>
<li>Load the context of the new process</li>
<li>Start/resume execution</li>
</ol>
<p><strong>Overhead:</strong> Context switching is pure overhead; the system does no useful work while switching.</p>
<p><strong>Factors Affecting Context Switch Time:</strong></p>
<ul>
<li>Number of registers to save/restore</li>
<li>Memory speed</li>
<li>Hardware support (some CPUs have special instructions)</li>
</ul>
<h3 id="inter-process-communication-ipc"><a class="header" href="#inter-process-communication-ipc">Inter-Process Communication (IPC)</a></h3>
<p>Processes need to communicate and synchronize their actions. IPC mechanisms include:</p>
<h4 id="1-shared-memory"><a class="header" href="#1-shared-memory">1. Shared Memory</a></h4>
<ul>
<li><strong>Description</strong>: Processes share a region of memory</li>
<li><strong>Advantages</strong>: Fast (no kernel involvement after setup)</li>
<li><strong>Disadvantages</strong>: Requires synchronization, potential race conditions</li>
</ul>
<h4 id="2-message-passing"><a class="header" href="#2-message-passing">2. Message Passing</a></h4>
<ul>
<li><strong>Description</strong>: Processes communicate by sending/receiving messages</li>
<li><strong>Types</strong>:
<ul>
<li><strong>Direct</strong>: Processes explicitly name each other</li>
<li><strong>Indirect</strong>: Messages sent to/received from mailboxes/ports</li>
</ul>
</li>
<li><strong>Synchronization</strong>:
<ul>
<li><strong>Blocking (synchronous)</strong>: Sender/receiver blocks until message is received/sent</li>
<li><strong>Non-blocking (asynchronous)</strong>: Sender/receiver continues immediately</li>
</ul>
</li>
<li><strong>Advantages</strong>: No shared memory conflicts, easier to implement</li>
<li><strong>Disadvantages</strong>: Slower than shared memory</li>
</ul>
<h4 id="3-pipes"><a class="header" href="#3-pipes">3. Pipes</a></h4>
<ul>
<li><strong>Description</strong>: Unidirectional communication channel</li>
<li><strong>Types</strong>:
<ul>
<li><strong>Ordinary pipes</strong>: Parent-child communication, unidirectional</li>
<li><strong>Named pipes (FIFOs)</strong>: Bidirectional, can be used by unrelated processes</li>
</ul>
</li>
</ul>
<h4 id="4-sockets"><a class="header" href="#4-sockets">4. Sockets</a></h4>
<ul>
<li><strong>Description</strong>: Communication endpoint for network communication</li>
<li><strong>Use</strong>: Both local and remote process communication</li>
</ul>
<h4 id="5-signals"><a class="header" href="#5-signals">5. Signals</a></h4>
<ul>
<li><strong>Description</strong>: Software interrupts for notification of events</li>
<li><strong>Use</strong>: Asynchronous notification</li>
</ul>
<h4 id="6-semaphores"><a class="header" href="#6-semaphores">6. Semaphores</a></h4>
<ul>
<li><strong>Description</strong>: Integer variable for process synchronization</li>
<li><strong>Types</strong>:
<ul>
<li><strong>Binary semaphore</strong>: 0 or 1 (mutex)</li>
<li><strong>Counting semaphore</strong>: Range over unrestricted domain</li>
</ul>
</li>
</ul>
<hr />
<h2 id="thread-management"><a class="header" href="#thread-management">Thread Management</a></h2>
<p>A <strong>thread</strong> is a lightweight process, the smallest unit of execution within a process.</p>
<h3 id="process-vs-thread"><a class="header" href="#process-vs-thread">Process vs Thread</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Process</th><th>Thread</th></tr></thead><tbody>
<tr><td>Heavy-weight</td><td>Light-weight</td></tr>
<tr><td>Separate memory space</td><td>Shared memory space</td></tr>
<tr><td>Inter-process communication required</td><td>Direct communication (shared data)</td></tr>
<tr><td>Context switching is expensive</td><td>Context switching is cheaper</td></tr>
<tr><td>Independent</td><td>Shares resources with other threads</td></tr>
</tbody></table>
</div>
<h3 id="thread-benefits"><a class="header" href="#thread-benefits">Thread Benefits</a></h3>
<ol>
<li><strong>Responsiveness</strong>: Program can continue even if part is blocked</li>
<li><strong>Resource Sharing</strong>: Threads share memory and resources</li>
<li><strong>Economy</strong>: Cheaper to create and context-switch than processes</li>
<li><strong>Scalability</strong>: Can take advantage of multiprocessor architectures</li>
</ol>
<h3 id="thread-models"><a class="header" href="#thread-models">Thread Models</a></h3>
<h4 id="1-user-level-threads"><a class="header" href="#1-user-level-threads">1. User-Level Threads</a></h4>
<ul>
<li><strong>Managed by</strong>: User-level thread library</li>
<li><strong>Advantages</strong>: Fast, no kernel mode switch</li>
<li><strong>Disadvantages</strong>: If one thread blocks, entire process blocks</li>
</ul>
<h4 id="2-kernel-level-threads"><a class="header" href="#2-kernel-level-threads">2. Kernel-Level Threads</a></h4>
<ul>
<li><strong>Managed by</strong>: Operating system kernel</li>
<li><strong>Advantages</strong>: True parallelism on multiprocessors, blocking doesn't affect other threads</li>
<li><strong>Disadvantages</strong>: Slower (kernel mode switch required)</li>
</ul>
<h4 id="3-hybrid-model-many-to-many"><a class="header" href="#3-hybrid-model-many-to-many">3. Hybrid Model (Many-to-Many)</a></h4>
<ul>
<li><strong>Description</strong>: Multiplexes many user threads to smaller or equal number of kernel threads</li>
<li><strong>Advantages</strong>: Combines benefits of both approaches</li>
</ul>
<h3 id="thread-synchronization"><a class="header" href="#thread-synchronization">Thread Synchronization</a></h3>
<p><strong>Critical Section Problem</strong>: When multiple threads access shared data concurrently, inconsistencies can occur.</p>
<p><strong>Solution Requirements:</strong></p>
<ol>
<li><strong>Mutual Exclusion</strong>: Only one thread in critical section at a time</li>
<li><strong>Progress</strong>: Selection of next thread can't be postponed indefinitely</li>
<li><strong>Bounded Waiting</strong>: Limit on number of times other threads can enter before a waiting thread</li>
</ol>
<p><strong>Synchronization Mechanisms:</strong></p>
<ul>
<li><strong>Mutex Locks</strong>: Binary lock for mutual exclusion</li>
<li><strong>Semaphores</strong>: Signaling mechanism</li>
<li><strong>Monitors</strong>: High-level synchronization construct</li>
<li><strong>Condition Variables</strong>: Wait for certain condition</li>
</ul>
<hr />
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<p>Memory management handles allocation and deallocation of memory space to processes.</p>
<h3 id="memory-hierarchy"><a class="header" href="#memory-hierarchy">Memory Hierarchy</a></h3>
<pre><code>Registers (fastest, smallest)
↓
Cache (L1, L2, L3)
↓
Main Memory (RAM)
↓
Secondary Storage (SSD/HDD)
↓
Tertiary Storage (slowest, largest)
</code></pre>
<h3 id="address-binding"><a class="header" href="#address-binding">Address Binding</a></h3>
<p><strong>Logical Address</strong>: Generated by CPU (virtual address)
<strong>Physical Address</strong>: Actual address in memory</p>
<p><strong>Binding Time:</strong></p>
<ul>
<li><strong>Compile time</strong>: Absolute code, must recompile if location changes</li>
<li><strong>Load time</strong>: Relocatable code, binding at load time</li>
<li><strong>Execution time</strong>: Process can move during execution (requires hardware support)</li>
</ul>
<h3 id="memory-allocation-strategies"><a class="header" href="#memory-allocation-strategies">Memory Allocation Strategies</a></h3>
<h4 id="contiguous-allocation"><a class="header" href="#contiguous-allocation">Contiguous Allocation</a></h4>
<p><strong>Fixed Partitioning:</strong></p>
<ul>
<li>Memory divided into fixed-size partitions</li>
<li><strong>Disadvantage</strong>: Internal fragmentation</li>
</ul>
<p><strong>Dynamic Partitioning:</strong></p>
<ul>
<li>Partitions created dynamically</li>
<li><strong>Disadvantage</strong>: External fragmentation</li>
</ul>
<p><strong>Allocation Algorithms:</strong></p>
<ol>
<li><strong>First Fit</strong>: Allocate first hole large enough</li>
<li><strong>Best Fit</strong>: Allocate smallest hole large enough</li>
<li><strong>Worst Fit</strong>: Allocate largest hole</li>
</ol>
<h3 id="virtual-memory"><a class="header" href="#virtual-memory">Virtual Memory</a></h3>
<p><strong>Virtual memory</strong> separates logical memory from physical memory, allowing:</p>
<ul>
<li>Programs larger than physical memory</li>
<li>Better memory utilization</li>
<li>Increased multiprogramming</li>
</ul>
<h3 id="paging"><a class="header" href="#paging">Paging</a></h3>
<p><strong>Paging</strong> divides physical memory into fixed-size blocks called <strong>frames</strong> and logical memory into blocks of the same size called <strong>pages</strong>.</p>
<p><strong>Components:</strong></p>
<ul>
<li><strong>Page Table</strong>: Maps logical pages to physical frames</li>
<li><strong>Page Table Entry (PTE)</strong>: Contains frame number, valid/invalid bit, protection bits, dirty bit, reference bit</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>No external fragmentation</li>
<li>Easy to allocate memory (any free frame)</li>
<li>Efficient swapping</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Internal fragmentation (last page)</li>
<li>Page table space overhead</li>
<li>Time overhead (page table lookup)</li>
</ul>
<p><strong>Translation Lookaside Buffer (TLB):</strong></p>
<ul>
<li>High-speed associative cache for page table entries</li>
<li>Reduces page table lookup time</li>
<li><strong>TLB Hit</strong>: Page table entry found in TLB</li>
<li><strong>TLB Miss</strong>: Must access page table in memory</li>
</ul>
<h3 id="segmentation"><a class="header" href="#segmentation">Segmentation</a></h3>
<p><strong>Segmentation</strong> divides logical address space into variable-sized segments (code, data, stack, heap).</p>
<p><strong>Segment Table Entry:</strong></p>
<ul>
<li>Base address (starting physical address)</li>
<li>Limit (length of segment)</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>Logical organization</li>
<li>Protection easier to implement</li>
<li>Sharing easier</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>External fragmentation</li>
<li>More complex memory management</li>
</ul>
<p><strong>Paging vs Segmentation:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Paging</th><th>Segmentation</th></tr></thead><tbody>
<tr><td>Fixed-size units</td><td>Variable-size units</td></tr>
<tr><td>Invisible to programmer</td><td>Visible to programmer</td></tr>
<tr><td>No external fragmentation</td><td>External fragmentation</td></tr>
<tr><td>Less logical organization</td><td>Logical organization</td></tr>
</tbody></table>
</div>
<h3 id="page-replacement-algorithms"><a class="header" href="#page-replacement-algorithms">Page Replacement Algorithms</a></h3>
<p>When all frames are allocated and a page fault occurs, a page must be replaced.</p>
<h4 id="1-first-in-first-out-fifo"><a class="header" href="#1-first-in-first-out-fifo">1. First-In-First-Out (FIFO)</a></h4>
<ul>
<li><strong>Description</strong>: Replace the oldest page</li>
<li><strong>Advantage</strong>: Simple to implement</li>
<li><strong>Disadvantage</strong>: Suffers from Belady's anomaly (more frames → more faults)</li>
</ul>
<h4 id="2-optimal-page-replacement-opt"><a class="header" href="#2-optimal-page-replacement-opt">2. Optimal Page Replacement (OPT)</a></h4>
<ul>
<li><strong>Description</strong>: Replace page that won't be used for longest time</li>
<li><strong>Advantage</strong>: Lowest page fault rate</li>
<li><strong>Disadvantage</strong>: Impossible to implement (requires future knowledge)</li>
<li><strong>Use</strong>: Benchmark for other algorithms</li>
</ul>
<h4 id="3-least-recently-used-lru"><a class="header" href="#3-least-recently-used-lru">3. Least Recently Used (LRU)</a></h4>
<ul>
<li><strong>Description</strong>: Replace page not used for longest time</li>
<li><strong>Advantage</strong>: Good approximation of optimal</li>
<li><strong>Disadvantage</strong>: Expensive to implement (requires timestamp/stack)</li>
</ul>
<h4 id="4-lru-approximation-second-chanceclock"><a class="header" href="#4-lru-approximation-second-chanceclock">4. LRU Approximation (Second Chance/Clock)</a></h4>
<ul>
<li><strong>Description</strong>: Uses reference bit; gives page a second chance before replacing</li>
<li><strong>Advantage</strong>: Reasonable performance, easier to implement than true LRU</li>
<li><strong>Implementation</strong>: Circular queue with reference bits</li>
</ul>
<h4 id="5-least-frequently-used-lfu"><a class="header" href="#5-least-frequently-used-lfu">5. Least Frequently Used (LFU)</a></h4>
<ul>
<li><strong>Description</strong>: Replace page with smallest count</li>
<li><strong>Advantage</strong>: Considers frequency of access</li>
<li><strong>Disadvantage</strong>: Doesn't account for recent usage patterns</li>
</ul>
<h4 id="6-most-frequently-used-mfu"><a class="header" href="#6-most-frequently-used-mfu">6. Most Frequently Used (MFU)</a></h4>
<ul>
<li><strong>Description</strong>: Replace page with largest count</li>
<li><strong>Rationale</strong>: Page with smallest count probably just brought in</li>
</ul>
<h3 id="memory-protection"><a class="header" href="#memory-protection">Memory Protection</a></h3>
<p>Protection mechanisms prevent processes from accessing memory not allocated to them:</p>
<ol>
<li><strong>Base and Limit Registers</strong>: Define legal address range</li>
<li><strong>Page-Level Protection</strong>: Protection bits in page table entries</li>
<li><strong>Segmentation Protection</strong>: Different protection levels for different segments</li>
</ol>
<p><strong>Protection Bits:</strong></p>
<ul>
<li><strong>Read (R)</strong></li>
<li><strong>Write (W)</strong></li>
<li><strong>Execute (X)</strong></li>
<li><strong>Valid/Invalid</strong>: Page is in process's logical address space</li>
</ul>
<hr />
<h2 id="file-systems"><a class="header" href="#file-systems">File Systems</a></h2>
<p>A <strong>file system</strong> controls how data is stored and retrieved.</p>
<h3 id="file-system-structure"><a class="header" href="#file-system-structure">File System Structure</a></h3>
<p><strong>Layers:</strong></p>
<ol>
<li><strong>Application Programs</strong>: User applications</li>
<li><strong>Logical File System</strong>: Manages metadata, directory structure</li>
<li><strong>File Organization Module</strong>: Translates logical blocks to physical blocks</li>
<li><strong>Basic File System</strong>: Issues generic commands to device driver</li>
<li><strong>I/O Control</strong>: Device drivers and interrupt handlers</li>
<li><strong>Devices</strong>: Physical storage devices</li>
</ol>
<h3 id="file-concept"><a class="header" href="#file-concept">File Concept</a></h3>
<p><strong>File</strong>: Named collection of related information stored on secondary storage</p>
<p><strong>File Attributes:</strong></p>
<ul>
<li>Name</li>
<li>Identifier (unique tag)</li>
<li>Type</li>
<li>Location</li>
<li>Size</li>
<li>Protection (read, write, execute)</li>
<li>Time, date, user identification</li>
</ul>
<p><strong>File Operations:</strong></p>
<ul>
<li>Create</li>
<li>Open</li>
<li>Read</li>
<li>Write</li>
<li>Reposition (seek)</li>
<li>Delete</li>
<li>Close</li>
<li>Truncate</li>
</ul>
<h3 id="file-allocation-methods"><a class="header" href="#file-allocation-methods">File Allocation Methods</a></h3>
<h4 id="1-contiguous-allocation"><a class="header" href="#1-contiguous-allocation">1. Contiguous Allocation</a></h4>
<ul>
<li><strong>Description</strong>: Each file occupies a set of contiguous blocks</li>
<li><strong>Advantages</strong>: Simple, excellent read performance, random access</li>
<li><strong>Disadvantages</strong>: External fragmentation, hard to grow files</li>
</ul>
<h4 id="2-linked-allocation"><a class="header" href="#2-linked-allocation">2. Linked Allocation</a></h4>
<ul>
<li><strong>Description</strong>: Each file is a linked list of disk blocks</li>
<li><strong>Advantages</strong>: No external fragmentation, files can grow easily</li>
<li><strong>Disadvantages</strong>: Random access slow, reliability (pointer loss), space overhead</li>
</ul>
<h4 id="3-indexed-allocation"><a class="header" href="#3-indexed-allocation">3. Indexed Allocation</a></h4>
<ul>
<li><strong>Description</strong>: Index block contains pointers to all file blocks</li>
<li><strong>Advantages</strong>: No external fragmentation, supports direct access</li>
<li><strong>Disadvantages</strong>: Index block overhead, size limitations</li>
</ul>
<p><strong>Multi-level Indexing:</strong></p>
<ul>
<li><strong>Direct blocks</strong>: Pointers to data blocks</li>
<li><strong>Single indirect</strong>: Points to block of pointers</li>
<li><strong>Double indirect</strong>: Points to block of single indirect pointers</li>
<li><strong>Triple indirect</strong>: Points to block of double indirect pointers</li>
</ul>
<h3 id="directory-structures"><a class="header" href="#directory-structures">Directory Structures</a></h3>
<p>Directories organize files into logical groupings.</p>
<h4 id="types"><a class="header" href="#types">Types:</a></h4>
<ol>
<li>
<p><strong>Single-Level Directory</strong></p>
<ul>
<li>All files in one directory</li>
<li>Simple but limited (naming conflicts)</li>
</ul>
</li>
<li>
<p><strong>Two-Level Directory</strong></p>
<ul>
<li>Separate directory for each user</li>
<li>Isolates users but limited grouping</li>
</ul>
</li>
<li>
<p><strong>Tree-Structured Directory</strong></p>
<ul>
<li>Hierarchical structure</li>
<li>Absolute vs relative paths</li>
<li>Most common in modern OS</li>
</ul>
</li>
<li>
<p><strong>Acyclic Graph Directory</strong></p>
<ul>
<li>Allows sharing (links, aliases)</li>
<li>More flexible than tree</li>
<li>Must handle deletion carefully</li>
</ul>
</li>
<li>
<p><strong>General Graph Directory</strong></p>
<ul>
<li>Allows cycles</li>
<li>Must use garbage collection</li>
</ul>
</li>
</ol>
<h3 id="journaling"><a class="header" href="#journaling">Journaling</a></h3>
<p><strong>Journaling</strong> is a technique to ensure file system consistency after crashes.</p>
<p><strong>How it Works:</strong></p>
<ol>
<li>Before making changes, write intent to journal (log)</li>
<li>Make actual changes to file system</li>
<li>Mark journal entry as complete</li>
</ol>
<p><strong>Benefits:</strong></p>
<ul>
<li>Fast recovery after crash</li>
<li>File system consistency</li>
<li>Reduces fsck (file system check) time</li>
</ul>
<p><strong>Types:</strong></p>
<ul>
<li><strong>Metadata journaling</strong>: Only log metadata (most common)</li>
<li><strong>Full journaling</strong>: Log both metadata and data</li>
<li><strong>Ordered journaling</strong>: Write data before metadata</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><strong>ext3/ext4</strong>: Linux journaling file systems</li>
<li><strong>NTFS</strong>: Windows (uses journaling)</li>
<li><strong>HFS+/APFS</strong>: macOS</li>
</ul>
<h3 id="free-space-management"><a class="header" href="#free-space-management">Free Space Management</a></h3>
<p><strong>Methods:</strong></p>
<ol>
<li><strong>Bit Vector/Bitmap</strong>: Each block represented by 1 bit (0=free, 1=allocated)</li>
<li><strong>Linked List</strong>: Free blocks linked together</li>
<li><strong>Grouping</strong>: Store addresses of free blocks in first free block</li>
<li><strong>Counting</strong>: Store address of first free block and count of contiguous free blocks</li>
</ol>
<hr />
<h2 id="io-systems"><a class="header" href="#io-systems">I/O Systems</a></h2>
<p>I/O systems manage communication between computer and external devices.</p>
<h3 id="io-hardware-components"><a class="header" href="#io-hardware-components">I/O Hardware Components</a></h3>
<ol>
<li><strong>Device Controller</strong>: Hardware that controls one or more devices</li>
<li><strong>Device Driver</strong>: Software interface between OS and device controller</li>
<li><strong>Bus</strong>: Communication pathway</li>
<li><strong>Port</strong>: Connection point</li>
<li><strong>Registers</strong>: Status, control, data-in, data-out</li>
</ol>
<h3 id="io-methods"><a class="header" href="#io-methods">I/O Methods</a></h3>
<h4 id="1-programmed-io-polling"><a class="header" href="#1-programmed-io-polling">1. Programmed I/O (Polling)</a></h4>
<ul>
<li><strong>Description</strong>: CPU continuously checks device status</li>
<li><strong>Advantages</strong>: Simple</li>
<li><strong>Disadvantages</strong>: CPU busy-waits (wasteful)</li>
</ul>
<h4 id="2-interrupt-driven-io"><a class="header" href="#2-interrupt-driven-io">2. Interrupt-Driven I/O</a></h4>
<ul>
<li><strong>Description</strong>: Device sends interrupt when ready</li>
<li><strong>Advantages</strong>: CPU can do other work</li>
<li><strong>Disadvantages</strong>: Overhead of interrupt handling</li>
</ul>
<h4 id="3-direct-memory-access-dma"><a class="header" href="#3-direct-memory-access-dma">3. Direct Memory Access (DMA)</a></h4>
<ul>
<li><strong>Description</strong>: Device controller transfers data directly to/from memory</li>
<li><strong>Advantages</strong>: CPU freed from data transfer</li>
<li><strong>Disadvantages</strong>: Requires DMA controller hardware</li>
</ul>
<h3 id="device-drivers"><a class="header" href="#device-drivers">Device Drivers</a></h3>
<p><strong>Device driver</strong> is OS software that controls hardware devices.</p>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Initialize device</li>
<li>Interpret high-level commands</li>
<li>Handle interrupts</li>
<li>Manage device queues</li>
<li>Error handling</li>
</ul>
<p><strong>Device Types:</strong></p>
<ul>
<li><strong>Block Devices</strong>: Data in fixed-size blocks (disks)</li>
<li><strong>Character Devices</strong>: Data as character stream (keyboards, mice)</li>
<li><strong>Network Devices</strong>: Packet-based communication</li>
</ul>
<h3 id="io-scheduling"><a class="header" href="#io-scheduling">I/O Scheduling</a></h3>
<p><strong>Goal</strong>: Optimize disk access time</p>
<p><strong>Disk Access Time Components:</strong></p>
<ol>
<li><strong>Seek Time</strong>: Move read/write head to correct track (dominant)</li>
<li><strong>Rotational Latency</strong>: Wait for sector to rotate under head</li>
<li><strong>Transfer Time</strong>: Actual data transfer</li>
</ol>
<p><strong>Disk Scheduling Algorithms:</strong></p>
<h4 id="1-first-come-first-served-fcfs-1"><a class="header" href="#1-first-come-first-served-fcfs-1">1. First-Come, First-Served (FCFS)</a></h4>
<ul>
<li>Process requests in order</li>
<li>Fair but may cause long seeks</li>
</ul>
<h4 id="2-shortest-seek-time-first-sstf"><a class="header" href="#2-shortest-seek-time-first-sstf">2. Shortest Seek Time First (SSTF)</a></h4>
<ul>
<li>Service request closest to current head position</li>
<li>Can cause starvation</li>
</ul>
<h4 id="3-scan-elevator-algorithm"><a class="header" href="#3-scan-elevator-algorithm">3. SCAN (Elevator Algorithm)</a></h4>
<ul>
<li>Head moves in one direction, services requests, then reverses</li>
<li>No starvation</li>
</ul>
<h4 id="4-c-scan-circular-scan"><a class="header" href="#4-c-scan-circular-scan">4. C-SCAN (Circular SCAN)</a></h4>
<ul>
<li>Like SCAN but only services in one direction, then jumps back</li>
<li>More uniform wait time</li>
</ul>
<h4 id="5-look--c-look"><a class="header" href="#5-look--c-look">5. LOOK / C-LOOK</a></h4>
<ul>
<li>Like SCAN/C-SCAN but only goes as far as last request</li>
<li>More efficient</li>
</ul>
<h3 id="buffering-and-caching"><a class="header" href="#buffering-and-caching">Buffering and Caching</a></h3>
<p><strong>Buffering:</strong></p>
<ul>
<li>Temporary storage area for data during I/O</li>
<li><strong>Single Buffer</strong>: One block at a time</li>
<li><strong>Double Buffer</strong>: Can fill one while processing other</li>
<li><strong>Circular Buffer</strong>: Ring of buffers</li>
</ul>
<p><strong>Caching:</strong></p>
<ul>
<li>Store frequently accessed data in faster storage</li>
<li><strong>Cache Hit</strong>: Data found in cache</li>
<li><strong>Cache Miss</strong>: Data must be fetched from slower storage</li>
</ul>
<p><strong>Cache Replacement Policies:</strong></p>
<ul>
<li>LRU (Least Recently Used)</li>
<li>LFU (Least Frequently Used)</li>
<li>FIFO (First In First Out)</li>
<li>Random</li>
</ul>
<hr />
<h2 id="deadlocks"><a class="header" href="#deadlocks">Deadlocks</a></h2>
<p>A <strong>deadlock</strong> is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource held by another process.</p>
<h3 id="necessary-conditions-for-deadlock"><a class="header" href="#necessary-conditions-for-deadlock">Necessary Conditions for Deadlock</a></h3>
<p>All four conditions must hold simultaneously:</p>
<ol>
<li><strong>Mutual Exclusion</strong>: At least one resource must be held in non-shareable mode</li>
<li><strong>Hold and Wait</strong>: Process holding resources can request additional resources</li>
<li><strong>No Preemption</strong>: Resources cannot be forcibly taken away</li>
<li><strong>Circular Wait</strong>: Circular chain of processes, each waiting for a resource held by the next</li>
</ol>
<h3 id="resource-allocation-graph"><a class="header" href="#resource-allocation-graph">Resource Allocation Graph</a></h3>
<p><strong>Components:</strong></p>
<ul>
<li><strong>Processes</strong>: Represented by circles</li>
<li><strong>Resources</strong>: Represented by rectangles</li>
<li><strong>Request Edge</strong>: Process → Resource (requesting)</li>
<li><strong>Assignment Edge</strong>: Resource → Process (allocated)</li>
</ul>
<p><strong>Deadlock Detection:</strong></p>
<ul>
<li>If graph has a cycle AND each resource has only one instance → deadlock</li>
<li>If graph has a cycle AND resources have multiple instances → possibly deadlock</li>
</ul>
<h3 id="deadlock-handling-strategies"><a class="header" href="#deadlock-handling-strategies">Deadlock Handling Strategies</a></h3>
<h4 id="1-deadlock-prevention"><a class="header" href="#1-deadlock-prevention">1. Deadlock Prevention</a></h4>
<p>Ensure at least one of the four necessary conditions cannot hold:</p>
<p><strong>Prevent Mutual Exclusion:</strong></p>
<ul>
<li>Make resources shareable (not always possible)</li>
</ul>
<p><strong>Prevent Hold and Wait:</strong></p>
<ul>
<li>Require process to request all resources at once</li>
<li>Require process to release all resources before requesting new ones</li>
<li><strong>Disadvantage</strong>: Low resource utilization, starvation</li>
</ul>
<p><strong>Prevent No Preemption:</strong></p>
<ul>
<li>If process requests unavailable resource, release all held resources</li>
<li><strong>Disadvantage</strong>: Difficult for some resources (printers)</li>
</ul>
<p><strong>Prevent Circular Wait:</strong></p>
<ul>
<li>Impose total ordering on resources</li>
<li>Request resources in increasing order of enumeration</li>
<li><strong>Advantage</strong>: Most practical prevention method</li>
</ul>
<h4 id="2-deadlock-avoidance"><a class="header" href="#2-deadlock-avoidance">2. Deadlock Avoidance</a></h4>
<p>System has additional information about resource requests and uses it to avoid deadlock.</p>
<p><strong>Safe State:</strong></p>
<ul>
<li>System can allocate resources to each process in some order and still avoid deadlock</li>
<li>If no safe sequence exists → unsafe state (not necessarily deadlock)</li>
</ul>
<p><strong>Banker's Algorithm:</strong></p>
<ul>
<li>Used for multiple instances of resources</li>
<li>Checks if allocation keeps system in safe state</li>
<li><strong>Steps</strong>:
<ol>
<li>Process requests resources</li>
<li>Pretend to allocate</li>
<li>Check if resulting state is safe</li>
<li>If safe, allocate; otherwise, wait</li>
</ol>
</li>
</ul>
<p><strong>Data Structures:</strong></p>
<ul>
<li><strong>Available</strong>: Number of available resources</li>
<li><strong>Max</strong>: Maximum demand of each process</li>
<li><strong>Allocation</strong>: Currently allocated resources</li>
<li><strong>Need</strong>: Remaining resource need (Max - Allocation)</li>
</ul>
<h4 id="3-deadlock-detection"><a class="header" href="#3-deadlock-detection">3. Deadlock Detection</a></h4>
<p>Allow deadlocks to occur, then detect and recover.</p>
<p><strong>Single Instance Resources:</strong></p>
<ul>
<li>Use wait-for graph (variant of resource allocation graph)</li>
<li>Cycle detection algorithm</li>
</ul>
<p><strong>Multiple Instance Resources:</strong></p>
<ul>
<li>Similar to Banker's algorithm</li>
<li>Periodically invoke detection algorithm</li>
</ul>
<p><strong>When to Invoke:</strong></p>
<ul>
<li>How often deadlocks likely to occur</li>
<li>How many processes affected</li>
<li>Trade-off: Detection overhead vs deadlock impact</li>
</ul>
<h4 id="4-deadlock-recovery"><a class="header" href="#4-deadlock-recovery">4. Deadlock Recovery</a></h4>
<p><strong>Process Termination:</strong></p>
<ol>
<li><strong>Abort all deadlocked processes</strong>: Expensive but simple</li>
<li><strong>Abort one process at a time</strong>: Overhead of detection after each abort</li>
</ol>
<p><strong>Selection Criteria:</strong></p>
<ul>
<li>Process priority</li>
<li>How long process has computed</li>
<li>Resources used</li>
<li>Resources needed to complete</li>
<li>Number of processes to terminate</li>
<li>Interactive vs batch</li>
</ul>
<p><strong>Resource Preemption:</strong></p>
<ol>
<li><strong>Selecting a victim</strong>: Minimize cost</li>
<li><strong>Rollback</strong>: Return process to safe state</li>
<li><strong>Starvation</strong>: Ensure same process not always picked</li>
</ol>
<hr />
<h2 id="security-and-protection"><a class="header" href="#security-and-protection">Security and Protection</a></h2>
<h3 id="protection"><a class="header" href="#protection">Protection</a></h3>
<p><strong>Protection</strong> is a mechanism for controlling access of programs, processes, or users to resources.</p>
<p><strong>Goals:</strong></p>
<ul>
<li>Prevent malicious misuse</li>
<li>Ensure each component uses resources only as authorized</li>
<li>Detect improper access attempts</li>
</ul>
<h4 id="protection-domain"><a class="header" href="#protection-domain">Protection Domain</a></h4>
<p><strong>Domain</strong>: Set of (object, access-rights) pairs</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><strong>Domain per user</strong>: Traditional approach</li>
<li><strong>Domain per process</strong>: More flexible</li>
<li><strong>Domain switching</strong>: Process can switch domains</li>
</ul>
<h4 id="access-matrix"><a class="header" href="#access-matrix">Access Matrix</a></h4>
<p><strong>Model</strong> showing which domains can access which objects with what rights.</p>
<ul>
<li><strong>Rows</strong>: Domains</li>
<li><strong>Columns</strong>: Objects</li>
<li><strong>Entries</strong>: Access rights (read, write, execute, etc.)</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><strong>Access Control List (ACL)</strong>: Column-wise (per object)</li>
<li><strong>Capability List</strong>: Row-wise (per domain)</li>
</ul>
<h4 id="access-control"><a class="header" href="#access-control">Access Control</a></h4>
<p><strong>Discretionary Access Control (DAC):</strong></p>
<ul>
<li>Owner controls access</li>
<li>Used in most OSes</li>
<li><strong>Disadvantage</strong>: Can be bypassed</li>
</ul>
<p><strong>Mandatory Access Control (MAC):</strong></p>
<ul>
<li>System enforces access based on security levels</li>
<li>Used in high-security systems</li>
<li>Users cannot change access rights</li>
</ul>
<p><strong>Role-Based Access Control (RBAC):</strong></p>
<ul>
<li>Access based on roles</li>
<li>Users assigned to roles</li>
<li>Permissions assigned to roles</li>
</ul>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<p><strong>Security</strong> protects system from external and internal attacks.</p>
<h4 id="security-threats"><a class="header" href="#security-threats">Security Threats</a></h4>
<ol>
<li>
<p><strong>Malware</strong>:</p>
<ul>
<li><strong>Virus</strong>: Self-replicating code attached to programs</li>
<li><strong>Worm</strong>: Self-replicating standalone program</li>
<li><strong>Trojan Horse</strong>: Malicious code disguised as legitimate</li>
<li><strong>Ransomware</strong>: Encrypts data and demands payment</li>
<li><strong>Spyware</strong>: Monitors user activity</li>
</ul>
</li>
<li>
<p><strong>Attacks</strong>:</p>
<ul>
<li><strong>Denial of Service (DoS)</strong>: Overwhelm system</li>
<li><strong>Man-in-the-Middle</strong>: Intercept communication</li>
<li><strong>Phishing</strong>: Trick users into revealing information</li>
<li><strong>Buffer Overflow</strong>: Exploit memory vulnerabilities</li>
<li><strong>Privilege Escalation</strong>: Gain unauthorized privileges</li>
</ul>
</li>
</ol>
<h4 id="security-mechanisms"><a class="header" href="#security-mechanisms">Security Mechanisms</a></h4>
<p><strong>Authentication:</strong></p>
<ul>
<li><strong>Something you know</strong>: Password, PIN</li>
<li><strong>Something you have</strong>: Smart card, token</li>
<li><strong>Something you are</strong>: Biometrics</li>
<li><strong>Multi-factor</strong>: Combination of above</li>
</ul>
<p><strong>Authorization:</strong></p>
<ul>
<li>Determine what authenticated user can do</li>
<li>Based on access control mechanisms</li>
</ul>
<p><strong>Encryption:</strong></p>
<ul>
<li><strong>Symmetric</strong>: Same key for encryption/decryption (AES)</li>
<li><strong>Asymmetric</strong>: Public/private key pair (RSA)</li>
<li><strong>Hashing</strong>: One-way transformation (SHA-256)</li>
</ul>
<p><strong>Firewalls:</strong></p>
<ul>
<li>Filter network traffic</li>
<li>Can be hardware or software</li>
<li>Prevent unauthorized access</li>
</ul>
<p><strong>Intrusion Detection Systems (IDS):</strong></p>
<ul>
<li>Monitor for suspicious activity</li>
<li><strong>Signature-based</strong>: Known attack patterns</li>
<li><strong>Anomaly-based</strong>: Deviations from normal behavior</li>
</ul>
<p><strong>Security Policies:</strong></p>
<ul>
<li>Define acceptable use</li>
<li>Password policies</li>
<li>Access control policies</li>
<li>Incident response procedures</li>
</ul>
<hr />
<h2 id="os-architectures"><a class="header" href="#os-architectures">OS Architectures</a></h2>
<h3 id="1-monolithic-kernel"><a class="header" href="#1-monolithic-kernel">1. Monolithic Kernel</a></h3>
<p><strong>Description</strong>: Entire OS runs in kernel mode as a single program.</p>
<p><strong>Structure:</strong></p>
<ul>
<li>All services in kernel space</li>
<li>Direct function calls between components</li>
<li>No protection between OS components</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>High performance (no context switching overhead)</li>
<li>Simple communication between components</li>
<li>Direct access to hardware</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Large kernel size</li>
<li>Less stable (bug in any component crashes entire system)</li>
<li>Difficult to maintain and debug</li>
<li>Hard to add new features</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>Traditional UNIX</li>
<li>Linux (modular monolithic)</li>
<li>MS-DOS</li>
</ul>
<h3 id="2-microkernel"><a class="header" href="#2-microkernel">2. Microkernel</a></h3>
<p><strong>Description</strong>: Minimal kernel with most services running in user space.</p>
<p><strong>Kernel Contains Only:</strong></p>
<ul>
<li>Process and thread management</li>
<li>Low-level memory management</li>
<li>Inter-process communication (IPC)</li>
<li>Basic scheduling</li>
</ul>
<p><strong>User Space Services:</strong></p>
<ul>
<li>Device drivers</li>
<li>File systems</li>
<li>Network protocols</li>
<li>Higher-level memory management</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>More stable (service crash doesn't crash kernel)</li>
<li>Easier to extend and maintain</li>
<li>Better security isolation</li>
<li>Portable</li>
<li>Supports distributed systems</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Performance overhead (context switching, IPC)</li>
<li>Complex IPC mechanisms</li>
<li>More difficult to design</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>Minix</li>
<li>QNX</li>
<li>Mach (basis for macOS kernel)</li>
<li>L4</li>
</ul>
<h3 id="3-hybrid-kernel"><a class="header" href="#3-hybrid-kernel">3. Hybrid Kernel</a></h3>
<p><strong>Description</strong>: Combines elements of monolithic and microkernel architectures.</p>
<p><strong>Approach:</strong></p>
<ul>
<li>Microkernel base</li>
<li>Some services in kernel space for performance</li>
<li>Balance between performance and modularity</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>Better performance than pure microkernel</li>
<li>More modular than pure monolithic</li>
<li>Flexibility to move services between kernel/user space</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Can inherit disadvantages of both approaches</li>
<li>More complex design</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><strong>Windows NT/10/11</strong>: Hybrid with microkernel influences</li>
<li><strong>macOS/iOS</strong>: XNU kernel (hybrid: Mach microkernel + BSD components)</li>
<li><strong>BeOS/Haiku</strong>: Hybrid architecture</li>
</ul>
<h3 id="other-architectures"><a class="header" href="#other-architectures">Other Architectures</a></h3>
<h4 id="layered-architecture"><a class="header" href="#layered-architecture">Layered Architecture</a></h4>
<ul>
<li>OS divided into layers</li>
<li>Each layer uses services of layer below</li>
<li><strong>Advantage</strong>: Modularity, easy debugging</li>
<li><strong>Disadvantage</strong>: Less efficient, hard to define layers</li>
</ul>
<h4 id="exokernel"><a class="header" href="#exokernel">Exokernel</a></h4>
<ul>
<li>Minimal kernel provides resource allocation</li>
<li>Applications manage resources directly</li>
<li><strong>Advantage</strong>: Maximum flexibility</li>
<li><strong>Disadvantage</strong>: Complex application development</li>
</ul>
<h4 id="unikernel"><a class="header" href="#unikernel">Unikernel</a></h4>
<ul>
<li>Single address space for application and kernel</li>
<li>Specialized for specific application</li>
<li><strong>Advantage</strong>: Minimal overhead, fast boot</li>
<li><strong>Disadvantage</strong>: No multitasking, specialized use</li>
</ul>
<hr />
<h2 id="real-world-os-comparison"><a class="header" href="#real-world-os-comparison">Real-World OS Comparison</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p><strong>Type</strong>: Monolithic kernel (modular)</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>Kernel space: Core kernel, device drivers (modules), system calls</li>
<li>User space: System libraries, applications</li>
</ul>
<p><strong>Key Features:</strong></p>
<ul>
<li>Open source (GPL license)</li>
<li>Multi-user, multi-tasking</li>
<li>POSIX-compliant</li>
<li>Excellent networking capabilities</li>
<li>Wide hardware support</li>
<li>Strong security model</li>
</ul>
<p><strong>Process Management:</strong></p>
<ul>
<li>Completely Fair Scheduler (CFS) - default</li>
<li>Real-time scheduling available (SCHED_FIFO, SCHED_RR)</li>
<li>Supports POSIX threads (pthreads)</li>
<li>Process created via <code>fork()</code>, <code>exec()</code> system calls</li>
</ul>
<p><strong>Memory Management:</strong></p>
<ul>
<li>Virtual memory with demand paging</li>
<li>Page cache for file system</li>
<li>Swap space support</li>
<li>Multiple page replacement algorithms</li>
<li>Support for huge pages</li>
<li>Memory overcommit</li>
</ul>
<p><strong>File Systems:</strong></p>
<ul>
<li>Native: ext2, ext3, ext4, Btrfs, XFS</li>
<li>Supports: FAT, NTFS, HFS+, and many others</li>
<li>Virtual File System (VFS) layer</li>
</ul>
<p><strong>I/O Scheduling:</strong></p>
<ul>
<li>Multiple schedulers available</li>
<li>CFQ (Completely Fair Queuing)</li>
<li>Deadline</li>
<li>NOOP</li>
<li>BFQ (Budget Fair Queueing)</li>
</ul>
<p><strong>Security:</strong></p>
<ul>
<li>User/group permissions</li>
<li>SELinux, AppArmor (MAC)</li>
<li>Capabilities</li>
<li>Namespaces and cgroups (containerization)</li>
<li>Secure boot support</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Servers (web, database, cloud)</li>
<li>Embedded systems (Android)</li>
<li>Supercomputers</li>
<li>Desktop/laptop (various distributions)</li>
<li>IoT devices</li>
</ul>
<p><strong>Distributions:</strong></p>
<ul>
<li>Ubuntu, Debian (user-friendly)</li>
<li>Red Hat, CentOS, Fedora (enterprise)</li>
<li>Arch Linux (DIY, bleeding edge)</li>
<li>Android (mobile)</li>
</ul>
<hr />
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p><strong>Type</strong>: Hybrid kernel (NT kernel)</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>Hardware Abstraction Layer (HAL)</li>
<li>Kernel (ntoskrnl.exe)</li>
<li>Executive services</li>
<li>System support processes</li>
<li>Environment subsystems</li>
<li>User applications</li>
</ul>
<p><strong>Key Features:</strong></p>
<ul>
<li>Proprietary (closed source)</li>
<li>Dominant desktop OS</li>
<li>Strong backward compatibility</li>
<li>Comprehensive GUI</li>
<li>Wide application support</li>
<li>DirectX for gaming</li>
</ul>
<p><strong>Process Management:</strong></p>
<ul>
<li>Preemptive multitasking</li>
<li>Priority-based scheduling (32 priority levels)</li>
<li>Thread-based</li>
<li>Processes created via <code>CreateProcess()</code> API</li>
<li>Fibers (lightweight threads)</li>
</ul>
<p><strong>Memory Management:</strong></p>
<ul>
<li>Virtual memory manager</li>
<li>Demand paging</li>
<li>Page file for swapping</li>
<li>Address Windowing Extensions (AWE) for large memory</li>
<li>SuperFetch (predictive prefetching)</li>
<li>Memory compression (Windows 10+)</li>
</ul>
<p><strong>File Systems:</strong></p>
<ul>
<li>Native: NTFS (journaling, compression, encryption)</li>
<li>Also supports: FAT32, exFAT, ReFS</li>
<li>NTFS features: ACLs, alternate data streams, hard links, symbolic links</li>
<li>Volume Shadow Copy (snapshots)</li>
</ul>
<p><strong>I/O Scheduling:</strong></p>
<ul>
<li>Priority-based I/O</li>
<li>Asynchronous I/O</li>
<li>I/O completion ports</li>
</ul>
<p><strong>Security:</strong></p>
<ul>
<li>User Account Control (UAC)</li>
<li>Windows Defender</li>
<li>BitLocker (disk encryption)</li>
<li>Windows Security (antivirus, firewall)</li>
<li>Secure Boot, TPM support</li>
<li>Windows Hello (biometric authentication)</li>
<li>Mandatory Integrity Control</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Desktop/laptop (business and home)</li>
<li>Gaming</li>
<li>Enterprise servers (Active Directory)</li>
<li>Development workstations</li>
</ul>
<p><strong>Versions:</strong></p>
<ul>
<li>Windows 10/11 (consumer, business)</li>
<li>Windows Server (enterprise)</li>
<li>Windows IoT (embedded)</li>
</ul>
<hr />
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p><strong>Type</strong>: Hybrid kernel (XNU: X is Not Unix)</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>XNU kernel (Mach microkernel + BSD)</li>
<li>Darwin (open source base)</li>
<li>Core Services</li>
<li>Application Frameworks (Cocoa, Carbon)</li>
<li>Aqua (GUI)</li>
</ul>
<p><strong>Key Features:</strong></p>
<ul>
<li>Unix-based (BSD heritage)</li>
<li>POSIX-compliant</li>
<li>Proprietary (runs only on Apple hardware)</li>
<li>Seamless hardware-software integration</li>
<li>Strong focus on user experience</li>
<li>Excellent multimedia capabilities</li>
</ul>
<p><strong>Process Management:</strong></p>
<ul>
<li>Mach tasks and threads</li>
<li>BSD process model on top</li>
<li>Priority-based scheduling</li>
<li>Grand Central Dispatch (GCD) for concurrency</li>
<li>Supports POSIX threads</li>
</ul>
<p><strong>Memory Management:</strong></p>
<ul>
<li>Virtual memory with demand paging</li>
<li>Mach VM system</li>
<li>Compressed memory</li>
<li>Unified memory (Apple Silicon)</li>
<li>Memory pressure notifications</li>
<li>No swap on iOS/iPadOS (memory compression only)</li>
</ul>
<p><strong>File Systems:</strong></p>
<ul>
<li>Native: APFS (Apple File System) - since macOS 10.13</li>
<li>Legacy: HFS+ (still supported)</li>
<li>APFS features: Snapshots, clones, encryption, space sharing</li>
<li>Case-insensitive by default (case-sensitive option available)</li>
</ul>
<p><strong>I/O Scheduling:</strong></p>
<ul>
<li>I/O Kit framework</li>
<li>Asynchronous I/O</li>
<li>Prioritized I/O</li>
</ul>
<p><strong>Security:</strong></p>
<ul>
<li>Gatekeeper (app verification)</li>
<li>System Integrity Protection (SIP)</li>
<li>FileVault (disk encryption)</li>
<li>Keychain (password management)</li>
<li>Secure Enclave (hardware security)</li>
<li>App sandboxing</li>
<li>Code signing requirements</li>
<li>XProtect (antimalware)</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Creative professionals (video, music, design)</li>
<li>Software development (especially iOS/macOS)</li>
<li>General consumer use</li>
<li>Education</li>
</ul>
<p><strong>Platforms:</strong></p>
<ul>
<li>macOS (desktop/laptop)</li>
<li>iOS (iPhone)</li>
<li>iPadOS (iPad)</li>
<li>watchOS (Apple Watch)</li>
<li>tvOS (Apple TV)</li>
</ul>
<hr />
<h3 id="real-time-operating-systems-rtos"><a class="header" href="#real-time-operating-systems-rtos">Real-Time Operating Systems (RTOS)</a></h3>
<p><strong>Definition</strong>: OS designed to handle time-critical tasks with deterministic behavior.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li><strong>Deterministic</strong>: Predictable response times</li>
<li><strong>Priority-based preemptive scheduling</strong>: High-priority tasks run immediately</li>
<li><strong>Minimal interrupt latency</strong>: Fast interrupt handling</li>
<li><strong>Fast context switching</strong>: Minimal overhead</li>
<li><strong>Bounded priority inversion</strong>: Priority inheritance protocols</li>
</ul>
<p><strong>Types:</strong></p>
<h4 id="hard-real-time-systems"><a class="header" href="#hard-real-time-systems">Hard Real-Time Systems</a></h4>
<ul>
<li><strong>Requirement</strong>: Tasks MUST complete within deadline</li>
<li><strong>Failure</strong>: System failure if deadline missed</li>
<li><strong>Examples</strong>: Medical devices, airbag systems, aircraft controls</li>
<li><strong>RTOS Examples</strong>: VxWorks, QNX, RTEMS</li>
</ul>
<h4 id="soft-real-time-systems"><a class="header" href="#soft-real-time-systems">Soft Real-Time Systems</a></h4>
<ul>
<li><strong>Requirement</strong>: Tasks SHOULD complete within deadline</li>
<li><strong>Failure</strong>: Degraded performance if deadline missed</li>
<li><strong>Examples</strong>: Video streaming, gaming, VoIP</li>
<li><strong>RTOS Examples</strong>: FreeRTOS, RTLinux, eCos</li>
</ul>
<p><strong>Memory Management:</strong></p>
<ul>
<li>Often no virtual memory (predictability)</li>
<li>Static memory allocation preferred</li>
<li>Deterministic memory allocation</li>
</ul>
<p><strong>Scheduling:</strong></p>
<ul>
<li>Rate Monotonic Scheduling (RMS)</li>
<li>Earliest Deadline First (EDF)</li>
<li>Fixed-priority preemptive scheduling</li>
</ul>
<p><strong>Popular RTOS:</strong></p>
<ol>
<li>
<p><strong>FreeRTOS</strong></p>
<ul>
<li>Open source, free</li>
<li>Small footprint</li>
<li>Wide hardware support</li>
<li>Used in IoT devices</li>
</ul>
</li>
<li>
<p><strong>VxWorks</strong></p>
<ul>
<li>Commercial, robust</li>
<li>Used in aerospace, defense</li>
<li>Mars rovers, Boeing 787</li>
</ul>
</li>
<li>
<p><strong>QNX</strong></p>
<ul>
<li>Microkernel RTOS</li>
<li>Used in automotive (infotainment)</li>
<li>Medical devices</li>
<li>BlackBerry 10</li>
</ul>
</li>
<li>
<p><strong>RTLinux / PREEMPT_RT</strong></p>
<ul>
<li>Linux with real-time extensions</li>
<li>Combines Linux flexibility with RT capabilities</li>
</ul>
</li>
</ol>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Industrial automation</li>
<li>Medical devices</li>
<li>Automotive systems</li>
<li>Aerospace and defense</li>
<li>Telecommunications</li>
<li>Robotics</li>
<li>Consumer electronics</li>
</ul>
<hr />
<h2 id="comparison-summary"><a class="header" href="#comparison-summary">Comparison Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Linux</th><th>Windows</th><th>macOS</th><th>RTOS</th></tr></thead><tbody>
<tr><td><strong>Kernel Type</strong></td><td>Monolithic</td><td>Hybrid</td><td>Hybrid</td><td>Varies</td></tr>
<tr><td><strong>Source Code</strong></td><td>Open</td><td>Closed</td><td>Hybrid</td><td>Varies</td></tr>
<tr><td><strong>Cost</strong></td><td>Free</td><td>Paid</td><td>Paid (with hardware)</td><td>Varies</td></tr>
<tr><td><strong>Target Use</strong></td><td>Servers, Desktop</td><td>Desktop, Enterprise</td><td>Desktop, Creative</td><td>Embedded, Critical</td></tr>
<tr><td><strong>Hardware</strong></td><td>Wide support</td><td>Wide support</td><td>Apple only</td><td>Specific embedded</td></tr>
<tr><td><strong>Security</strong></td><td>Strong</td><td>Good</td><td>Strong</td><td>Application-specific</td></tr>
<tr><td><strong>Customization</strong></td><td>Highly customizable</td><td>Limited</td><td>Limited</td><td>Highly customizable</td></tr>
<tr><td><strong>RT Support</strong></td><td>Patches available</td><td>Limited</td><td>Limited</td><td>Native</td></tr>
<tr><td><strong>Determinism</strong></td><td>Low</td><td>Low</td><td>Low</td><td>High</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Understanding operating systems is fundamental to computer science and software engineering. Modern operating systems are complex, sophisticated software that:</p>
<ul>
<li>Manage hardware resources efficiently</li>
<li>Provide abstraction layers for applications</li>
<li>Ensure security and protection</li>
<li>Enable concurrent execution</li>
<li>Handle I/O operations</li>
<li>Manage memory and storage</li>
</ul>
<p>Different OS architectures and implementations serve different purposes, from general-purpose systems like Linux, Windows, and macOS to specialized real-time systems for embedded and critical applications.</p>
<p>The principles covered in this document—process management, memory management, file systems, I/O, deadlocks, and security—are essential for system administrators, developers, and anyone working with computer systems.</p>
<hr />
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li>
<p><strong>Books</strong>:</p>
<ul>
<li>"Operating System Concepts" by Silberschatz, Galvin, and Gagne</li>
<li>"Modern Operating Systems" by Andrew S. Tanenbaum</li>
<li>"Operating Systems: Three Easy Pieces" by Remzi and Andrea Arpaci-Dusseau</li>
<li>"The Design and Implementation of the FreeBSD Operating System" by McKusick et al.</li>
<li>"Linux Kernel Development" by Robert Love</li>
<li>"Windows Internals" by Russinovich, Solomon, and Ionescu</li>
</ul>
</li>
<li>
<p><strong>Online Resources</strong>:</p>
<ul>
<li>Linux kernel documentation</li>
<li>Microsoft Windows development documentation</li>
<li>Apple developer documentation</li>
<li>OSDev.org (OS development community)</li>
<li>OSTEP (Operating Systems: Three Easy Pieces) - free online</li>
</ul>
</li>
<li>
<p><strong>Courses</strong>:</p>
<ul>
<li>MIT 6.828: Operating System Engineering</li>
<li>UC Berkeley CS162: Operating Systems</li>
<li>Stanford CS140: Operating Systems</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../misc/blockchain.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rtos/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../misc/blockchain.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rtos/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
