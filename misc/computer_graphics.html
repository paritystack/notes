<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Computer Graphics - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-c422b50d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-bd4efd9a.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="computer-graphics"><a class="header" href="#computer-graphics">Computer Graphics</a></h1>
<p>A comprehensive guide to computer graphics fundamentals, rendering techniques, and modern graphics programming.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#computer-graphics-fundamentals">Computer Graphics Fundamentals</a></li>
<li><a href="#coordinate-systems-and-transformations">Coordinate Systems and Transformations</a></li>
<li><a href="#graphics-pipeline">Graphics Pipeline</a></li>
<li><a href="#2d-graphics">2D Graphics</a></li>
<li><a href="#3d-graphics">3D Graphics</a></li>
<li><a href="#rasterization">Rasterization</a></li>
<li><a href="#shading-and-lighting">Shading and Lighting</a></li>
<li><a href="#texturing">Texturing</a></li>
<li><a href="#advanced-rendering-techniques">Advanced Rendering Techniques</a></li>
<li><a href="#animation">Animation</a></li>
<li><a href="#graphics-apis">Graphics APIs</a></li>
<li><a href="#ray-tracing">Ray Tracing</a></li>
<li><a href="#gpu-architecture">GPU Architecture</a></li>
<li><a href="#modern-graphics-techniques">Modern Graphics Techniques</a></li>
</ol>
<hr>
<h2 id="computer-graphics-fundamentals"><a class="header" href="#computer-graphics-fundamentals">Computer Graphics Fundamentals</a></h2>
<p><strong>Computer Graphics</strong> is the field of visual computing that deals with generating, manipulating, and rendering visual content using computers.</p>
<h3 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h3>
<ol>
<li><strong>Rendering</strong>: The process of generating an image from a model</li>
<li><strong>Rasterization</strong>: Converting vector graphics to raster (pixel) format</li>
<li><strong>Pixel</strong>: The smallest addressable element in a display device</li>
<li><strong>Frame Buffer</strong>: Memory buffer containing the complete frame data</li>
<li><strong>Refresh Rate</strong>: How many times per second the display is redrawn</li>
<li><strong>Resolution</strong>: The number of pixels in each dimension (width × height)</li>
</ol>
<h3 id="color-models"><a class="header" href="#color-models">Color Models</a></h3>
<h4 id="rgb-red-green-blue"><a class="header" href="#rgb-red-green-blue">RGB (Red, Green, Blue)</a></h4>
<ul>
<li><strong>Additive color model</strong> used in displays</li>
<li>Each color component ranges from 0-255 (8-bit) or 0.0-1.0 (normalized)</li>
<li>White = (255, 255, 255), Black = (0, 0, 0)</li>
<li>Used in monitors, TVs, and digital displays</li>
</ul>
<pre><code class="language-python"># RGB color representation
red = (255, 0, 0)
green = (0, 255, 0)
blue = (0, 0, 255)
white = (255, 255, 255)
</code></pre>
<h4 id="rgba-rgb--alpha"><a class="header" href="#rgba-rgb--alpha">RGBA (RGB + Alpha)</a></h4>
<ul>
<li>Extends RGB with an alpha channel for transparency</li>
<li>Alpha: 0 = fully transparent, 255 = fully opaque</li>
</ul>
<h4 id="hsvhsl-hue-saturation-valuelightness"><a class="header" href="#hsvhsl-hue-saturation-valuelightness">HSV/HSL (Hue, Saturation, Value/Lightness)</a></h4>
<ul>
<li><strong>Cylindrical color model</strong> more intuitive for human perception</li>
<li>Hue: Color type (0-360 degrees)</li>
<li>Saturation: Color intensity (0-100%)</li>
<li>Value/Lightness: Brightness (0-100%)</li>
</ul>
<h4 id="cmyk-cyan-magenta-yellow-black"><a class="header" href="#cmyk-cyan-magenta-yellow-black">CMYK (Cyan, Magenta, Yellow, Black)</a></h4>
<ul>
<li><strong>Subtractive color model</strong> used in printing</li>
<li>White paper + no ink = white</li>
<li>All inks combined = black</li>
</ul>
<hr>
<h2 id="coordinate-systems-and-transformations"><a class="header" href="#coordinate-systems-and-transformations">Coordinate Systems and Transformations</a></h2>
<h3 id="coordinate-systems"><a class="header" href="#coordinate-systems">Coordinate Systems</a></h3>
<h4 id="1-objectmodel-space"><a class="header" href="#1-objectmodel-space">1. Object/Model Space</a></h4>
<ul>
<li>Local coordinate system for each object</li>
<li>Origin typically at object’s center or base</li>
<li>Defined by the artist/modeler</li>
</ul>
<h4 id="2-world-space"><a class="header" href="#2-world-space">2. World Space</a></h4>
<ul>
<li>Global coordinate system for the entire scene</li>
<li>Objects are positioned relative to a common origin</li>
<li>Result of applying <strong>Model transformation</strong></li>
</ul>
<h4 id="3-viewcamera-space"><a class="header" href="#3-viewcamera-space">3. View/Camera Space</a></h4>
<ul>
<li>Coordinate system relative to the camera</li>
<li>Camera at origin, looking down -Z axis</li>
<li>Result of applying <strong>View transformation</strong></li>
</ul>
<h4 id="4-clip-space"><a class="header" href="#4-clip-space">4. Clip Space</a></h4>
<ul>
<li>After projection, coordinates in [-1, 1] range (OpenGL) or [0, 1] (DirectX)</li>
<li>Result of applying <strong>Projection transformation</strong></li>
</ul>
<h4 id="5-screen-space"><a class="header" href="#5-screen-space">5. Screen Space</a></h4>
<ul>
<li>Final 2D pixel coordinates on screen</li>
<li>Result of <strong>Viewport transformation</strong></li>
</ul>
<h3 id="transformation-matrices"><a class="header" href="#transformation-matrices">Transformation Matrices</a></h3>
<h4 id="translation"><a class="header" href="#translation">Translation</a></h4>
<p>Moves an object in space.</p>
<pre><code>T(tx, ty, tz) = |1  0  0  tx|
                |0  1  0  ty|
                |0  0  1  tz|
                |0  0  0  1 |
</code></pre>
<h4 id="scaling"><a class="header" href="#scaling">Scaling</a></h4>
<p>Changes object size.</p>
<pre><code>S(sx, sy, sz) = |sx 0  0  0|
                |0  sy 0  0|
                |0  0  sz 0|
                |0  0  0  1|
</code></pre>
<h4 id="rotation"><a class="header" href="#rotation">Rotation</a></h4>
<p>Rotates object around an axis.</p>
<p><strong>Rotation around Z-axis:</strong></p>
<pre><code>Rz(θ) = |cos(θ) -sin(θ)  0  0|
        |sin(θ)  cos(θ)  0  0|
        |0       0       1  0|
        |0       0       0  1|
</code></pre>
<h4 id="model-view-projection-mvp-matrix"><a class="header" href="#model-view-projection-mvp-matrix">Model-View-Projection (MVP) Matrix</a></h4>
<p>The fundamental transformation pipeline:</p>
<pre><code>P_clip = Projection × View × Model × P_local
</code></pre>
<p>Where:</p>
<ul>
<li><strong>Model</strong>: Transforms from object space to world space</li>
<li><strong>View</strong>: Transforms from world space to camera space</li>
<li><strong>Projection</strong>: Transforms from camera space to clip space</li>
</ul>
<h3 id="homogeneous-coordinates"><a class="header" href="#homogeneous-coordinates">Homogeneous Coordinates</a></h3>
<p>Use 4D coordinates (x, y, z, w) to represent 3D points:</p>
<ul>
<li>Point: (x, y, z, 1)</li>
<li>Vector: (x, y, z, 0)</li>
</ul>
<p><strong>Benefits:</strong></p>
<ul>
<li>Enables translation using matrix multiplication</li>
<li>Simplifies perspective projection</li>
<li>Allows distinction between points and vectors</li>
</ul>
<hr>
<h2 id="graphics-pipeline"><a class="header" href="#graphics-pipeline">Graphics Pipeline</a></h2>
<p>The <strong>graphics pipeline</strong> is the sequence of steps used to render a 3D scene to a 2D image.</p>
<h3 id="traditional-fixed-function-pipeline"><a class="header" href="#traditional-fixed-function-pipeline">Traditional Fixed-Function Pipeline</a></h3>
<ol>
<li>
<p><strong>Vertex Processing</strong></p>
<ul>
<li>Transform vertices to clip space</li>
<li>Apply lighting calculations (per-vertex)</li>
<li>Generate texture coordinates</li>
</ul>
</li>
<li>
<p><strong>Primitive Assembly</strong></p>
<ul>
<li>Group vertices into primitives (triangles, lines, points)</li>
</ul>
</li>
<li>
<p><strong>Rasterization</strong></p>
<ul>
<li>Convert primitives to fragments (potential pixels)</li>
<li>Interpolate vertex attributes across fragments</li>
</ul>
</li>
<li>
<p><strong>Fragment Processing</strong></p>
<ul>
<li>Apply texturing</li>
<li>Calculate final color per fragment</li>
</ul>
</li>
<li>
<p><strong>Output Merger</strong></p>
<ul>
<li>Depth testing (Z-buffer)</li>
<li>Blending (transparency)</li>
<li>Write to framebuffer</li>
</ul>
</li>
</ol>
<h3 id="modern-programmable-pipeline"><a class="header" href="#modern-programmable-pipeline">Modern Programmable Pipeline</a></h3>
<pre><code>Vertex Data
    ↓
Vertex Shader (programmable)
    ↓
Tessellation Control Shader (optional)
    ↓
Tessellation Evaluation Shader (optional)
    ↓
Geometry Shader (optional)
    ↓
Rasterization (fixed)
    ↓
Fragment/Pixel Shader (programmable)
    ↓
Output Merger (configurable)
    ↓
Frame Buffer
</code></pre>
<h4 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex Shader</a></h4>
<ul>
<li>Processes each vertex independently</li>
<li>Transforms vertex positions (MVP transformation)</li>
<li>Calculates lighting per vertex</li>
<li>Outputs position and attributes for next stage</li>
</ul>
<pre><code class="language-glsl">// Simple GLSL vertex shader
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec3 Normal;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
</code></pre>
<h4 id="fragment-shader"><a class="header" href="#fragment-shader">Fragment Shader</a></h4>
<ul>
<li>Processes each fragment (potential pixel)</li>
<li>Calculates final color</li>
<li>Applies texturing and lighting</li>
<li>Can discard fragments</li>
</ul>
<pre><code class="language-glsl">// Simple GLSL fragment shader
#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main() {
    // Ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // Diffuse
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    // Specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;

    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}
</code></pre>
<hr>
<h2 id="2d-graphics"><a class="header" href="#2d-graphics">2D Graphics</a></h2>
<h3 id="primitive-shapes"><a class="header" href="#primitive-shapes">Primitive Shapes</a></h3>
<h4 id="line-drawing"><a class="header" href="#line-drawing">Line Drawing</a></h4>
<p><strong>Bresenham’s Line Algorithm</strong> - efficient integer-only line drawing:</p>
<pre><code class="language-python">def bresenham_line(x0, y0, x1, y1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 &lt; x1 else -1
    sy = 1 if y0 &lt; y1 else -1
    err = dx - dy

    while True:
        points.append((x0, y0))
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 &gt; -dy:
            err -= dy
            x0 += sx
        if e2 &lt; dx:
            err += dx
            y0 += sy

    return points
</code></pre>
<h4 id="circle-drawing"><a class="header" href="#circle-drawing">Circle Drawing</a></h4>
<p><strong>Midpoint Circle Algorithm</strong>:</p>
<pre><code class="language-python">def midpoint_circle(xc, yc, r):
    points = []
    x = 0
    y = r
    p = 1 - r

    while x &lt;= y:
        # Plot 8 symmetric points
        points.extend([
            (xc + x, yc + y), (xc - x, yc + y),
            (xc + x, yc - y), (xc - x, yc - y),
            (xc + y, yc + x), (xc - y, yc + x),
            (xc + y, yc - x), (xc - y, yc - x)
        ])

        x += 1
        if p &lt; 0:
            p += 2 * x + 1
        else:
            y -= 1
            p += 2 * (x - y) + 1

    return points
</code></pre>
<h3 id="polygon-filling"><a class="header" href="#polygon-filling">Polygon Filling</a></h3>
<h4 id="scanline-fill-algorithm"><a class="header" href="#scanline-fill-algorithm">Scanline Fill Algorithm</a></h4>
<ol>
<li>Find intersections of scanline with polygon edges</li>
<li>Sort intersections by x-coordinate</li>
<li>Fill between pairs of intersections</li>
</ol>
<h4 id="flood-fill-algorithm"><a class="header" href="#flood-fill-algorithm">Flood Fill Algorithm</a></h4>
<ul>
<li>Recursive or queue-based filling from a seed point</li>
<li>Used in paint programs</li>
</ul>
<pre><code class="language-python">def flood_fill(image, x, y, new_color, old_color):
    if (x &lt; 0 or x &gt;= image.width or y &lt; 0 or y &gt;= image.height):
        return
    if image[x][y] != old_color:
        return

    image[x][y] = new_color
    flood_fill(image, x+1, y, new_color, old_color)
    flood_fill(image, x-1, y, new_color, old_color)
    flood_fill(image, x, y+1, new_color, old_color)
    flood_fill(image, x, y-1, new_color, old_color)
</code></pre>
<h3 id="2d-transformations"><a class="header" href="#2d-transformations">2D Transformations</a></h3>
<p>Using 3×3 matrices with homogeneous coordinates (x, y, 1):</p>
<pre><code>Translation: |1  0  tx|
            |0  1  ty|
            |0  0  1 |

Rotation:    |cos(θ) -sin(θ)  0|
            |sin(θ)  cos(θ)  0|
            |0       0       1|

Scaling:     |sx  0   0|
            |0   sy  0|
            |0   0   1|
</code></pre>
<hr>
<h2 id="3d-graphics"><a class="header" href="#3d-graphics">3D Graphics</a></h2>
<h3 id="3d-representations"><a class="header" href="#3d-representations">3D Representations</a></h3>
<h4 id="1-polygon-meshes"><a class="header" href="#1-polygon-meshes">1. Polygon Meshes</a></h4>
<ul>
<li>Most common representation</li>
<li>Surface approximated by connected polygons (usually triangles)</li>
<li><strong>Vertices</strong>: 3D points</li>
<li><strong>Edges</strong>: Lines connecting vertices</li>
<li><strong>Faces</strong>: Polygons formed by edges</li>
</ul>
<pre><code class="language-python"># Triangle mesh structure
class Mesh:
    def __init__(self):
        self.vertices = []  # List of (x, y, z) tuples
        self.faces = []     # List of vertex index tuples
        self.normals = []   # List of normal vectors
        self.uvs = []       # List of texture coordinates
</code></pre>
<h4 id="2-parametric-surfaces"><a class="header" href="#2-parametric-surfaces">2. Parametric Surfaces</a></h4>
<ul>
<li>Surfaces defined by mathematical functions</li>
<li>Examples: Bezier surfaces, B-splines, NURBS</li>
</ul>
<h4 id="3-implicit-surfaces"><a class="header" href="#3-implicit-surfaces">3. Implicit Surfaces</a></h4>
<ul>
<li>Defined by equations: f(x, y, z) = 0</li>
<li>Examples: Spheres, metaballs</li>
</ul>
<h4 id="4-voxels"><a class="header" href="#4-voxels">4. Voxels</a></h4>
<ul>
<li>3D pixels - volumetric representation</li>
<li>Used in medical imaging, scientific visualization</li>
</ul>
<h3 id="face-culling"><a class="header" href="#face-culling">Face Culling</a></h3>
<p><strong>Back-face Culling</strong> - don’t render polygons facing away from camera:</p>
<pre><code class="language-python">def is_front_facing(vertex0, vertex1, vertex2, camera_pos):
    # Calculate face normal
    edge1 = vertex1 - vertex0
    edge2 = vertex2 - vertex0
    normal = cross(edge1, edge2)

    # Vector from face to camera
    to_camera = camera_pos - vertex0

    # If dot product is positive, face is front-facing
    return dot(normal, to_camera) &gt; 0
</code></pre>
<h3 id="projection"><a class="header" href="#projection">Projection</a></h3>
<h4 id="orthographic-projection"><a class="header" href="#orthographic-projection">Orthographic Projection</a></h4>
<ul>
<li>Parallel projection</li>
<li>No perspective distortion</li>
<li>Used in CAD, technical drawings</li>
</ul>
<pre><code>Ortho Matrix:
|2/(r-l)    0         0        -(r+l)/(r-l)|
|0          2/(t-b)   0        -(t+b)/(t-b)|
|0          0        -2/(f-n)  -(f+n)/(f-n)|
|0          0         0         1          |

where l,r = left,right; b,t = bottom,top; n,f = near,far
</code></pre>
<h4 id="perspective-projection"><a class="header" href="#perspective-projection">Perspective Projection</a></h4>
<ul>
<li>Simulates how human eyes see</li>
<li>Objects farther away appear smaller</li>
<li>Parallel lines converge at vanishing points</li>
</ul>
<pre><code>Perspective Matrix (OpenGL):
|2n/(r-l)   0         (r+l)/(r-l)   0        |
|0          2n/(t-b)  (t+b)/(t-b)   0        |
|0          0        -(f+n)/(f-n)  -2fn/(f-n)|
|0          0        -1             0        |
</code></pre>
<p><strong>Field of View (FOV)</strong> formulation:</p>
<pre><code class="language-python">def perspective_matrix(fov_y, aspect, near, far):
    f = 1.0 / tan(fov_y / 2.0)
    return [
        [f/aspect, 0, 0, 0],
        [0, f, 0, 0],
        [0, 0, (far+near)/(near-far), (2*far*near)/(near-far)],
        [0, 0, -1, 0]
    ]
</code></pre>
<hr>
<h2 id="rasterization"><a class="header" href="#rasterization">Rasterization</a></h2>
<p><strong>Rasterization</strong> converts geometric primitives (triangles) into fragments (pixels).</p>
<h3 id="triangle-rasterization"><a class="header" href="#triangle-rasterization">Triangle Rasterization</a></h3>
<h4 id="scanline-rasterization"><a class="header" href="#scanline-rasterization">Scanline Rasterization</a></h4>
<ol>
<li>Sort vertices by y-coordinate</li>
<li>Interpolate edges</li>
<li>Fill horizontal spans between edges</li>
</ol>
<h4 id="barycentric-coordinates"><a class="header" href="#barycentric-coordinates">Barycentric Coordinates</a></h4>
<p>Used for attribute interpolation across triangles:</p>
<pre><code class="language-python">def barycentric_coords(p, a, b, c):
    """
    Compute barycentric coordinates (u, v, w) for point p
    with respect to triangle (a, b, c)
    """
    v0 = b - a
    v1 = c - a
    v2 = p - a

    d00 = dot(v0, v0)
    d01 = dot(v0, v1)
    d11 = dot(v1, v1)
    d20 = dot(v2, v0)
    d21 = dot(v2, v1)

    denom = d00 * d11 - d01 * d01
    v = (d11 * d20 - d01 * d21) / denom
    w = (d00 * d21 - d01 * d20) / denom
    u = 1.0 - v - w

    return (u, v, w)

# Interpolate attribute at point p
def interpolate_attribute(p, a, b, c, attr_a, attr_b, attr_c):
    u, v, w = barycentric_coords(p, a, b, c)
    return u * attr_a + v * attr_b + w * attr_c
</code></pre>
<h3 id="z-buffer-depth-buffer"><a class="header" href="#z-buffer-depth-buffer">Z-Buffer (Depth Buffer)</a></h3>
<p>Solves the <strong>visibility problem</strong> - which surfaces are in front:</p>
<pre><code class="language-python">def render_with_zbuffer(triangles, width, height):
    color_buffer = [[background_color] * width for _ in range(height)]
    z_buffer = [[float('inf')] * width for _ in range(height)]

    for triangle in triangles:
        for x, y in pixels_covered_by_triangle(triangle):
            z = interpolate_depth(triangle, x, y)

            if z &lt; z_buffer[y][x]:
                z_buffer[y][x] = z
                color_buffer[y][x] = shade_pixel(triangle, x, y)

    return color_buffer
</code></pre>
<p><strong>Properties:</strong></p>
<ul>
<li>Most common visibility algorithm</li>
<li>O(n) time complexity for n triangles</li>
<li>Requires memory for depth buffer (typically 24 or 32 bits per pixel)</li>
<li>Handles complex scenes efficiently</li>
</ul>
<hr>
<h2 id="shading-and-lighting"><a class="header" href="#shading-and-lighting">Shading and Lighting</a></h2>
<h3 id="lighting-models"><a class="header" href="#lighting-models">Lighting Models</a></h3>
<h4 id="phong-reflection-model"><a class="header" href="#phong-reflection-model">Phong Reflection Model</a></h4>
<p>Models light-surface interaction with three components:</p>
<p><strong>1. Ambient</strong>: Background illumination</p>
<pre><code>I_ambient = k_a × I_a
</code></pre>
<p><strong>2. Diffuse</strong>: Matte reflection (Lambertian)</p>
<pre><code>I_diffuse = k_d × I_l × max(N · L, 0)
</code></pre>
<p><strong>3. Specular</strong>: Shiny highlights</p>
<pre><code>I_specular = k_s × I_l × max(R · V, 0)^α
</code></pre>
<p><strong>Total illumination:</strong></p>
<pre><code>I = I_ambient + I_diffuse + I_specular
</code></pre>
<p>Where:</p>
<ul>
<li><code>k_a, k_d, k_s</code>: Ambient, diffuse, specular coefficients</li>
<li><code>I_a, I_l</code>: Ambient and light intensities</li>
<li><code>N</code>: Surface normal</li>
<li><code>L</code>: Light direction</li>
<li><code>R</code>: Reflection direction</li>
<li><code>V</code>: View direction</li>
<li><code>α</code>: Shininess exponent</li>
</ul>
<h4 id="blinn-phong-model"><a class="header" href="#blinn-phong-model">Blinn-Phong Model</a></h4>
<p>More efficient variation using halfway vector:</p>
<pre><code>I_specular = k_s × I_l × max(N · H, 0)^α

where H = normalize(L + V)
</code></pre>
<h3 id="shading-techniques"><a class="header" href="#shading-techniques">Shading Techniques</a></h3>
<h4 id="flat-shading"><a class="header" href="#flat-shading">Flat Shading</a></h4>
<ul>
<li>One color per polygon</li>
<li>Fast but faceted appearance</li>
<li>Suitable for low-poly models</li>
</ul>
<pre><code class="language-python">def flat_shade(triangle, light_dir):
    normal = calculate_face_normal(triangle)
    intensity = max(dot(normal, light_dir), 0)
    return base_color * intensity
</code></pre>
<h4 id="gouraud-shading-smooth-shading"><a class="header" href="#gouraud-shading-smooth-shading">Gouraud Shading (Smooth Shading)</a></h4>
<ul>
<li>Calculate lighting at vertices</li>
<li>Interpolate colors across face</li>
<li>Smooth appearance, faster than Phong</li>
</ul>
<pre><code class="language-python">def gouraud_shade(triangle, light_dir):
    # Calculate intensity at each vertex
    i0 = phong_lighting(triangle.v0, triangle.n0, light_dir)
    i1 = phong_lighting(triangle.v1, triangle.n1, light_dir)
    i2 = phong_lighting(triangle.v2, triangle.n2, light_dir)

    # Interpolate across triangle
    for pixel in triangle:
        u, v, w = barycentric_coords(pixel, triangle)
        intensity = u*i0 + v*i1 + w*i2
        pixel.color = base_color * intensity
</code></pre>
<h4 id="phong-shading"><a class="header" href="#phong-shading">Phong Shading</a></h4>
<ul>
<li>Interpolate normals across face</li>
<li>Calculate lighting per pixel</li>
<li>High quality, more expensive</li>
</ul>
<pre><code class="language-python">def phong_shade(triangle, light_dir, view_dir):
    for pixel in triangle:
        # Interpolate normal at pixel
        u, v, w = barycentric_coords(pixel, triangle)
        normal = normalize(u*n0 + v*n1 + w*n2)

        # Calculate lighting for this pixel
        intensity = phong_lighting(pixel.pos, normal, light_dir, view_dir)
        pixel.color = base_color * intensity
</code></pre>
<h3 id="light-types"><a class="header" href="#light-types">Light Types</a></h3>
<h4 id="1-directional-light"><a class="header" href="#1-directional-light">1. Directional Light</a></h4>
<ul>
<li>Parallel rays (sun-like)</li>
<li>No position, only direction</li>
<li>Same intensity everywhere</li>
</ul>
<pre><code class="language-glsl">vec3 directional_light(vec3 direction, vec3 normal) {
    return max(dot(normal, -direction), 0.0);
}
</code></pre>
<h4 id="2-point-light"><a class="header" href="#2-point-light">2. Point Light</a></h4>
<ul>
<li>Radiates in all directions</li>
<li>Intensity decreases with distance (attenuation)</li>
</ul>
<pre><code class="language-glsl">vec3 point_light(vec3 lightPos, vec3 fragPos, vec3 normal) {
    vec3 lightDir = normalize(lightPos - fragPos);
    float distance = length(lightPos - fragPos);
    float attenuation = 1.0 / (constant + linear * distance +
                               quadratic * distance * distance);
    return max(dot(normal, lightDir), 0.0) * attenuation;
}
</code></pre>
<h4 id="3-spot-light"><a class="header" href="#3-spot-light">3. Spot Light</a></h4>
<ul>
<li>Cone of light from a point</li>
<li>Has position, direction, and cutoff angle</li>
</ul>
<pre><code class="language-glsl">vec3 spot_light(vec3 lightPos, vec3 lightDir, vec3 fragPos, vec3 normal) {
    vec3 toFragment = normalize(fragPos - lightPos);
    float theta = dot(toFragment, normalize(lightDir));

    if (theta &gt; cutoff) {
        // Inside spotlight cone
        float intensity = (theta - outerCutoff) / (cutoff - outerCutoff);
        return intensity * point_light(lightPos, fragPos, normal);
    }
    return vec3(0.0);
}
</code></pre>
<h4 id="4-area-light"><a class="header" href="#4-area-light">4. Area Light</a></h4>
<ul>
<li>Extended light source</li>
<li>Soft shadows</li>
<li>More computationally expensive</li>
</ul>
<hr>
<h2 id="texturing"><a class="header" href="#texturing">Texturing</a></h2>
<p><strong>Texture mapping</strong> applies images (textures) to 3D surfaces.</p>
<h3 id="texture-coordinates-uv-mapping"><a class="header" href="#texture-coordinates-uv-mapping">Texture Coordinates (UV Mapping)</a></h3>
<ul>
<li>Map 3D surface to 2D texture space</li>
<li>U, V coordinates typically in range [0, 1]</li>
<li>Assigned to vertices, interpolated across faces</li>
</ul>
<pre><code class="language-python">class Vertex:
    def __init__(self, position, normal, uv):
        self.position = position  # (x, y, z)
        self.normal = normal      # (nx, ny, nz)
        self.uv = uv             # (u, v)
</code></pre>
<h3 id="texture-filtering"><a class="header" href="#texture-filtering">Texture Filtering</a></h3>
<h4 id="nearest-neighbor-point-sampling"><a class="header" href="#nearest-neighbor-point-sampling">Nearest Neighbor (Point Sampling)</a></h4>
<ul>
<li>Use closest texel</li>
<li>Fast but blocky when magnified</li>
</ul>
<pre><code class="language-python">def nearest_neighbor(texture, u, v):
    x = int(u * texture.width)
    y = int(v * texture.height)
    return texture[y][x]
</code></pre>
<h4 id="bilinear-filtering"><a class="header" href="#bilinear-filtering">Bilinear Filtering</a></h4>
<ul>
<li>Interpolate between 4 nearest texels</li>
<li>Smoother results</li>
</ul>
<pre><code class="language-python">def bilinear_filter(texture, u, v):
    x = u * (texture.width - 1)
    y = v * (texture.height - 1)

    x0, y0 = int(x), int(y)
    x1, y1 = x0 + 1, y0 + 1

    # Fractional parts
    fx = x - x0
    fy = y - y0

    # Get 4 texel colors
    c00 = texture[y0][x0]
    c10 = texture[y0][x1]
    c01 = texture[y1][x0]
    c11 = texture[y1][x1]

    # Interpolate
    c0 = lerp(c00, c10, fx)
    c1 = lerp(c01, c11, fx)
    return lerp(c0, c1, fy)
</code></pre>
<h4 id="trilinear-filtering"><a class="header" href="#trilinear-filtering">Trilinear Filtering</a></h4>
<ul>
<li>Bilinear filtering + interpolation between mipmap levels</li>
<li>Reduces aliasing</li>
</ul>
<h4 id="anisotropic-filtering"><a class="header" href="#anisotropic-filtering">Anisotropic Filtering</a></h4>
<ul>
<li>Adapts to surface angle</li>
<li>Best quality, most expensive</li>
<li>Common in modern games (2x, 4x, 8x, 16x)</li>
</ul>
<h3 id="mipmapping"><a class="header" href="#mipmapping">Mipmapping</a></h3>
<p>Pre-filtered texture pyramid for different distances:</p>
<pre><code>Level 0: 1024×1024 (original)
Level 1: 512×512
Level 2: 256×256
...
Level 10: 1×1
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Reduces aliasing at distance</li>
<li>Improves performance (better cache coherency)</li>
<li>33% more memory (1 + 1/4 + 1/16 + … = 4/3)</li>
</ul>
<pre><code class="language-python">def generate_mipmaps(texture):
    mipmaps = [texture]
    current = texture

    while current.width &gt; 1 and current.height &gt; 1:
        # Downsample by averaging 2×2 blocks
        next_level = Image(current.width // 2, current.height // 2)
        for y in range(next_level.height):
            for x in range(next_level.width):
                next_level[y][x] = average([
                    current[2*y][2*x],
                    current[2*y][2*x+1],
                    current[2*y+1][2*x],
                    current[2*y+1][2*x+1]
                ])
        mipmaps.append(next_level)
        current = next_level

    return mipmaps
</code></pre>
<h3 id="advanced-texture-types"><a class="header" href="#advanced-texture-types">Advanced Texture Types</a></h3>
<h4 id="1-normal-mapping"><a class="header" href="#1-normal-mapping">1. Normal Mapping</a></h4>
<ul>
<li>Store surface normals in texture</li>
<li>Add detail without geometry</li>
<li>RGB → normal vector (x, y, z)</li>
</ul>
<pre><code class="language-glsl">vec3 normal_mapping(sampler2D normalMap, vec2 uv, vec3 tangent, vec3 bitangent, vec3 normal) {
    // Sample normal from texture
    vec3 texNormal = texture(normalMap, uv).rgb * 2.0 - 1.0;

    // Transform from tangent space to world space
    mat3 TBN = mat3(tangent, bitangent, normal);
    return normalize(TBN * texNormal);
}
</code></pre>
<h4 id="2-displacement-mapping"><a class="header" href="#2-displacement-mapping">2. Displacement Mapping</a></h4>
<ul>
<li>Actually modify geometry based on texture</li>
<li>More expensive than normal mapping</li>
<li>True geometric detail</li>
</ul>
<h4 id="3-specular-mapping"><a class="header" href="#3-specular-mapping">3. Specular Mapping</a></h4>
<ul>
<li>Control specular intensity per pixel</li>
<li>Allows different material properties on one surface</li>
</ul>
<h4 id="4-environment-mapping-reflection-mapping"><a class="header" href="#4-environment-mapping-reflection-mapping">4. Environment Mapping (Reflection Mapping)</a></h4>
<ul>
<li>Simulate reflections using pre-rendered environment</li>
<li>Cube maps: 6 textures forming a cube</li>
<li>Sphere maps: single texture mapped to sphere</li>
</ul>
<pre><code class="language-glsl">vec3 environment_mapping(samplerCube envMap, vec3 viewDir, vec3 normal) {
    vec3 reflected = reflect(viewDir, normal);
    return texture(envMap, reflected).rgb;
}
</code></pre>
<h4 id="5-shadow-mapping"><a class="header" href="#5-shadow-mapping">5. Shadow Mapping</a></h4>
<ul>
<li>Store depth from light’s perspective</li>
<li>Compare with fragment depth to determine shadow</li>
</ul>
<hr>
<h2 id="advanced-rendering-techniques"><a class="header" href="#advanced-rendering-techniques">Advanced Rendering Techniques</a></h2>
<h3 id="physically-based-rendering-pbr"><a class="header" href="#physically-based-rendering-pbr">Physically Based Rendering (PBR)</a></h3>
<p>Modern rendering approach based on physical light behavior.</p>
<h4 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h4>
<ol>
<li><strong>Energy Conservation</strong>: Reflected light never exceeds incoming light</li>
<li><strong>Fresnel Effect</strong>: Reflectivity varies with viewing angle</li>
<li><strong>Microsurface Theory</strong>: Surfaces have microscopic geometry</li>
</ol>
<h4 id="pbr-material-properties"><a class="header" href="#pbr-material-properties">PBR Material Properties</a></h4>
<p><strong>Metallic Workflow:</strong></p>
<ul>
<li>Base Color (albedo)</li>
<li>Metallic (0 = dielectric, 1 = metal)</li>
<li>Roughness (0 = smooth, 1 = rough)</li>
<li>Ambient Occlusion</li>
</ul>
<p><strong>Specular Workflow:</strong></p>
<ul>
<li>Diffuse Color</li>
<li>Specular Color</li>
<li>Glossiness</li>
</ul>
<h4 id="cook-torrance-brdf"><a class="header" href="#cook-torrance-brdf">Cook-Torrance BRDF</a></h4>
<pre><code class="language-glsl">vec3 cook_torrance(vec3 N, vec3 V, vec3 L, vec3 albedo, float roughness, float metallic) {
    vec3 H = normalize(V + L);

    // Normal Distribution Function (GGX/Trowbridge-Reitz)
    float NDF = DistributionGGX(N, H, roughness);

    // Geometry Function (Smith's method)
    float G = GeometrySmith(N, V, L, roughness);

    // Fresnel (Schlick's approximation)
    vec3 F0 = mix(vec3(0.04), albedo, metallic);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

    // Specular term
    vec3 numerator = NDF * G * F;
    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
    vec3 specular = numerator / denominator;

    // Energy conservation
    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);

    // Lambertian diffuse
    vec3 diffuse = kD * albedo / PI;

    float NdotL = max(dot(N, L), 0.0);
    return (diffuse + specular) * NdotL;
}
</code></pre>
<h3 id="deferred-shading"><a class="header" href="#deferred-shading">Deferred Shading</a></h3>
<p>Separate geometry rendering from lighting calculations.</p>
<h4 id="g-buffer-geometry-buffer"><a class="header" href="#g-buffer-geometry-buffer">G-Buffer (Geometry Buffer)</a></h4>
<p>Multiple render targets storing:</p>
<ol>
<li>Position</li>
<li>Normal</li>
<li>Albedo/Color</li>
<li>Specular</li>
<li>Depth</li>
</ol>
<pre><code class="language-glsl">// G-Buffer pass (fragment shader)
layout (location = 0) out vec3 gPosition;
layout (location = 1) out vec3 gNormal;
layout (location = 2) out vec4 gAlbedoSpec;

void main() {
    gPosition = FragPos;
    gNormal = normalize(Normal);
    gAlbedoSpec.rgb = texture(albedoMap, TexCoords).rgb;
    gAlbedoSpec.a = texture(specularMap, TexCoords).r;
}

// Lighting pass
vec3 lighting = vec3(0.0);
for (Light light : lights) {
    vec3 position = texture(gPosition, TexCoords).rgb;
    vec3 normal = texture(gNormal, TexCoords).rgb;
    vec3 albedo = texture(gAlbedoSpec, TexCoords).rgb;

    lighting += calculate_light(light, position, normal, albedo);
}
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Handle many lights efficiently</li>
<li>Lighting calculated once per visible pixel</li>
<li>Separate geometry and lighting complexity</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>High memory bandwidth</li>
<li>No hardware MSAA support</li>
<li>Transparency requires separate pass</li>
</ul>
<h3 id="screen-space-techniques"><a class="header" href="#screen-space-techniques">Screen Space Techniques</a></h3>
<h4 id="screen-space-ambient-occlusion-ssao"><a class="header" href="#screen-space-ambient-occlusion-ssao">Screen Space Ambient Occlusion (SSAO)</a></h4>
<ul>
<li>Approximate ambient occlusion in screen space</li>
<li>Sample depth buffer around each pixel</li>
<li>Darken occluded areas</li>
</ul>
<pre><code class="language-glsl">float ssao(vec2 texCoord, vec3 position, vec3 normal) {
    float occlusion = 0.0;

    for (int i = 0; i &lt; kernelSize; i++) {
        // Sample position
        vec3 samplePos = position + kernel[i] * radius;

        // Project to screen space
        vec4 offset = projection * vec4(samplePos, 1.0);
        offset.xy /= offset.w;
        offset.xy = offset.xy * 0.5 + 0.5;

        // Get depth
        float sampleDepth = texture(depthTexture, offset.xy).r;

        // Range check and accumulate
        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(position.z - sampleDepth));
        occlusion += (sampleDepth &gt;= samplePos.z ? 1.0 : 0.0) * rangeCheck;
    }

    return 1.0 - (occlusion / kernelSize);
}
</code></pre>
<h4 id="screen-space-reflections-ssr"><a class="header" href="#screen-space-reflections-ssr">Screen Space Reflections (SSR)</a></h4>
<ul>
<li>Ray march through depth buffer</li>
<li>Approximate reflections without environment maps</li>
<li>Works well for planar surfaces</li>
</ul>
<h3 id="shadow-techniques"><a class="header" href="#shadow-techniques">Shadow Techniques</a></h3>
<h4 id="1-shadow-mapping"><a class="header" href="#1-shadow-mapping">1. Shadow Mapping</a></h4>
<pre><code class="language-glsl">// Render depth from light's perspective
float shadow = 0.0;
vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
projCoords = projCoords * 0.5 + 0.5;

float closestDepth = texture(shadowMap, projCoords.xy).r;
float currentDepth = projCoords.z;

shadow = currentDepth &gt; closestDepth ? 1.0 : 0.0;
</code></pre>
<h4 id="2-percentage-closer-filtering-pcf"><a class="header" href="#2-percentage-closer-filtering-pcf">2. Percentage Closer Filtering (PCF)</a></h4>
<ul>
<li>Sample multiple shadow map locations</li>
<li>Soft shadow edges</li>
</ul>
<pre><code class="language-glsl">float shadow = 0.0;
vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
for(int x = -1; x &lt;= 1; x++) {
    for(int y = -1; y &lt;= 1; y++) {
        float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
        shadow += currentDepth &gt; pcfDepth ? 1.0 : 0.0;
    }
}
shadow /= 9.0;
</code></pre>
<h4 id="3-cascaded-shadow-maps-csm"><a class="header" href="#3-cascaded-shadow-maps-csm">3. Cascaded Shadow Maps (CSM)</a></h4>
<ul>
<li>Multiple shadow maps for different distances</li>
<li>Higher resolution near camera</li>
<li>Common in outdoor scenes</li>
</ul>
<h4 id="4-variance-shadow-maps-vsm"><a class="header" href="#4-variance-shadow-maps-vsm">4. Variance Shadow Maps (VSM)</a></h4>
<ul>
<li>Store depth and depth² in shadow map</li>
<li>Use Chebyshev’s inequality for smooth shadows</li>
</ul>
<hr>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<h3 id="keyframe-animation"><a class="header" href="#keyframe-animation">Keyframe Animation</a></h3>
<p>Store key poses at specific times, interpolate between them.</p>
<pre><code class="language-python">class KeyFrame:
    def __init__(self, time, value):
        self.time = time
        self.value = value

class Animation:
    def __init__(self):
        self.keyframes = []

    def add_keyframe(self, time, value):
        self.keyframes.append(KeyFrame(time, value))
        self.keyframes.sort(key=lambda k: k.time)

    def evaluate(self, time):
        # Find surrounding keyframes
        for i in range(len(self.keyframes) - 1):
            k0 = self.keyframes[i]
            k1 = self.keyframes[i + 1]

            if k0.time &lt;= time &lt;= k1.time:
                # Interpolate
                t = (time - k0.time) / (k1.time - k0.time)
                return self.interpolate(k0.value, k1.value, t)

        return self.keyframes[-1].value
</code></pre>
<h3 id="interpolation-methods"><a class="header" href="#interpolation-methods">Interpolation Methods</a></h3>
<h4 id="linear-interpolation-lerp"><a class="header" href="#linear-interpolation-lerp">Linear Interpolation (LERP)</a></h4>
<pre><code class="language-python">def lerp(a, b, t):
    return a + (b - a) * t
</code></pre>
<h4 id="spherical-linear-interpolation-slerp"><a class="header" href="#spherical-linear-interpolation-slerp">Spherical Linear Interpolation (SLERP)</a></h4>
<p>For quaternions (rotations):</p>
<pre><code class="language-python">def slerp(q1, q2, t):
    dot = q1.dot(q2)

    # Clamp dot product
    dot = max(-1.0, min(1.0, dot))

    theta = acos(dot) * t
    q3 = (q2 - q1 * dot).normalize()

    return q1 * cos(theta) + q3 * sin(theta)
</code></pre>
<h4 id="cubic-hermite-spline-smooth"><a class="header" href="#cubic-hermite-spline-smooth">Cubic Hermite Spline (Smooth)</a></h4>
<pre><code class="language-python">def hermite(p0, p1, m0, m1, t):
    t2 = t * t
    t3 = t2 * t

    h00 = 2*t3 - 3*t2 + 1
    h10 = t3 - 2*t2 + t
    h01 = -2*t3 + 3*t2
    h11 = t3 - t2

    return h00*p0 + h10*m0 + h01*p1 + h11*m1
</code></pre>
<h3 id="skeletal-animation-skinning"><a class="header" href="#skeletal-animation-skinning">Skeletal Animation (Skinning)</a></h3>
<h4 id="skeleton-structure"><a class="header" href="#skeleton-structure">Skeleton Structure</a></h4>
<pre><code class="language-python">class Bone:
    def __init__(self, name, parent=None):
        self.name = name
        self.parent = parent
        self.children = []
        self.local_transform = Matrix4x4.identity()
        self.inverse_bind_pose = Matrix4x4.identity()

    def get_world_transform(self):
        if self.parent:
            return self.parent.get_world_transform() * self.local_transform
        return self.local_transform
</code></pre>
<h4 id="vertex-skinning"><a class="header" href="#vertex-skinning">Vertex Skinning</a></h4>
<pre><code class="language-glsl">// Vertex shader with skinning
const int MAX_BONES = 100;
const int MAX_BONE_INFLUENCE = 4;

uniform mat4 bones[MAX_BONES];

in vec3 position;
in ivec4 boneIDs;
in vec4 weights;

void main() {
    mat4 boneTransform = bones[boneIDs[0]] * weights[0];
    boneTransform += bones[boneIDs[1]] * weights[1];
    boneTransform += bones[boneIDs[2]] * weights[2];
    boneTransform += bones[boneIDs[3]] * weights[3];

    vec4 localPosition = boneTransform * vec4(position, 1.0);
    gl_Position = projection * view * model * localPosition;
}
</code></pre>
<h3 id="inverse-kinematics-ik"><a class="header" href="#inverse-kinematics-ik">Inverse Kinematics (IK)</a></h3>
<p>Calculate joint angles to reach a target position.</p>
<pre><code class="language-python">def solve_two_bone_ik(root, mid, end, target):
    """
    Solve 2-bone IK (e.g., arm: shoulder-elbow-wrist)
    """
    # Distances
    a = distance(root, mid)  # Upper bone
    b = distance(mid, end)   # Lower bone
    c = distance(root, target)  # To target

    # Law of cosines
    # Angle at middle joint
    cos_B = (a*a + b*b - c*c) / (2*a*b)
    cos_B = clamp(cos_B, -1, 1)
    angle_B = acos(cos_B)

    # Angle at root
    cos_A = (a*a + c*c - b*b) / (2*a*c)
    cos_A = clamp(cos_A, -1, 1)
    angle_A = acos(cos_A)

    # Calculate rotations
    to_target = normalize(target - root)
    to_mid = normalize(mid - root)

    # Apply rotations to skeleton
    root.rotation = quaternion_from_to(to_mid, to_target) * angle_A
    mid.rotation = quaternion_axis_angle(perpendicular(to_mid), angle_B)
</code></pre>
<h3 id="blend-shapes-morph-targets"><a class="header" href="#blend-shapes-morph-targets">Blend Shapes (Morph Targets)</a></h3>
<p>Linear interpolation between different mesh shapes.</p>
<pre><code class="language-python">def blend_shapes(base_mesh, targets, weights):
    """
    targets: list of displacement vectors
    weights: blend weight for each target
    """
    result = base_mesh.copy()

    for i, (target, weight) in enumerate(zip(targets, weights)):
        for v in range(len(result.vertices)):
            result.vertices[v] += target.displacements[v] * weight

    return result
</code></pre>
<hr>
<h2 id="graphics-apis"><a class="header" href="#graphics-apis">Graphics APIs</a></h2>
<h3 id="opengl"><a class="header" href="#opengl">OpenGL</a></h3>
<p>Cross-platform graphics API, widely supported.</p>
<h4 id="basic-opengl-rendering-loop"><a class="header" href="#basic-opengl-rendering-loop">Basic OpenGL Rendering Loop</a></h4>
<pre><code class="language-c">// Initialization
GLuint VAO, VBO;
glGenVertexArrays(1, &amp;VAO);
glGenBuffers(1, &amp;VBO);

glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

// Render loop
while (!glfwWindowShouldClose(window)) {
    // Clear
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Use shader
    glUseProgram(shaderProgram);

    // Set uniforms
    glUniformMatrix4fv(mvpLoc, 1, GL_FALSE, glm::value_ptr(mvp));

    // Draw
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, vertexCount);

    // Swap buffers
    glfwSwapBuffers(window);
    glfwPollEvents();
}
</code></pre>
<h4 id="opengl-versions"><a class="header" href="#opengl-versions">OpenGL Versions</a></h4>
<ul>
<li><strong>OpenGL 2.1</strong>: Fixed-function pipeline</li>
<li><strong>OpenGL 3.3</strong>: Core profile, deprecated fixed-function</li>
<li><strong>OpenGL 4.x</strong>: Compute shaders, advanced features</li>
<li><strong>OpenGL ES</strong>: Mobile/embedded variant</li>
<li><strong>WebGL</strong>: JavaScript binding for browsers (based on OpenGL ES)</li>
</ul>
<h3 id="directx"><a class="header" href="#directx">DirectX</a></h3>
<p>Microsoft’s graphics API for Windows and Xbox.</p>
<h4 id="directx-11-example"><a class="header" href="#directx-11-example">DirectX 11 Example</a></h4>
<pre><code class="language-cpp">// Create device and swap chain
D3D_FEATURE_LEVEL featureLevel;
ID3D11Device* device;
ID3D11DeviceContext* context;
IDXGISwapChain* swapChain;

D3D11CreateDeviceAndSwapChain(
    nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr,
    0, nullptr, 0, D3D11_SDK_VERSION,
    &amp;swapChainDesc, &amp;swapChain,
    &amp;device, &amp;featureLevel, &amp;context
);

// Render loop
while (running) {
    // Clear
    context-&gt;ClearRenderTargetView(renderTargetView, clearColor);
    context-&gt;ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH, 1.0f, 0);

    // Set shaders
    context-&gt;VSSetShader(vertexShader, nullptr, 0);
    context-&gt;PSSetShader(pixelShader, nullptr, 0);

    // Draw
    context-&gt;DrawIndexed(indexCount, 0, 0);

    // Present
    swapChain-&gt;Present(1, 0);
}
</code></pre>
<h4 id="directx-versions"><a class="header" href="#directx-versions">DirectX Versions</a></h4>
<ul>
<li><strong>DirectX 9</strong>: Legacy, still used in some older games</li>
<li><strong>DirectX 11</strong>: Widely supported, good balance</li>
<li><strong>DirectX 12</strong>: Low-level, explicit control, more complex</li>
</ul>
<h3 id="vulkan"><a class="header" href="#vulkan">Vulkan</a></h3>
<p>Modern low-level cross-platform API.</p>
<p><strong>Key Concepts:</strong></p>
<ul>
<li><strong>Instance</strong>: Connection to Vulkan library</li>
<li><strong>Physical Device</strong>: GPU representation</li>
<li><strong>Logical Device</strong>: Interface to physical device</li>
<li><strong>Queue</strong>: Submit command buffers</li>
<li><strong>Command Buffer</strong>: Record rendering commands</li>
<li><strong>Pipeline</strong>: Complete rendering state</li>
</ul>
<pre><code class="language-cpp">// Create instance
VkInstanceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
createInfo.pApplicationInfo = &amp;appInfo;

VkInstance instance;
vkCreateInstance(&amp;createInfo, nullptr, &amp;instance);

// Create logical device
VkDevice device;
vkCreateDevice(physicalDevice, &amp;deviceCreateInfo, nullptr, &amp;device);

// Create command pool
VkCommandPool commandPool;
vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;commandPool);

// Record command buffer
vkBeginCommandBuffer(commandBuffer, &amp;beginInfo);
vkCmdBeginRenderPass(commandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
vkCmdDraw(commandBuffer, vertexCount, 1, 0, 0);
vkCmdEndRenderPass(commandBuffer);
vkEndCommandBuffer(commandBuffer);

// Submit and present
vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFence);
vkQueuePresentKHR(presentQueue, &amp;presentInfo);
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Explicit control over GPU</li>
<li>Multi-threaded command buffer recording</li>
<li>Less driver overhead</li>
<li>Better performance potential</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Verbose (1000+ lines for triangle)</li>
<li>Complex memory management</li>
<li>Steep learning curve</li>
</ul>
<h3 id="metal"><a class="header" href="#metal">Metal</a></h3>
<p>Apple’s graphics API for iOS and macOS.</p>
<pre><code class="language-swift">// Create device
let device = MTLCreateSystemDefaultDevice()
let commandQueue = device.makeCommandQueue()

// Create render pipeline
let pipelineDescriptor = MTLRenderPipelineDescriptor()
pipelineDescriptor.vertexFunction = vertexFunction
pipelineDescriptor.fragmentFunction = fragmentFunction
let pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)

// Render
let commandBuffer = commandQueue.makeCommandBuffer()
let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)

renderEncoder.setRenderPipelineState(pipelineState)
renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
renderEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3)

renderEncoder.endEncoding()
commandBuffer.present(drawable)
commandBuffer.commit()
</code></pre>
<h3 id="webgl"><a class="header" href="#webgl">WebGL</a></h3>
<p>OpenGL ES for the web.</p>
<pre><code class="language-javascript">// Get context
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2');

// Create shader program
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Create buffer
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

// Render loop
function render() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.uniformMatrix4fv(mvpLocation, false, mvpMatrix);
    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

    requestAnimationFrame(render);
}
render();
</code></pre>
<hr>
<h2 id="ray-tracing"><a class="header" href="#ray-tracing">Ray Tracing</a></h2>
<p><strong>Ray tracing</strong> simulates light physics by tracing rays from camera through pixels.</p>
<h3 id="basic-ray-tracing-algorithm"><a class="header" href="#basic-ray-tracing-algorithm">Basic Ray Tracing Algorithm</a></h3>
<pre><code class="language-python">def ray_trace(scene, camera, width, height):
    image = create_image(width, height)

    for y in range(height):
        for x in range(width):
            # Generate ray from camera through pixel
            ray = camera.generate_ray(x, y, width, height)

            # Trace ray and get color
            color = trace_ray(scene, ray, max_depth=5)

            image[y][x] = color

    return image

def trace_ray(scene, ray, depth):
    if depth &lt;= 0:
        return BLACK

    # Find closest intersection
    hit = scene.intersect(ray)

    if not hit:
        return scene.background_color

    # Calculate shading at hit point
    color = shade(scene, hit, ray)

    # Handle reflection
    if hit.material.reflective:
        reflect_dir = reflect(ray.direction, hit.normal)
        reflect_ray = Ray(hit.point + hit.normal * EPSILON, reflect_dir)
        reflect_color = trace_ray(scene, reflect_ray, depth - 1)
        color = color * (1 - hit.material.reflectivity) + reflect_color * hit.material.reflectivity

    # Handle refraction (transparency)
    if hit.material.transparent:
        refract_dir = refract(ray.direction, hit.normal, hit.material.ior)
        refract_ray = Ray(hit.point - hit.normal * EPSILON, refract_dir)
        refract_color = trace_ray(scene, refract_ray, depth - 1)
        color = mix(color, refract_color, hit.material.transparency)

    return color
</code></pre>
<h3 id="ray-object-intersection"><a class="header" href="#ray-object-intersection">Ray-Object Intersection</a></h3>
<h4 id="ray-sphere-intersection"><a class="header" href="#ray-sphere-intersection">Ray-Sphere Intersection</a></h4>
<pre><code class="language-python">class Sphere:
    def __init__(self, center, radius):
        self.center = center
        self.radius = radius

    def intersect(self, ray):
        # Ray: P(t) = origin + t * direction
        # Sphere: |P - center|² = radius²

        oc = ray.origin - self.center
        a = dot(ray.direction, ray.direction)
        b = 2.0 * dot(oc, ray.direction)
        c = dot(oc, oc) - self.radius * self.radius

        discriminant = b*b - 4*a*c

        if discriminant &lt; 0:
            return None  # No intersection

        t = (-b - sqrt(discriminant)) / (2.0 * a)

        if t &lt; 0:
            return None  # Behind ray origin

        hit_point = ray.at(t)
        normal = normalize(hit_point - self.center)

        return Hit(t, hit_point, normal, self)
</code></pre>
<h4 id="ray-triangle-intersection-möller-trumbore"><a class="header" href="#ray-triangle-intersection-möller-trumbore">Ray-Triangle Intersection (Möller-Trumbore)</a></h4>
<pre><code class="language-python">def ray_triangle_intersect(ray, v0, v1, v2):
    edge1 = v1 - v0
    edge2 = v2 - v0

    h = cross(ray.direction, edge2)
    a = dot(edge1, h)

    if abs(a) &lt; EPSILON:
        return None  # Ray parallel to triangle

    f = 1.0 / a
    s = ray.origin - v0
    u = f * dot(s, h)

    if u &lt; 0.0 or u &gt; 1.0:
        return None

    q = cross(s, edge1)
    v = f * dot(ray.direction, q)

    if v &lt; 0.0 or u + v &gt; 1.0:
        return None

    t = f * dot(edge2, q)

    if t &gt; EPSILON:
        hit_point = ray.at(t)
        normal = normalize(cross(edge1, edge2))
        return Hit(t, hit_point, normal, (u, v))

    return None
</code></pre>
<h3 id="acceleration-structures"><a class="header" href="#acceleration-structures">Acceleration Structures</a></h3>
<h4 id="bounding-volume-hierarchy-bvh"><a class="header" href="#bounding-volume-hierarchy-bvh">Bounding Volume Hierarchy (BVH)</a></h4>
<pre><code class="language-python">class BVHNode:
    def __init__(self, objects):
        if len(objects) == 1:
            self.left = self.right = None
            self.object = objects[0]
            self.bbox = objects[0].bounding_box()
        else:
            # Split objects
            axis = random.choice([0, 1, 2])
            objects.sort(key=lambda obj: obj.center()[axis])
            mid = len(objects) // 2

            self.left = BVHNode(objects[:mid])
            self.right = BVHNode(objects[mid:])
            self.object = None
            self.bbox = union(self.left.bbox, self.right.bbox)

    def intersect(self, ray):
        if not self.bbox.intersect(ray):
            return None

        if self.object:
            return self.object.intersect(ray)

        hit_left = self.left.intersect(ray) if self.left else None
        hit_right = self.right.intersect(ray) if self.right else None

        if hit_left and hit_right:
            return hit_left if hit_left.t &lt; hit_right.t else hit_right
        return hit_left or hit_right
</code></pre>
<h3 id="path-tracing-global-illumination"><a class="header" href="#path-tracing-global-illumination">Path Tracing (Global Illumination)</a></h3>
<p>More physically accurate than basic ray tracing.</p>
<pre><code class="language-python">def path_trace(scene, ray, depth):
    if depth &lt;= 0:
        return BLACK

    hit = scene.intersect(ray)
    if not hit:
        return scene.background_color

    # Direct lighting
    direct = sample_lights(scene, hit)

    # Indirect lighting (Monte Carlo integration)
    if random.random() &lt; 0.5:  # Russian roulette
        # Sample random direction in hemisphere
        random_dir = sample_hemisphere(hit.normal)
        indirect_ray = Ray(hit.point + hit.normal * EPSILON, random_dir)
        indirect = path_trace(scene, indirect_ray, depth - 1)

        # BRDF evaluation
        brdf = hit.material.evaluate_brdf(ray.direction, random_dir, hit.normal)
        cos_theta = max(0, dot(hit.normal, random_dir))

        return direct + 2.0 * brdf * indirect * cos_theta

    return direct
</code></pre>
<h3 id="real-time-ray-tracing"><a class="header" href="#real-time-ray-tracing">Real-Time Ray Tracing</a></h3>
<p>Modern GPUs (NVIDIA RTX, AMD RDNA 2) support hardware-accelerated ray tracing.</p>
<h4 id="directx-raytracing-dxr"><a class="header" href="#directx-raytracing-dxr">DirectX Raytracing (DXR)</a></h4>
<pre><code class="language-hlsl">[shader("raygeneration")]
void RayGen() {
    uint2 launchIndex = DispatchRaysIndex().xy;

    RayDesc ray;
    ray.Origin = cameraPos;
    ray.Direction = calculateRayDirection(launchIndex);
    ray.TMin = 0.001;
    ray.TMax = 10000.0;

    RayPayload payload;
    TraceRay(scene, RAY_FLAG_NONE, 0xFF, 0, 0, 0, ray, payload);

    output[launchIndex] = payload.color;
}

[shader("closesthit")]
void ClosestHit(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attr) {
    payload.color = shade(attr);
}
</code></pre>
<hr>
<h2 id="gpu-architecture"><a class="header" href="#gpu-architecture">GPU Architecture</a></h2>
<h3 id="gpu-vs-cpu"><a class="header" href="#gpu-vs-cpu">GPU vs CPU</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>CPU</th><th>GPU</th></tr>
</thead>
<tbody>
<tr><td>Cores</td><td>Few (4-64)</td><td>Thousands</td></tr>
<tr><td>Clock Speed</td><td>High (3-5 GHz)</td><td>Lower (1-2 GHz)</td></tr>
<tr><td>Design</td><td>Latency optimized</td><td>Throughput optimized</td></tr>
<tr><td>Cache</td><td>Large</td><td>Small per core</td></tr>
<tr><td>Best For</td><td>Serial tasks</td><td>Parallel tasks</td></tr>
</tbody>
</table>
</div>
<h3 id="gpu-pipeline"><a class="header" href="#gpu-pipeline">GPU Pipeline</a></h3>
<pre><code>Application (CPU)
    ↓
Command Processor (GPU)
    ↓
Vertex Fetch
    ↓
Vertex Shader (Programmable)
    ↓
Tessellation (Optional)
    ↓
Geometry Shader (Optional)
    ↓
Rasterizer (Fixed)
    ↓
Pixel/Fragment Shader (Programmable)
    ↓
ROP (Render Output Unit)
    ↓
Frame Buffer
</code></pre>
<h3 id="simd-and-warps"><a class="header" href="#simd-and-warps">SIMD and Warps</a></h3>
<p><strong>SIMD</strong> (Single Instruction, Multiple Data):</p>
<ul>
<li>Same instruction executed on multiple data simultaneously</li>
<li>GPU cores execute in groups (warps/wavefronts)</li>
<li>Warp size: 32 (NVIDIA), 64 (AMD)</li>
</ul>
<p><strong>Divergence:</strong></p>
<pre><code class="language-glsl">// Bad: causes thread divergence
if (threadID % 2 == 0) {
    // Half the warp executes this
    result = expensiveOperation1();
} else {
    // Other half executes this
    result = expensiveOperation2();
}
// Both paths must be executed, other threads idle

// Better: avoid divergence
result = mix(expensiveOperation1(), expensiveOperation2(), threadID % 2);
</code></pre>
<h3 id="memory-hierarchy"><a class="header" href="#memory-hierarchy">Memory Hierarchy</a></h3>
<ol>
<li><strong>Registers</strong>: Fastest, per-thread, very limited</li>
<li><strong>Shared/Local Memory</strong>: Fast, shared within workgroup</li>
<li><strong>Constant Memory</strong>: Read-only, cached</li>
<li><strong>Texture Memory</strong>: Optimized for 2D spatial access</li>
<li><strong>Global Memory</strong>: Slowest, largest, accessible by all</li>
</ol>
<h3 id="compute-shaders"><a class="header" href="#compute-shaders">Compute Shaders</a></h3>
<p>General-purpose GPU computing within graphics pipeline.</p>
<pre><code class="language-glsl">#version 430

layout (local_size_x = 16, local_size_y = 16) in;
layout (rgba32f, binding = 0) uniform image2D imgOutput;

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

    // Perform computation
    vec4 color = computePixelColor(pixelCoords);

    imageStore(imgOutput, pixelCoords, color);
}
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Particle systems</li>
<li>Post-processing effects</li>
<li>Physics simulation</li>
<li>Image processing</li>
<li>Procedural generation</li>
</ul>
<hr>
<h2 id="modern-graphics-techniques"><a class="header" href="#modern-graphics-techniques">Modern Graphics Techniques</a></h2>
<h3 id="temporal-anti-aliasing-taa"><a class="header" href="#temporal-anti-aliasing-taa">Temporal Anti-Aliasing (TAA)</a></h3>
<p>Combines current and previous frames to reduce aliasing.</p>
<pre><code class="language-glsl">vec4 TAA(vec2 uv, vec4 currentColor, sampler2D historyTexture) {
    // Reproject to previous frame
    vec2 velocity = texture(velocityBuffer, uv).xy;
    vec2 prevUV = uv - velocity;

    // Sample history
    vec4 historyColor = texture(historyTexture, prevUV);

    // Neighborhood clamping to reduce ghosting
    vec4 nearColor0 = textureOffset(currentTexture, uv, ivec2(1, 0));
    vec4 nearColor1 = textureOffset(currentTexture, uv, ivec2(-1, 0));
    vec4 nearColor2 = textureOffset(currentTexture, uv, ivec2(0, 1));
    vec4 nearColor3 = textureOffset(currentTexture, uv, ivec2(0, -1));

    vec4 boxMin = min(currentColor, min(min(nearColor0, nearColor1), min(nearColor2, nearColor3)));
    vec4 boxMax = max(currentColor, max(max(nearColor0, nearColor1), max(nearColor2, nearColor3)));

    historyColor = clamp(historyColor, boxMin, boxMax);

    // Blend
    float blendFactor = 0.1;
    return mix(historyColor, currentColor, blendFactor);
}
</code></pre>
<h3 id="high-dynamic-range-hdr"><a class="header" href="#high-dynamic-range-hdr">High Dynamic Range (HDR)</a></h3>
<p>Represent wider range of luminance values.</p>
<pre><code class="language-glsl">// Tone mapping (Reinhard)
vec3 reinhard(vec3 hdrColor) {
    return hdrColor / (hdrColor + vec3(1.0));
}

// Tone mapping (ACES Filmic)
vec3 acesFilmic(vec3 x) {
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

// Exposure adjustment
vec3 exposureToneMapping(vec3 hdrColor, float exposure) {
    vec3 exposed = hdrColor * exposure;
    return acesFilmic(exposed);
}
</code></pre>
<h3 id="bloom"><a class="header" href="#bloom">Bloom</a></h3>
<p>Glow effect for bright areas.</p>
<pre><code class="language-glsl">// 1. Extract bright areas
vec3 extractBright(vec3 color, float threshold) {
    float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722));
    return brightness &gt; threshold ? color : vec3(0.0);
}

// 2. Gaussian blur (separable)
vec3 gaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {
    vec3 result = vec3(0.0);
    float weights[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

    result += texture(tex, uv).rgb * weights[0];
    for(int i = 1; i &lt; 5; i++) {
        result += texture(tex, uv + direction * i).rgb * weights[i];
        result += texture(tex, uv - direction * i).rgb * weights[i];
    }
    return result;
}

// 3. Combine with original
vec3 finalColor = originalColor + bloomColor * bloomIntensity;
</code></pre>
<h3 id="level-of-detail-lod"><a class="header" href="#level-of-detail-lod">Level of Detail (LOD)</a></h3>
<p>Render different detail levels based on distance/importance.</p>
<pre><code class="language-python">class LODMesh:
    def __init__(self):
        self.lods = [
            (1000.0, high_poly_mesh),    # &lt; 1000 units
            (5000.0, medium_poly_mesh),  # &lt; 5000 units
            (float('inf'), low_poly_mesh) # &gt; 5000 units
        ]

    def get_mesh(self, distance):
        for threshold, mesh in self.lods:
            if distance &lt; threshold:
                return mesh
        return self.lods[-1][1]
</code></pre>
<h3 id="frustum-culling"><a class="header" href="#frustum-culling">Frustum Culling</a></h3>
<p>Don’t render objects outside camera view.</p>
<pre><code class="language-python">def frustum_cull(camera, objects):
    planes = extract_frustum_planes(camera.view_projection)
    visible = []

    for obj in objects:
        bbox = obj.bounding_box
        if is_bbox_in_frustum(bbox, planes):
            visible.append(obj)

    return visible

def is_bbox_in_frustum(bbox, planes):
    for plane in planes:
        # Test if all corners are on negative side of plane
        if all(plane.distance(corner) &lt; 0 for corner in bbox.corners):
            return False  # Completely outside
    return True  # At least partially inside
</code></pre>
<h3 id="occlusion-culling"><a class="header" href="#occlusion-culling">Occlusion Culling</a></h3>
<p>Don’t render objects hidden behind others.</p>
<pre><code class="language-glsl">// Hierarchical Z-buffer approach
// 1. Render depth of occluders to mip-mapped depth buffer
// 2. Test object bounds against appropriate mip level

bool isOccluded(vec3 bboxMin, vec3 bboxMax, sampler2D hierZ) {
    // Project bounding box to screen space
    vec4 screenMin = projection * view * vec4(bboxMin, 1.0);
    vec4 screenMax = projection * view * vec4(bboxMax, 1.0);

    screenMin.xyz /= screenMin.w;
    screenMax.xyz /= screenMax.w;

    // Sample appropriate mip level
    float width = screenMax.x - screenMin.x;
    float level = log2(width * screenWidth);

    float occluderDepth = textureLod(hierZ, screenMin.xy, level).r;

    return screenMin.z &gt; occluderDepth;
}
</code></pre>
<h3 id="tessellation"><a class="header" href="#tessellation">Tessellation</a></h3>
<p>Dynamically subdivide geometry on GPU.</p>
<pre><code class="language-glsl">// Tessellation Control Shader
layout (vertices = 3) out;

void main() {
    // Pass through vertex
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;

    // Set tessellation levels based on distance
    float distance = length(cameraPos - gl_in[gl_InvocationID].gl_Position.xyz);
    float tessLevel = mix(64.0, 1.0, clamp(distance / 100.0, 0.0, 1.0));

    gl_TessLevelOuter[gl_InvocationID] = tessLevel;
    gl_TessLevelInner[0] = tessLevel;
}

// Tessellation Evaluation Shader
layout (triangles, equal_spacing, ccw) in;

void main() {
    // Barycentric interpolation
    vec3 p0 = gl_TessCoord.x * gl_in[0].gl_Position.xyz;
    vec3 p1 = gl_TessCoord.y * gl_in[1].gl_Position.xyz;
    vec3 p2 = gl_TessCoord.z * gl_in[2].gl_Position.xyz;
    vec3 pos = p0 + p1 + p2;

    // Displacement mapping
    float height = texture(heightMap, uv).r;
    pos += normal * height * displacementScale;

    gl_Position = projection * view * vec4(pos, 1.0);
}
</code></pre>
<h3 id="virtual-texturing-mega-textures"><a class="header" href="#virtual-texturing-mega-textures">Virtual Texturing (Mega Textures)</a></h3>
<p>Stream texture data on demand.</p>
<ul>
<li>Divide large texture into tiles</li>
<li>Load only visible tiles</li>
<li>Indirection texture maps UV to tile location</li>
<li>Used in large open-world games</li>
</ul>
<h3 id="clustered-shading"><a class="header" href="#clustered-shading">Clustered Shading</a></h3>
<p>Handle many lights efficiently.</p>
<pre><code class="language-glsl">// Divide screen into tiles (clusters)
// Assign lights to clusters
// Each pixel only processes lights in its cluster

ivec3 getCluster(vec3 fragPos) {
    ivec2 tile = ivec2(gl_FragCoord.xy / TILE_SIZE);
    int zSlice = int(log(fragPos.z) * zSlices / log(farPlane / nearPlane));
    return ivec3(tile, zSlice);
}

void main() {
    ivec3 cluster = getCluster(FragPos);

    // Get light list for this cluster
    int lightCount = clusterLightCounts[cluster];
    int lightOffset = clusterLightOffsets[cluster];

    vec3 lighting = vec3(0.0);
    for (int i = 0; i &lt; lightCount; i++) {
        int lightIndex = clusterLightIndices[lightOffset + i];
        lighting += calculateLight(lights[lightIndex]);
    }

    FragColor = vec4(lighting * albedo, 1.0);
}
</code></pre>
<hr>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Computer graphics is a vast and evolving field combining mathematics, physics, computer science, and art. Modern real-time graphics leverage:</p>
<ul>
<li><strong>Programmable pipelines</strong> for flexibility</li>
<li><strong>Physically-based rendering</strong> for realism</li>
<li><strong>Advanced algorithms</strong> for performance</li>
<li><strong>Parallel computing</strong> via GPUs</li>
<li><strong>Machine learning</strong> for upscaling (DLSS, FSR)</li>
</ul>
<h3 id="further-topics"><a class="header" href="#further-topics">Further Topics</a></h3>
<ul>
<li><strong>Volumetric Rendering</strong>: Clouds, fog, subsurface scattering</li>
<li><strong>Procedural Generation</strong>: Noise functions, fractals</li>
<li><strong>Non-Photorealistic Rendering</strong>: Toon shading, sketching</li>
<li><strong>Virtual Reality</strong>: Stereoscopic rendering, foveated rendering</li>
<li><strong>Ray Marching</strong>: Distance fields, fractals</li>
<li><strong>Neural Rendering</strong>: NeRF, neural textures</li>
</ul>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li><strong>Books</strong>: “Real-Time Rendering”, “Physically Based Rendering”, “Graphics Gems”</li>
<li><strong>APIs</strong>: OpenGL, Vulkan, DirectX, Metal, WebGL</li>
<li><strong>Tools</strong>: Blender, Unity, Unreal Engine, Godot</li>
<li><strong>Websites</strong>: Learn OpenGL, Scratchapixel, ShaderToy</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../misc/operating_systems.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../misc/uboot.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../misc/operating_systems.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../misc/uboot.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
