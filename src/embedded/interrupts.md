# Interrupts

## Overview

Interrupts are signals that temporarily halt the normal execution of a program, allowing the system to respond to important events. They are a crucial mechanism in embedded systems and computer architecture, enabling efficient event handling, real-time processing, and hardware interaction without constant polling.

## Types of Interrupts

### Hardware Interrupts

Generated by hardware peripherals (e.g., UART, timers, GPIO, SPI, I2C) to signal that they require attention from the CPU. These interrupts can occur asynchronously and are typically prioritized to ensure critical tasks are handled promptly.

**Categories:**
- **External Interrupts**: Triggered by external pins (GPIO state changes, button presses)
- **Peripheral Interrupts**: Generated by on-chip peripherals (UART data ready, timer overflow, ADC conversion complete)
- **System Interrupts**: Critical system events (watchdog timeout, clock failure, brown-out detection)

### Software Interrupts

Triggered by software instructions, such as:
- **System Calls**: Programs requesting OS services
- **Exceptions**: Division by zero, invalid memory access, undefined instructions
- **Debug Events**: Breakpoints, single-step execution

### Timer Interrupts

Generated by hardware timers at regular intervals for:
- Task scheduling in RTOS
- Time-keeping and timestamps
- PWM generation
- Periodic sampling and control loops

## ARM Cortex-M Interrupt Architecture

### NVIC (Nested Vectored Interrupt Controller)

The NVIC is the interrupt controller in ARM Cortex-M processors, providing:
- Support for up to 240 external interrupts (MCU-dependent)
- Hardware priority management
- Nested interrupt support
- Low-latency interrupt entry/exit
- Automatic state saving and restoration

**Key Features:**
- **Priority Levels**: Configurable priority for each interrupt (typically 3-8 bits)
- **Priority Grouping**: Splits priority into preemption priority and sub-priority
- **Interrupt Masking**: PRIMASK, FAULTMASK, BASEPRI registers for selective masking
- **Tail Chaining**: Optimized back-to-back interrupt handling without state restore

### Vector Table

The vector table is a data structure at the beginning of memory (typically 0x00000000 or relocated) containing:
- Initial stack pointer value (first entry)
- Reset handler address
- Exception handler addresses (NMI, HardFault, etc.)
- IRQ handler addresses for all peripheral interrupts

**Example Vector Table Structure (Cortex-M):**
```c
__attribute__ ((section(".isr_vector")))
const uint32_t vector_table[] = {
    (uint32_t)&_estack,           // 0: Initial Stack Pointer
    (uint32_t)Reset_Handler,      // 1: Reset Handler
    (uint32_t)NMI_Handler,        // 2: NMI Handler
    (uint32_t)HardFault_Handler,  // 3: Hard Fault Handler
    (uint32_t)MemManage_Handler,  // 4: MPU Fault Handler
    (uint32_t)BusFault_Handler,   // 5: Bus Fault Handler
    (uint32_t)UsageFault_Handler, // 6: Usage Fault Handler
    0,                            // 7-10: Reserved
    0,
    0,
    0,
    (uint32_t)SVC_Handler,        // 11: SVCall Handler
    (uint32_t)DebugMon_Handler,   // 12: Debug Monitor
    0,                            // 13: Reserved
    (uint32_t)PendSV_Handler,     // 14: PendSV Handler
    (uint32_t)SysTick_Handler,    // 15: SysTick Handler
    // External Interrupts
    (uint32_t)WWDG_IRQHandler,    // 16: Window Watchdog
    (uint32_t)EXTI0_IRQHandler,   // 17: EXTI Line 0
    // ... more peripheral IRQs
};
```

### Interrupt Priority Configuration

**Priority Grouping:**
```c
// Set priority grouping (4 bits preemption, 0 bits sub-priority)
NVIC_SetPriorityGrouping(3);

// Configure interrupt priority
// Priority 2, sub-priority 0
NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(3, 2, 0));

// Enable interrupt
NVIC_EnableIRQ(USART1_IRQn);
```

**Priority Levels:**
- Lower numerical value = higher priority
- Priority 0 is the highest (most urgent)
- Interrupts with higher preemption priority can preempt lower priority handlers
- Sub-priority determines execution order when multiple interrupts are pending with same preemption priority

### Exception States (Cortex-M)

1. **Inactive**: Exception not active or pending
2. **Pending**: Exception waiting to be serviced
3. **Active**: Exception handler is executing
4. **Active and Pending**: Handler executing, and another instance is pending

## AVR Interrupts

### AVR Interrupt Architecture

AVR microcontrollers use a simpler interrupt system compared to ARM Cortex-M:
- **Single Priority Level**: All interrupts have the same priority (no nested interrupts by default)
- **Fixed Vector Table**: Located at the beginning of program memory
- **Automatic Global Interrupt Disable**: When an interrupt fires, global interrupts are automatically disabled
- **Manual Re-enable**: Must use `sei()` in ISR for nested interrupts

### AVR Vector Table

Each interrupt has a fixed vector address at the beginning of flash memory:

```c
// ATmega328P example vectors
ISR(RESET_vect) { }          // 0x0000: Reset
ISR(INT0_vect) { }           // 0x0002: External Interrupt 0
ISR(INT1_vect) { }           // 0x0004: External Interrupt 1
ISR(PCINT0_vect) { }         // 0x0006: Pin Change Interrupt 0
ISR(PCINT1_vect) { }         // 0x0008: Pin Change Interrupt 1
ISR(PCINT2_vect) { }         // 0x000A: Pin Change Interrupt 2
ISR(TIMER2_COMPA_vect) { }   // 0x000C: Timer2 Compare Match A
ISR(TIMER2_COMPB_vect) { }   // 0x000E: Timer2 Compare Match B
ISR(TIMER2_OVF_vect) { }     // 0x0010: Timer2 Overflow
ISR(TIMER1_CAPT_vect) { }    // 0x0012: Timer1 Capture
ISR(USART_RX_vect) { }       // etc.
```

### AVR Interrupt Configuration

**Enabling Interrupts:**
```c
#include <avr/interrupt.h>

// Enable global interrupts
sei();

// Disable global interrupts
cli();

// Enable specific interrupt (e.g., Timer0 overflow)
TIMSK0 |= (1 << TOIE0);

// Enable external interrupt INT0
EIMSK |= (1 << INT0);

// Configure INT0 to trigger on falling edge
EICRA |= (1 << ISC01);
EICRA &= ~(1 << ISC00);
```

**AVR ISR Definition:**
```c
// Timer0 overflow interrupt
ISR(TIMER0_OVF_vect) {
    // Handler code
    TCNT0 = 0;  // Reset counter
    // ISR automatically clears global interrupt flag on entry
    // and restores it on exit (via RETI instruction)
}

// ISR with nested interrupts enabled
ISR(USART_RX_vect) {
    uint8_t data = UDR0;  // Read data

    // Re-enable interrupts for nesting (use with caution)
    sei();

    // Process data
    process_data(data);

    // cli() not needed - RETI handles this
}
```

### AVR Interrupt Priority

AVR interrupts are serviced based on **vector table position**:
- Lower vector addresses have higher priority
- If multiple interrupts are pending, the one with the lowest vector address executes first
- No hardware-based preemption (unless manually enabled with `sei()` in ISR)

## ISR Best Practices

### Keep ISRs Short and Fast

**Why:**
- Long ISRs block other interrupts
- Increase interrupt latency
- Can cause system instability

**Guidelines:**
```c
// BAD: Complex processing in ISR
ISR(UART_RX_vect) {
    char data = UDR0;
    process_protocol(data);      // Complex function
    update_display();            // Slow operation
    send_response();             // I/O operation
}

// GOOD: Minimal processing, defer work
volatile uint8_t rx_buffer[64];
volatile uint8_t rx_head = 0;
volatile bool data_ready = false;

ISR(UART_RX_vect) {
    rx_buffer[rx_head++] = UDR0;
    if (rx_head >= 64) rx_head = 0;
    data_ready = true;            // Set flag for main loop
}

// Main loop handles processing
void main_loop(void) {
    if (data_ready) {
        cli();
        process_buffer(rx_buffer);
        data_ready = false;
        sei();
    }
}
```

### Volatile Variables

Variables shared between ISR and main code **must** be declared `volatile`:

```c
// Tells compiler this variable can change unexpectedly
volatile uint32_t tick_count = 0;
volatile bool button_pressed = false;

ISR(TIMER0_OVF_vect) {
    tick_count++;
}

void delay_ms(uint32_t ms) {
    uint32_t start = tick_count;  // Read volatile variable
    while ((tick_count - start) < ms) {
        // Compiler won't optimize this loop away
    }
}
```

### Atomic Access for Multi-Byte Variables

Reading/writing multi-byte variables is not atomic on 8-bit and 16-bit MCUs:

```c
volatile uint32_t counter = 0;

// BAD: Non-atomic read (can be interrupted mid-read)
void bad_read(void) {
    uint32_t local = counter;  // 4 separate byte reads on AVR
}

// GOOD: Atomic read
uint32_t atomic_read_counter(void) {
    uint32_t temp;
    cli();                // Disable interrupts
    temp = counter;       // Safe read
    sei();                // Re-enable interrupts
    return temp;
}

// Alternative for ARM Cortex-M: Use LDREX/STREX or disable interrupts
uint32_t safe_increment(void) {
    __disable_irq();
    uint32_t temp = counter++;
    __enable_irq();
    return temp;
}
```

### Re-entrancy

ISRs should generally be **non-reentrant** unless carefully designed:

```c
// NOT re-entrant (static state)
void bad_isr_function(void) {
    static int count = 0;  // Shared state
    count++;
    // If this function is called from multiple ISRs, count can be corrupted
}

// Re-entrant (no static state, uses only parameters and local variables)
void good_isr_function(int* buffer, int index, int value) {
    buffer[index] = value;  // Safe if buffer, index, value are on stack
}
```

### Avoid Dynamic Memory Allocation

Never use `malloc()`, `free()`, or `new`/`delete` in ISRs:
- Not re-entrant
- Can cause heap corruption
- Unpredictable execution time
- May use interrupts internally

## Critical Sections

### What is a Critical Section?

A critical section is code that accesses shared resources and must not be interrupted:

```c
volatile uint16_t adc_sum = 0;
volatile uint8_t adc_count = 0;

// Critical section: updating two related variables
void add_adc_sample(uint16_t sample) {
    cli();                    // Enter critical section
    adc_sum += sample;
    adc_count++;
    sei();                    // Exit critical section
}
```

### Methods for Protecting Critical Sections

**AVR - Global Interrupt Disable:**
```c
cli();
// Critical code
sei();
```

**ARM Cortex-M - Multiple Methods:**
```c
// Method 1: Disable all interrupts
__disable_irq();
// Critical code
__enable_irq();

// Method 2: Raise execution priority (CMSIS)
uint32_t primask = __get_PRIMASK();
__disable_irq();
// Critical code
__set_PRIMASK(primask);

// Method 3: Use BASEPRI to mask interrupts below certain priority
uint32_t basepri = __get_BASEPRI();
__set_BASEPRI(64);  // Mask interrupts with priority >= 64
// Critical code
__set_BASEPRI(basepri);
```

**Nestable Critical Sections:**
```c
static volatile uint8_t critical_nesting = 0;

void enter_critical(void) {
    cli();
    critical_nesting++;
}

void exit_critical(void) {
    critical_nesting--;
    if (critical_nesting == 0) {
        sei();
    }
}
```

### Race Conditions

Example of a race condition:

```c
volatile bool data_ready = false;
volatile uint8_t data_buffer[10];
volatile uint8_t data_length = 0;

ISR(UART_RX_vect) {
    data_buffer[data_length++] = UDR0;
    if (data_length >= 10) {
        data_ready = true;
        data_length = 0;
    }
}

// BAD: Race condition
void process_data(void) {
    if (data_ready) {
        // ISR could fire here and modify data_buffer!
        for (int i = 0; i < 10; i++) {
            do_something(data_buffer[i]);  // Possible corruption
        }
        data_ready = false;
    }
}

// GOOD: Protected with critical section
void process_data_safe(void) {
    uint8_t local_buffer[10];
    bool ready;

    cli();
    ready = data_ready;
    if (ready) {
        memcpy(local_buffer, (void*)data_buffer, 10);
        data_ready = false;
    }
    sei();

    if (ready) {
        for (int i = 0; i < 10; i++) {
            do_something(local_buffer[i]);  // Safe
        }
    }
}
```

## Interrupt Latency

### Definition

**Interrupt Latency**: Time from interrupt assertion to first instruction of ISR executing.

**Components:**
1. **Hardware latency**: Time for CPU to recognize interrupt
2. **Context saving**: Pushing registers to stack
3. **Vector fetch**: Reading ISR address from vector table
4. **Pipeline flush**: Clearing instruction pipeline

### Typical Latency Values

- **AVR**: 4-5 clock cycles (hardware) + ISR prologue
- **ARM Cortex-M0**: 15 cycles (includes stacking)
- **ARM Cortex-M3/M4**: 12 cycles (with tail-chaining: 6 cycles)
- **ARM Cortex-M7**: 12 cycles (can be reduced to 6 with optimization)

### Factors Affecting Latency

1. **Interrupt Priority**: Lower priority interrupts wait for higher priority ones
2. **Disabled Interrupts**: Critical sections delay recognition
3. **Current ISR Execution**: Lower priority interrupts wait for higher priority ISRs
4. **Flash Wait States**: Slow memory access increases latency
5. **Bus Contention**: DMA or other masters accessing memory

### Reducing Interrupt Latency

**ARM Cortex-M Optimization:**
```c
// Enable interrupt tail-chaining (automatic in NVIC)
// Reduces back-to-back ISR latency from 12 to 6 cycles

// Keep vector table in fast memory (RAM or tightly-coupled memory)
__attribute__((section(".ram_vector"))) uint32_t ram_vectors[256];

// Use fast interrupt handlers for critical interrupts
__attribute__((interrupt("IRQ"))) void fast_handler(void);
```

**AVR Optimization:**
```c
// Use SIGNAL instead of ISR for critical interrupts (no nested interrupt support)
SIGNAL(TIMER0_OVF_vect) {
    // Fastest possible handler - no interrupt nesting support
    PORTB ^= (1 << PB0);  // Toggle pin
}

// Place critical ISR code in specific section for faster flash access
__attribute__((section(".lowtext"))) void critical_function(void);
```

**General Tips:**
- Use higher priority for time-critical interrupts
- Minimize critical section duration
- Use tail-chaining (ARM Cortex-M)
- Keep ISRs in fast memory
- Reduce ISR complexity

## Hardware Interrupt Characteristics

### Edge vs. Level Triggered

**Edge-Triggered:**
- Interrupt fires on rising/falling edge of signal
- Must be cleared by reading status register or peripheral action
- Can miss events if edges occur too quickly
- Typically used for event counting, button presses

```c
// STM32 - Configure GPIO for falling edge interrupt
EXTI->FTSR |= EXTI_FTSR_TR0;   // Falling edge trigger
EXTI->RTSR &= ~EXTI_RTSR_TR0;  // Disable rising edge

// AVR - Configure INT0 for falling edge
EICRA |= (1 << ISC01);
EICRA &= ~(1 << ISC00);
```

**Level-Triggered:**
- Interrupt active while signal is at specific level (high or low)
- Interrupt repeats if condition not cleared
- Won't miss events but can cause interrupt storms
- Used for status flags, continuous conditions

```c
// Some peripherals use level-triggered interrupts
// Must clear the condition (e.g., read data register, clear flag)

ISR(USART_RX_vect) {
    uint8_t data = UDR0;  // Reading UDR0 clears the interrupt flag
    // If not cleared, interrupt will immediately fire again
}
```

### Interrupt Flags and Pending Registers

**Interrupt Flag Register (IFR):**
- Indicates which interrupt source triggered
- Must be cleared (usually by writing 1 to the bit)

**Pending Register:**
- Shows interrupts waiting to be serviced

```c
// ARM Cortex-M - Check pending interrupts
if (NVIC_GetPendingIRQ(USART1_IRQn)) {
    // USART1 interrupt is pending
}

// Clear pending interrupt
NVIC_ClearPendingIRQ(USART1_IRQn);

// AVR - Check and clear interrupt flags
if (TIFR0 & (1 << TOV0)) {  // Timer0 overflow flag set
    TIFR0 |= (1 << TOV0);   // Clear by writing 1
}
```

**Common Mistake - Flag Clearing:**
```c
// BAD: Reading flag doesn't clear it (on most MCUs)
ISR(TIMER_COMP_vect) {
    if (TIM_SR & TIM_FLAG_CC1) {
        // Flag still set, interrupt will fire again immediately!
    }
}

// GOOD: Explicitly clear the flag
ISR(TIMER_COMP_vect) {
    TIM_SR = ~TIM_FLAG_CC1;  // Clear flag (write 0 on some MCUs)
    // or
    TIM_SR |= TIM_FLAG_CC1;  // Clear flag (write 1 on others - check datasheet)
}
```

## RTOS Considerations

### Interrupt-Safe API Calls

Most RTOS functions are **not** safe to call from ISRs. Use special ISR-safe versions:

**FreeRTOS Example:**
```c
// Main task code
void task_function(void* param) {
    uint32_t value;
    xQueueReceive(queue, &value, portMAX_DELAY);
}

// ISR code - use FromISR variants
void USART1_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    uint32_t data = USART1->DR;

    // Use ISR-safe version
    xQueueSendFromISR(queue, &data, &xHigherPriorityTaskWoken);

    // Request context switch if higher priority task woken
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

**Common ISR-Safe Functions:**
- `xQueueSendFromISR()` / `xQueueReceiveFromISR()`
- `xSemaphoreGiveFromISR()` / `xSemaphoreTakeFromISR()`
- `xEventGroupSetBitsFromISR()`
- `vTaskNotifyGiveFromISR()`

### Deferred Interrupt Processing

Pattern: Do minimal work in ISR, defer complex processing to task

**Method 1: Binary Semaphore**
```c
SemaphoreHandle_t xDataSemaphore;

void data_processing_task(void* param) {
    while (1) {
        xSemaphoreTake(xDataSemaphore, portMAX_DELAY);
        // Do complex processing here
        process_sensor_data();
    }
}

void SENSOR_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    // Quick: read sensor, store in buffer
    read_sensor_to_buffer();

    // Wake up processing task
    xSemaphoreGiveFromISR(xDataSemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

**Method 2: Task Notification (More Efficient)**
```c
TaskHandle_t xProcessingTask;

void data_processing_task(void* param) {
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        process_sensor_data();
    }
}

void SENSOR_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    read_sensor_to_buffer();
    vTaskNotifyGiveFromISR(xProcessingTask, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

**Method 3: Message Queue**
```c
QueueHandle_t xEventQueue;

void event_handler_task(void* param) {
    event_t event;
    while (1) {
        xQueueReceive(xEventQueue, &event, portMAX_DELAY);
        handle_event(&event);
    }
}

void BUTTON_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    event_t event = { .type = BUTTON_PRESSED, .timestamp = get_time() };
    xQueueSendFromISR(xEventQueue, &event, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

### Interrupt Priority vs RTOS Priority

**Critical Rule**: RTOS API calls from ISR are only safe if interrupt priority is **lower** than `configMAX_SYSCALL_INTERRUPT_PRIORITY`.

```c
// FreeRTOS configuration
#define configMAX_SYSCALL_INTERRUPT_PRIORITY 5

// Interrupt priorities (ARM Cortex-M, lower number = higher priority)
NVIC_SetPriority(TIMER_IRQn, 3);   // Priority 3 - CANNOT call RTOS APIs (too high)
NVIC_SetPriority(USART_IRQn, 5);   // Priority 5 - Can call RTOS FromISR APIs
NVIC_SetPriority(SPI_IRQn, 10);    // Priority 10 - Can call RTOS FromISR APIs
```

## Practical Examples

### STM32 (ARM Cortex-M) External Interrupt Example

```c
#include "stm32f4xx.h"

void EXTI0_Config(void) {
    // Enable GPIOA clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // Configure PA0 as input
    GPIOA->MODER &= ~GPIO_MODER_MODER0;

    // Enable SYSCFG clock
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    // Connect EXTI0 to PA0
    SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PA;

    // Enable rising edge trigger
    EXTI->RTSR |= EXTI_RTSR_TR0;

    // Unmask EXTI0
    EXTI->IMR |= EXTI_IMR_MR0;

    // Set priority and enable in NVIC
    NVIC_SetPriority(EXTI0_IRQn, 2);
    NVIC_EnableIRQ(EXTI0_IRQn);
}

void EXTI0_IRQHandler(void) {
    // Check if EXTI0 triggered
    if (EXTI->PR & EXTI_PR_PR0) {
        // Clear pending bit by writing 1
        EXTI->PR = EXTI_PR_PR0;

        // Handle interrupt
        toggle_led();
    }
}
```

### STM32 Timer Interrupt Example

```c
void TIM2_Config(void) {
    // Enable TIM2 clock
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    // Configure timer for 1ms interrupt @ 84MHz
    TIM2->PSC = 84 - 1;        // Prescaler: 84MHz / 84 = 1MHz
    TIM2->ARR = 1000 - 1;      // Auto-reload: 1MHz / 1000 = 1kHz (1ms)

    // Enable update interrupt
    TIM2->DIER |= TIM_DIER_UIE;

    // Enable TIM2 global interrupt in NVIC
    NVIC_SetPriority(TIM2_IRQn, 3);
    NVIC_EnableIRQ(TIM2_IRQn);

    // Start timer
    TIM2->CR1 |= TIM_CR1_CEN;
}

volatile uint32_t system_ticks = 0;

void TIM2_IRQHandler(void) {
    // Check update interrupt flag
    if (TIM2->SR & TIM_SR_UIF) {
        // Clear flag
        TIM2->SR &= ~TIM_SR_UIF;

        // Increment tick counter
        system_ticks++;
    }
}
```

### AVR Timer Interrupt Example

```c
#include <avr/io.h>
#include <avr/interrupt.h>

void timer0_init(void) {
    // Set timer0 to CTC mode
    TCCR0A |= (1 << WGM01);

    // Set compare value for 1ms @ 16MHz with prescaler 64
    // 16MHz / 64 / 250 = 1kHz (1ms)
    OCR0A = 250 - 1;

    // Enable compare match interrupt
    TIMSK0 |= (1 << OCIE0A);

    // Start timer with prescaler 64
    TCCR0B |= (1 << CS01) | (1 << CS00);

    // Enable global interrupts
    sei();
}

volatile uint32_t millis_count = 0;

ISR(TIMER0_COMPA_vect) {
    millis_count++;
}

uint32_t millis(void) {
    uint32_t m;
    cli();
    m = millis_count;
    sei();
    return m;
}
```

### AVR External Interrupt Example

```c
#include <avr/io.h>
#include <avr/interrupt.h>

void ext_int0_init(void) {
    // Configure INT0 pin (PD2) as input with pull-up
    DDRD &= ~(1 << PD2);
    PORTD |= (1 << PD2);

    // Trigger on falling edge
    EICRA |= (1 << ISC01);
    EICRA &= ~(1 << ISC00);

    // Enable INT0
    EIMSK |= (1 << INT0);

    // Enable global interrupts
    sei();
}

volatile uint8_t button_pressed = 0;

ISR(INT0_vect) {
    button_pressed = 1;
    // Debouncing should be handled in main loop or with timer
}
```

### Nordic nRF52 (ARM Cortex-M4) GPIOTE Example

```c
#include "nrf_gpio.h"
#include "nrf_gpiote.h"

void gpiote_init(void) {
    // Configure GPIO pin
    nrf_gpio_cfg_input(BUTTON_PIN, NRF_GPIO_PIN_PULLUP);

    // Configure GPIOTE channel 0 for button
    NRF_GPIOTE->CONFIG[0] = (GPIOTE_CONFIG_MODE_Event << GPIOTE_CONFIG_MODE_Pos) |
                            (BUTTON_PIN << GPIOTE_CONFIG_PSEL_Pos) |
                            (GPIOTE_CONFIG_POLARITY_HiToLo << GPIOTE_CONFIG_POLARITY_Pos);

    // Enable interrupt for channel 0
    NRF_GPIOTE->INTENSET = GPIOTE_INTENSET_IN0_Msk;

    // Enable GPIOTE interrupt in NVIC
    NVIC_SetPriority(GPIOTE_IRQn, 3);
    NVIC_EnableIRQ(GPIOTE_IRQn);
}

void GPIOTE_IRQHandler(void) {
    // Check if event on channel 0
    if (NRF_GPIOTE->EVENTS_IN[0]) {
        // Clear event
        NRF_GPIOTE->EVENTS_IN[0] = 0;

        // Handle button press
        handle_button_press();
    }
}
```

### Circular Buffer for Interrupt-Safe Data Transfer

```c
#define BUFFER_SIZE 128

typedef struct {
    volatile uint8_t buffer[BUFFER_SIZE];
    volatile uint16_t head;
    volatile uint16_t tail;
} circular_buffer_t;

circular_buffer_t rx_buffer = {0};

// Called from ISR
void buffer_put(circular_buffer_t* cb, uint8_t data) {
    uint16_t next_head = (cb->head + 1) % BUFFER_SIZE;

    // Check if buffer full
    if (next_head != cb->tail) {
        cb->buffer[cb->head] = data;
        cb->head = next_head;
    }
}

// Called from main code
bool buffer_get(circular_buffer_t* cb, uint8_t* data) {
    if (cb->head == cb->tail) {
        return false;  // Buffer empty
    }

    *data = cb->buffer[cb->tail];
    cb->tail = (cb->tail + 1) % BUFFER_SIZE;
    return true;
}

// UART RX ISR
ISR(USART_RX_vect) {
    uint8_t data = UDR0;
    buffer_put(&rx_buffer, data);
}

// Main loop
void main_loop(void) {
    uint8_t byte;
    while (buffer_get(&rx_buffer, &byte)) {
        process_byte(byte);
    }
}
```

## Common Pitfalls and Solutions

### Pitfall 1: Forgetting to Clear Interrupt Flags

```c
// BAD: Flag not cleared
ISR(ADC_vect) {
    uint16_t result = ADC;
    process_result(result);
    // Flag not cleared - ISR fires continuously!
}

// GOOD: Flag cleared (automatic for many peripherals on AVR)
// But explicit for others:
void TIM2_IRQHandler(void) {
    if (TIM2->SR & TIM_SR_UIF) {
        TIM2->SR &= ~TIM_SR_UIF;  // Clear flag explicitly
        handle_timer();
    }
}
```

### Pitfall 2: Non-Atomic Operations on Shared Variables

```c
// BAD: Non-atomic 16-bit increment on 8-bit AVR
volatile uint16_t counter = 0;

ISR(TIMER_vect) {
    counter++;  // Two instructions: low byte, then high byte
}

void main(void) {
    uint16_t local = counter;  // Can read inconsistent value!
}

// GOOD: Atomic access
uint16_t read_counter(void) {
    uint16_t temp;
    cli();
    temp = counter;
    sei();
    return temp;
}
```

### Pitfall 3: Function Calls in ISR Without Considering Side Effects

```c
// BAD: printf in ISR (slow, uses interrupts internally)
ISR(UART_RX_vect) {
    printf("Received: %c\n", UDR0);  // NEVER do this!
}

// GOOD: Set flag, process in main
volatile bool data_received = false;
volatile uint8_t received_byte;

ISR(UART_RX_vect) {
    received_byte = UDR0;
    data_received = true;
}
```

### Pitfall 4: Incorrect Interrupt Priority Configuration

```c
// BAD: Critical interrupt with low priority
NVIC_SetPriority(MOTOR_CONTROL_IRQn, 15);  // Lowest priority
NVIC_SetPriority(DEBUG_UART_IRQn, 0);      // Highest priority

// GOOD: Priority matches criticality
NVIC_SetPriority(MOTOR_CONTROL_IRQn, 2);   // High priority - time critical
NVIC_SetPriority(DEBUG_UART_IRQn, 10);     // Low priority - not critical
```

## Summary

Interrupts are essential for responsive embedded systems. Key takeaways:

1. **Keep ISRs short** - Defer complex processing to main loop or RTOS tasks
2. **Use `volatile`** - For all variables shared between ISR and main code
3. **Protect critical sections** - Use interrupt disable/enable or RTOS primitives
4. **Clear interrupt flags** - Always clear flags to prevent repeated interrupts
5. **Understand your architecture** - ARM Cortex-M has sophisticated NVIC; AVR is simpler but effective
6. **Configure priorities correctly** - Critical interrupts get higher priority
7. **Use RTOS-safe functions** - Always use `FromISR` variants in RTOS environments
8. **Test thoroughly** - Race conditions and timing bugs are hard to reproduce
