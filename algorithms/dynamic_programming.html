<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dynamic Programming - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-0298451c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-3ff3ea79.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Dynamic Programming (DP) is a powerful algorithmic paradigm that solves complex optimization problems by breaking them down into simpler overlapping subproblems. Instead of solving the same subproblem multiple times, DP stores the results of subproblems and reuses them, dramatically improving efficiency from exponential to polynomial time complexity.</p>
<p>DP is essential for solving optimization problems where you need to find the best solution among many possibilities, counting problems where you need to count all possible ways to do something, and decision-making problems with multiple stages.</p>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<h3 id="optimal-substructure"><a class="header" href="#optimal-substructure">Optimal Substructure</a></h3>
<p>A problem exhibits <strong>optimal substructure</strong> if an optimal solution can be constructed from optimal solutions of its subproblems. This is the foundation that allows DP to work.</p>
<p><strong>Example</strong>: In the shortest path problem, if the shortest path from A to C goes through B, then the path from A to B must also be the shortest path between those two points.</p>
<p><strong>How to identify</strong>:</p>
<ol>
<li>Try to express the solution in terms of solutions to smaller instances</li>
<li>Verify that combining optimal solutions to subproblems gives an optimal solution to the original problem</li>
<li>If greedy choices work, you might not need DP (use greedy algorithm instead)</li>
</ol>
<h3 id="overlapping-subproblems"><a class="header" href="#overlapping-subproblems">Overlapping Subproblems</a></h3>
<p>A problem has <strong>overlapping subproblems</strong> if the same subproblems are solved multiple times during the computation.</p>
<p><strong>Example</strong>: Computing Fibonacci(5) recursively computes Fibonacci(3) twice, Fibonacci(2) three times, and Fibonacci(1) five times.</p>
<p><strong>Key insight</strong>: Without DP, exponential time complexity. With DP, polynomial time complexity.</p>
<h2 id="dp-approaches"><a class="header" href="#dp-approaches">DP Approaches</a></h2>
<h3 id="1-memoization-top-down"><a class="header" href="#1-memoization-top-down">1. Memoization (Top-Down)</a></h3>
<p>Memoization uses recursion with caching. Start with the original problem and recursively solve subproblems, storing results in a cache (usually a hash map or array).</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Intuitive and easier to implement for complex problems</li>
<li>Only computes subproblems that are actually needed</li>
<li>Natural fit for problems with recursive structure</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Recursion overhead (stack space)</li>
<li>Potential stack overflow for deep recursion</li>
</ul>
<pre><code class="language-python">def fib_memo(n, memo=None):
    """Calculate nth Fibonacci number using memoization"""
    if memo is None:
        memo = {}

    if n in memo:
        return memo[n]

    # Base cases
    if n &lt;= 1:
        return n

    # Recursive case with memoization
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# Time: O(n), Space: O(n)
</code></pre>
<h3 id="2-tabulation-bottom-up"><a class="header" href="#2-tabulation-bottom-up">2. Tabulation (Bottom-Up)</a></h3>
<p>Tabulation builds up the solution iteratively, starting from the smallest subproblems and working up to the final solution.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>No recursion overhead</li>
<li>Usually faster in practice</li>
<li>Easier to optimize space complexity</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>May compute unnecessary subproblems</li>
<li>Can be less intuitive for complex problems</li>
</ul>
<pre><code class="language-python">def fib_tab(n):
    """Calculate nth Fibonacci number using tabulation"""
    if n &lt;= 1:
        return n

    # Build table bottom-up
    dp = [0] * (n + 1)
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

# Time: O(n), Space: O(n)
</code></pre>
<h3 id="3-space-optimized-tabulation"><a class="header" href="#3-space-optimized-tabulation">3. Space-Optimized Tabulation</a></h3>
<p>For many DP problems, you only need the last few states, not the entire table.</p>
<pre><code class="language-python">def fib_optimized(n):
    """Space-optimized Fibonacci calculation"""
    if n &lt;= 1:
        return n

    prev2, prev1 = 0, 1

    for _ in range(2, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current

    return prev1

# Time: O(n), Space: O(1)
</code></pre>
<h2 id="problem-classification-by-pattern"><a class="header" href="#problem-classification-by-pattern">Problem Classification by Pattern</a></h2>
<h3 id="pattern-1-linear-sequence-dp"><a class="header" href="#pattern-1-linear-sequence-dp">Pattern 1: Linear Sequence DP</a></h3>
<p><strong>Characteristics</strong>: <code>dp[i]</code> depends on previous states <code>dp[i-1]</code>, <code>dp[i-2]</code>, etc.</p>
<p><strong>Template</strong>:</p>
<pre><code class="language-python">dp[i] = f(dp[i-1], dp[i-2], ..., dp[i-k])
</code></pre>
<h4 id="climbing-stairs"><a class="header" href="#climbing-stairs">Climbing Stairs</a></h4>
<p><strong>Problem</strong>: Count ways to climb n stairs (1 or 2 steps at a time).</p>
<pre><code class="language-python">def climb_stairs(n):
    """Count distinct ways to climb n stairs"""
    if n &lt;= 2:
        return n

    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2

    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

# Time: O(n), Space: O(n)
# Can be optimized to O(1) space
</code></pre>
<h4 id="house-robber"><a class="header" href="#house-robber">House Robber</a></h4>
<p><strong>Problem</strong>: Rob houses to maximize money without robbing adjacent houses.</p>
<pre><code class="language-python">def rob(nums):
    """Maximum money you can rob without adjacent houses"""
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]

    # dp[i] = max money robbing houses 0..i
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i in range(2, len(nums)):
        # Either rob current house + dp[i-2], or skip it
        dp[i] = max(dp[i-1], nums[i] + dp[i-2])

    return dp[-1]

# Time: O(n), Space: O(n)
</code></pre>
<p><strong>Space-optimized version</strong>:</p>
<pre><code class="language-python">def rob_optimized(nums):
    if not nums:
        return 0

    prev2, prev1 = 0, 0

    for num in nums:
        current = max(prev1, num + prev2)
        prev2, prev1 = prev1, current

    return prev1

# Time: O(n), Space: O(1)
</code></pre>
<h4 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h4>
<p><strong>Problem</strong>: Find length of longest strictly increasing subsequence.</p>
<pre><code class="language-python">def length_of_LIS(nums):
    """Length of longest increasing subsequence"""
    if not nums:
        return 0

    n = len(nums)
    # dp[i] = length of LIS ending at index i
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if nums[j] &lt; nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

# Time: O(n²), Space: O(n)
# Can be optimized to O(n log n) using binary search
</code></pre>
<h3 id="pattern-2-gridmatrix-dp"><a class="header" href="#pattern-2-gridmatrix-dp">Pattern 2: Grid/Matrix DP</a></h3>
<p><strong>Characteristics</strong>: <code>dp[i][j]</code> depends on neighbors in 2D space.</p>
<p><strong>Template</strong>:</p>
<pre><code class="language-python">dp[i][j] = f(dp[i-1][j], dp[i][j-1], dp[i-1][j-1], ...)
</code></pre>
<h4 id="unique-paths"><a class="header" href="#unique-paths">Unique Paths</a></h4>
<p><strong>Problem</strong>: Count paths from top-left to bottom-right (only right/down moves).</p>
<pre><code class="language-python">def unique_paths(m, n):
    """Count unique paths in m×n grid"""
    # dp[i][j] = number of paths to reach cell (i,j)
    dp = [[1] * n for _ in range(m)]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]

# Time: O(m×n), Space: O(m×n)
</code></pre>
<p><strong>Space-optimized</strong>:</p>
<pre><code class="language-python">def unique_paths_optimized(m, n):
    dp = [1] * n

    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j-1]

    return dp[n-1]

# Time: O(m×n), Space: O(n)
</code></pre>
<h4 id="minimum-path-sum"><a class="header" href="#minimum-path-sum">Minimum Path Sum</a></h4>
<p><strong>Problem</strong>: Find minimum sum path from top-left to bottom-right.</p>
<pre><code class="language-python">def min_path_sum(grid):
    """Minimum path sum in grid"""
    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]

    # Initialize first cell
    dp[0][0] = grid[0][0]

    # Initialize first row
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]

    # Initialize first column
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]

    # Fill rest of table
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

    return dp[m-1][n-1]

# Time: O(m×n), Space: O(m×n)
</code></pre>
<h4 id="maximal-square"><a class="header" href="#maximal-square">Maximal Square</a></h4>
<p><strong>Problem</strong>: Find largest square containing only 1s in binary matrix.</p>
<pre><code class="language-python">def maximal_square(matrix):
    """Find area of largest square of 1s"""
    if not matrix or not matrix[0]:
        return 0

    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    max_side = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == '1':
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    # Square side length at (i,j)
                    dp[i][j] = min(
                        dp[i-1][j],      # top
                        dp[i][j-1],      # left
                        dp[i-1][j-1]     # diagonal
                    ) + 1
                max_side = max(max_side, dp[i][j])

    return max_side * max_side

# Time: O(m×n), Space: O(m×n)
</code></pre>
<h3 id="pattern-3-string-dp"><a class="header" href="#pattern-3-string-dp">Pattern 3: String DP</a></h3>
<p><strong>Characteristics</strong>: Problems involving sequences, subsequences, or substring operations.</p>
<h4 id="longest-common-subsequence-lcs"><a class="header" href="#longest-common-subsequence-lcs">Longest Common Subsequence (LCS)</a></h4>
<p><strong>Problem</strong>: Find length of longest subsequence common to both strings.</p>
<pre><code class="language-python">def longest_common_subsequence(text1, text2):
    """Length of longest common subsequence"""
    m, n = len(text1), len(text2)
    # dp[i][j] = LCS length of text1[0..i-1] and text2[0..j-1]
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                # Characters match: extend LCS
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                # Take max of excluding one character
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

# Time: O(m×n), Space: O(m×n)
</code></pre>
<p><strong>Reconstructing the LCS</strong>:</p>
<pre><code class="language-python">def get_lcs(text1, text2):
    """Get actual LCS string"""
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Build DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    # Backtrack to find LCS
    lcs = []
    i, j = m, n
    while i &gt; 0 and j &gt; 0:
        if text1[i-1] == text2[j-1]:
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] &gt; dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    return ''.join(reversed(lcs))
</code></pre>
<h4 id="edit-distance-levenshtein-distance"><a class="header" href="#edit-distance-levenshtein-distance">Edit Distance (Levenshtein Distance)</a></h4>
<p><strong>Problem</strong>: Minimum operations to convert word1 to word2 (insert, delete, replace).</p>
<pre><code class="language-python">def min_distance(word1, word2):
    """Minimum edit distance between two words"""
    m, n = len(word1), len(word2)
    # dp[i][j] = min operations to convert word1[0..i-1] to word2[0..j-1]
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Base cases: converting to/from empty string
    for i in range(m + 1):
        dp[i][0] = i  # Delete all characters
    for j in range(n + 1):
        dp[0][j] = j  # Insert all characters

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                # No operation needed
                dp[i][j] = dp[i-1][j-1]
            else:
                # Min of: replace, delete, insert
                dp[i][j] = 1 + min(
                    dp[i-1][j-1],  # Replace
                    dp[i-1][j],    # Delete from word1
                    dp[i][j-1]     # Insert to word1
                )

    return dp[m][n]

# Time: O(m×n), Space: O(m×n)
</code></pre>
<h4 id="longest-palindromic-subsequence"><a class="header" href="#longest-palindromic-subsequence">Longest Palindromic Subsequence</a></h4>
<p><strong>Problem</strong>: Find length of longest palindromic subsequence.</p>
<pre><code class="language-python">def longest_palindrome_subseq(s):
    """Length of longest palindromic subsequence"""
    n = len(s)
    # dp[i][j] = length of LPS in s[i..j]
    dp = [[0] * n for _ in range(n)]

    # Every single character is a palindrome of length 1
    for i in range(n):
        dp[i][i] = 1

    # Build table for substrings of increasing length
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                # Characters match: add 2 to inner subsequence
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                # Take max of excluding one end
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])

    return dp[0][n-1]

# Time: O(n²), Space: O(n²)
</code></pre>
<h4 id="word-break"><a class="header" href="#word-break">Word Break</a></h4>
<p><strong>Problem</strong>: Check if string can be segmented into dictionary words.</p>
<pre><code class="language-python">def word_break(s, wordDict):
    """Check if string can be segmented into words"""
    word_set = set(wordDict)
    n = len(s)
    # dp[i] = True if s[0..i-1] can be segmented
    dp = [False] * (n + 1)
    dp[0] = True  # Empty string

    for i in range(1, n + 1):
        for j in range(i):
            # If s[0..j-1] can be segmented and s[j..i-1] is a word
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break

    return dp[n]

# Time: O(n² × m) where m is average word length
# Space: O(n)
</code></pre>
<h3 id="pattern-4-knapsack-problems"><a class="header" href="#pattern-4-knapsack-problems">Pattern 4: Knapsack Problems</a></h3>
<p><strong>Characteristics</strong>: Selection problems with capacity constraints.</p>
<h4 id="01-knapsack"><a class="header" href="#01-knapsack">0/1 Knapsack</a></h4>
<p><strong>Problem</strong>: Maximize value with weight constraint (each item used at most once).</p>
<pre><code class="language-python">def knapsack_01(weights, values, capacity):
    """0/1 Knapsack: maximize value within capacity"""
    n = len(weights)
    # dp[i][w] = max value using items 0..i-1 with capacity w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't include item i-1
            dp[i][w] = dp[i-1][w]

            # Include item i-1 if it fits
            if weights[i-1] &lt;= w:
                dp[i][w] = max(
                    dp[i][w],
                    values[i-1] + dp[i-1][w - weights[i-1]]
                )

    return dp[n][capacity]

# Time: O(n×W), Space: O(n×W)
</code></pre>
<p><strong>Space-optimized 0/1 Knapsack</strong>:</p>
<pre><code class="language-python">def knapsack_01_optimized(weights, values, capacity):
    """Space-optimized 0/1 knapsack"""
    dp = [0] * (capacity + 1)

    for i in range(len(weights)):
        # Traverse backwards to avoid using updated values
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], values[i] + dp[w - weights[i]])

    return dp[capacity]

# Time: O(n×W), Space: O(W)
</code></pre>
<h4 id="unbounded-knapsack"><a class="header" href="#unbounded-knapsack">Unbounded Knapsack</a></h4>
<p><strong>Problem</strong>: Same as 0/1 but can use each item unlimited times.</p>
<pre><code class="language-python">def knapsack_unbounded(weights, values, capacity):
    """Unbounded knapsack: items can be used multiple times"""
    dp = [0] * (capacity + 1)

    for w in range(1, capacity + 1):
        for i in range(len(weights)):
            if weights[i] &lt;= w:
                dp[w] = max(dp[w], values[i] + dp[w - weights[i]])

    return dp[capacity]

# Time: O(n×W), Space: O(W)
</code></pre>
<h4 id="coin-change-minimum-coins"><a class="header" href="#coin-change-minimum-coins">Coin Change (Minimum Coins)</a></h4>
<p><strong>Problem</strong>: Minimum coins needed to make amount.</p>
<pre><code class="language-python">def coin_change(coins, amount):
    """Minimum coins to make amount"""
    # dp[i] = min coins to make amount i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Time: O(amount × len(coins)), Space: O(amount)
</code></pre>
<h4 id="coin-change-count-ways"><a class="header" href="#coin-change-count-ways">Coin Change (Count Ways)</a></h4>
<p><strong>Problem</strong>: Count ways to make amount with given coins.</p>
<pre><code class="language-python">def coin_change_ways(coins, amount):
    """Count ways to make amount"""
    dp = [0] * (amount + 1)
    dp[0] = 1

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]

    return dp[amount]

# Time: O(amount × len(coins)), Space: O(amount)
</code></pre>
<h3 id="pattern-5-partition-dp"><a class="header" href="#pattern-5-partition-dp">Pattern 5: Partition DP</a></h3>
<p><strong>Characteristics</strong>: Dividing array/string into parts to optimize some property.</p>
<h4 id="partition-equal-subset-sum"><a class="header" href="#partition-equal-subset-sum">Partition Equal Subset Sum</a></h4>
<p><strong>Problem</strong>: Check if array can be partitioned into two equal-sum subsets.</p>
<pre><code class="language-python">def can_partition(nums):
    """Check if array can be partitioned into equal sum subsets"""
    total = sum(nums)
    if total % 2:
        return False

    target = total // 2
    # dp[i] = True if sum i is achievable
    dp = [False] * (target + 1)
    dp[0] = True

    for num in nums:
        # Traverse backwards (0/1 knapsack pattern)
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] or dp[i - num]

    return dp[target]

# Time: O(n × sum/2), Space: O(sum/2)
</code></pre>
<h4 id="palindrome-partitioning-ii"><a class="header" href="#palindrome-partitioning-ii">Palindrome Partitioning II</a></h4>
<p><strong>Problem</strong>: Minimum cuts needed to partition string into palindromes.</p>
<pre><code class="language-python">def min_cut(s):
    """Minimum cuts for palindrome partitioning"""
    n = len(s)

    # Precompute palindrome check
    is_palindrome = [[False] * n for _ in range(n)]
    for i in range(n):
        is_palindrome[i][i] = True
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                is_palindrome[i][j] = (length == 2 or is_palindrome[i+1][j-1])

    # dp[i] = min cuts for s[0..i]
    dp = [0] * n
    for i in range(n):
        if is_palindrome[0][i]:
            dp[i] = 0
        else:
            dp[i] = i  # Max cuts
            for j in range(i):
                if is_palindrome[j+1][i]:
                    dp[i] = min(dp[i], dp[j] + 1)

    return dp[n-1]

# Time: O(n²), Space: O(n²)
</code></pre>
<h3 id="pattern-6-state-machine-dp"><a class="header" href="#pattern-6-state-machine-dp">Pattern 6: State Machine DP</a></h3>
<p><strong>Characteristics</strong>: Problems with multiple states and transitions.</p>
<h4 id="best-time-to-buy-and-sell-stock-with-cooldown"><a class="header" href="#best-time-to-buy-and-sell-stock-with-cooldown">Best Time to Buy and Sell Stock with Cooldown</a></h4>
<p><strong>Problem</strong>: Max profit with cooldown after selling.</p>
<pre><code class="language-python">def max_profit_cooldown(prices):
    """Max profit with cooldown"""
    if not prices:
        return 0

    n = len(prices)
    # States: hold stock, sold today, cooldown
    hold = [0] * n
    sold = [0] * n
    cooldown = [0] * n

    hold[0] = -prices[0]

    for i in range(1, n):
        # Hold: either already holding or buy today
        hold[i] = max(hold[i-1], cooldown[i-1] - prices[i])
        # Sold: sell today
        sold[i] = hold[i-1] + prices[i]
        # Cooldown: either already in cooldown or just sold
        cooldown[i] = max(cooldown[i-1], sold[i-1])

    return max(sold[-1], cooldown[-1])

# Time: O(n), Space: O(n)
</code></pre>
<h3 id="pattern-7-interval-dp"><a class="header" href="#pattern-7-interval-dp">Pattern 7: Interval DP</a></h3>
<p><strong>Characteristics</strong>: Problems on ranges/intervals <code>[i, j]</code>.</p>
<h4 id="burst-balloons"><a class="header" href="#burst-balloons">Burst Balloons</a></h4>
<p><strong>Problem</strong>: Maximize coins from bursting balloons.</p>
<pre><code class="language-python">def max_coins(nums):
    """Maximum coins from bursting balloons"""
    # Add 1s at boundaries
    nums = [1] + nums + [1]
    n = len(nums)
    # dp[i][j] = max coins bursting balloons (i, j) (exclusive)
    dp = [[0] * n for _ in range(n)]

    # Build for increasing interval lengths
    for length in range(2, n):
        for left in range(n - length):
            right = left + length
            # Try bursting each balloon k last in (left, right)
            for k in range(left + 1, right):
                coins = nums[left] * nums[k] * nums[right]
                coins += dp[left][k] + dp[k][right]
                dp[left][right] = max(dp[left][right], coins)

    return dp[0][n-1]

# Time: O(n³), Space: O(n²)
</code></pre>
<h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<h3 id="state-space-reduction"><a class="header" href="#state-space-reduction">State Space Reduction</a></h3>
<p>Many DP problems can be optimized by reducing the state space:</p>
<ol>
<li><strong>Eliminate redundant dimensions</strong>: If a dimension can be computed from others, remove it</li>
<li><strong>Use modulo arithmetic</strong>: For counting problems with large numbers</li>
<li><strong>Compress coordinates</strong>: Map large ranges to smaller ones</li>
<li><strong>Rolling array</strong>: Keep only last k rows/columns instead of entire table</li>
</ol>
<h3 id="dp-with-data-structures"><a class="header" href="#dp-with-data-structures">DP with Data Structures</a></h3>
<p>Combining DP with advanced data structures can optimize solutions.</p>
<h4 id="monotonic-queue-optimization"><a class="header" href="#monotonic-queue-optimization">Monotonic Queue Optimization</a></h4>
<p><strong>Problem</strong>: Sliding window maximum with DP.</p>
<pre><code class="language-python">from collections import deque

def max_sliding_window_dp(nums, k):
    """DP with monotonic deque for sliding window maximum"""
    if not nums:
        return []

    dq = deque()  # Stores indices
    result = []

    for i in range(len(nums)):
        # Remove elements outside window
        while dq and dq[0] &lt; i - k + 1:
            dq.popleft()

        # Remove smaller elements (maintain decreasing order)
        while dq and nums[dq[-1]] &lt; nums[i]:
            dq.pop()

        dq.append(i)

        # Add to result when window is full
        if i &gt;= k - 1:
            result.append(nums[dq[0]])

    return result

# Time: O(n), Space: O(k)
</code></pre>
<h4 id="segment-tree-dp"><a class="header" href="#segment-tree-dp">Segment Tree DP</a></h4>
<p><strong>Problem</strong>: Range maximum query with updates in DP.</p>
<pre><code class="language-python">class SegmentTree:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (4 * n)

    def update(self, node, start, end, idx, val):
        if start == end:
            self.tree[node] = val
        else:
            mid = (start + end) // 2
            if idx &lt;= mid:
                self.update(2*node, start, mid, idx, val)
            else:
                self.update(2*node+1, mid+1, end, idx, val)
            self.tree[node] = max(self.tree[2*node], self.tree[2*node+1])

    def query(self, node, start, end, l, r):
        if r &lt; start or end &lt; l:
            return float('-inf')
        if l &lt;= start and end &lt;= r:
            return self.tree[node]
        mid = (start + end) // 2
        return max(
            self.query(2*node, start, mid, l, r),
            self.query(2*node+1, mid+1, end, l, r)
        )

def dp_with_segment_tree(arr):
    """DP optimization using segment tree"""
    n = len(arr)
    st = SegmentTree(n)
    dp = [0] * n

    for i in range(n):
        # Query best previous state in range
        if i &gt; 0:
            best = st.query(1, 0, n-1, 0, i-1)
            dp[i] = best + arr[i]
        else:
            dp[i] = arr[i]
        # Update segment tree
        st.update(1, 0, n-1, i, dp[i])

    return max(dp)

# Time: O(n log n), Space: O(n)
</code></pre>
<h3 id="convex-hull-trick-cht"><a class="header" href="#convex-hull-trick-cht">Convex Hull Trick (CHT)</a></h3>
<p>Optimize DP transitions with linear functions.</p>
<p><strong>Problem</strong>: Minimum cost with linear transitions.</p>
<pre><code class="language-python">from collections import deque

def convex_hull_trick(arr):
    """DP optimization using convex hull trick"""
    n = len(arr)
    dp = [0] * n

    # Line represented as (m, c) for y = mx + c
    hull = deque()

    def bad(l1, l2, l3):
        """Check if l2 is redundant"""
        m1, c1 = l1
        m2, c2 = l2
        m3, c3 = l3
        # Cross product comparison
        return (c3 - c1) * (m1 - m2) &lt;= (c2 - c1) * (m1 - m3)

    def query(hull, x):
        """Find minimum value at x"""
        # Binary search for best line
        left, right = 0, len(hull) - 1
        while left &lt; right:
            mid = (left + right) // 2
            m1, c1 = hull[mid]
            m2, c2 = hull[mid + 1]
            if m1 * x + c1 &gt;= m2 * x + c2:
                left = mid + 1
            else:
                right = mid
        m, c = hull[left]
        return m * x + c

    dp[0] = 0
    hull.append((0, 0))  # Initial line

    for i in range(1, n):
        # Query best previous state
        dp[i] = query(hull, arr[i])

        # Add new line to hull
        new_line = (i, dp[i])
        while len(hull) &gt;= 2 and bad(hull[-2], hull[-1], new_line):
            hull.pop()
        hull.append(new_line)

    return dp[n-1]

# Time: O(n log n) with binary search, O(n) if queries are monotonic
</code></pre>
<h3 id="divide-and-conquer-optimization"><a class="header" href="#divide-and-conquer-optimization">Divide and Conquer Optimization</a></h3>
<p>For DP with special monotonicity property.</p>
<p><strong>Condition</strong>: If <code>dp[i][j] = min(dp[i-1][k] + cost[k][j])</code> for <code>k &lt; j</code>, and the optimal <code>k</code> is monotonic.</p>
<pre><code class="language-python">def divide_and_conquer_dp(cost, m):
    """
    Divide and conquer DP optimization
    dp[i][j] = min cost to partition arr[0..j] into i groups
    """
    n = len(cost)
    dp = [[float('inf')] * n for _ in range(m + 1)]

    # Base case
    for j in range(n):
        dp[1][j] = cost[0][j]

    def solve(i, l, r, opt_l, opt_r):
        """
        Compute dp[i][l..r] knowing optimal k is in [opt_l, opt_r]
        """
        if l &gt; r:
            return

        mid = (l + r) // 2
        best_k = -1

        # Find optimal k for dp[i][mid]
        for k in range(opt_l, min(mid, opt_r) + 1):
            val = dp[i-1][k] + cost[k+1][mid]
            if val &lt; dp[i][mid]:
                dp[i][mid] = val
                best_k = k

        # Recursively solve left and right
        solve(i, l, mid - 1, opt_l, best_k)
        solve(i, mid + 1, r, best_k, opt_r)

    for i in range(2, m + 1):
        solve(i, 0, n - 1, 0, n - 1)

    return dp[m][n-1]

# Time: O(m × n log n), Space: O(m × n)
# Without optimization: O(m × n²)
</code></pre>
<h3 id="knuths-optimization"><a class="header" href="#knuths-optimization">Knuth’s Optimization</a></h3>
<p>For interval DP with quadrangle inequality.</p>
<p><strong>Condition</strong>: If <code>cost[i][j]</code> satisfies quadrangle inequality.</p>
<pre><code class="language-python">def knuth_optimization(arr):
    """
    Optimal binary search tree using Knuth's optimization
    """
    n = len(arr)
    dp = [[0] * n for _ in range(n)]
    opt = [[0] * n for _ in range(n)]  # Stores optimal split point

    # Base case: single elements
    for i in range(n):
        opt[i][i] = i

    # Build for increasing lengths
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')

            # Search only between opt[i][j-1] and opt[i+1][j]
            for k in range(opt[i][j-1], min(opt[i+1][j], j) + 1):
                cost = dp[i][k-1] if k &gt; i else 0
                cost += dp[k+1][j] if k &lt; j else 0
                cost += sum(arr[i:j+1])  # Additional cost

                if cost &lt; dp[i][j]:
                    dp[i][j] = cost
                    opt[i][j] = k

    return dp[0][n-1]

# Time: O(n²), Space: O(n²)
# Without optimization: O(n³)
</code></pre>
<h3 id="bitmask-dp"><a class="header" href="#bitmask-dp">Bitmask DP</a></h3>
<p>Use bitmasks to represent subsets when state involves combinations.</p>
<p><strong>Example: Traveling Salesman Problem</strong></p>
<pre><code class="language-python">def tsp(dist):
    """Minimum cost to visit all cities (TSP)"""
    n = len(dist)
    # dp[mask][i] = min cost to visit cities in mask, ending at i
    dp = [[float('inf')] * n for _ in range(1 &lt;&lt; n)]
    dp[1][0] = 0  # Start at city 0

    for mask in range(1 &lt;&lt; n):
        for u in range(n):
            if not (mask &amp; (1 &lt;&lt; u)):
                continue
            for v in range(n):
                if mask &amp; (1 &lt;&lt; v):
                    continue
                new_mask = mask | (1 &lt;&lt; v)
                dp[new_mask][v] = min(
                    dp[new_mask][v],
                    dp[mask][u] + dist[u][v]
                )

    # Return to start
    return min(dp[(1 &lt;&lt; n) - 1][i] + dist[i][0] for i in range(n))

# Time: O(2ⁿ × n²), Space: O(2ⁿ × n)
</code></pre>
<h3 id="digit-dp"><a class="header" href="#digit-dp">Digit DP</a></h3>
<p>Solve problems on ranges of numbers by processing digits.</p>
<p><strong>Example: Count numbers with property in range [L, R]</strong></p>
<pre><code class="language-python">def count_digit_dp(n):
    """Count numbers up to n with some property"""
    s = str(n)
    memo = {}

    def dp(pos, tight, started):
        """
        pos: current digit position
        tight: whether we're bounded by n
        started: whether number has started (handle leading zeros)
        """
        if pos == len(s):
            return 1 if started else 0

        if (pos, tight, started) in memo:
            return memo[(pos, tight, started)]

        limit = int(s[pos]) if tight else 9
        result = 0

        for digit in range(0, limit + 1):
            # Check property here
            new_tight = tight and (digit == limit)
            new_started = started or (digit != 0)
            result += dp(pos + 1, new_tight, new_started)

        memo[(pos, tight, started)] = result
        return result

    return dp(0, True, False)
</code></pre>
<h3 id="tree-dp"><a class="header" href="#tree-dp">Tree DP</a></h3>
<p>DP on trees, usually processing from leaves up.</p>
<h4 id="pattern-1-maximum-independent-set-in-tree"><a class="header" href="#pattern-1-maximum-independent-set-in-tree">Pattern 1: Maximum Independent Set in Tree</a></h4>
<pre><code class="language-python">def tree_dp(graph, root):
    """Maximum independent set in tree"""
    # include[v] = max value including v
    # exclude[v] = max value excluding v
    include = {}
    exclude = {}

    def dfs(node, parent):
        include[node] = 1  # Value of node
        exclude[node] = 0

        for child in graph[node]:
            if child == parent:
                continue
            dfs(child, node)
            # If we include node, can't include children
            include[node] += exclude[child]
            # If we exclude node, take max of children
            exclude[node] += max(include[child], exclude[child])

    dfs(root, -1)
    return max(include[root], exclude[root])
</code></pre>
<h4 id="pattern-2-tree-distance-dp"><a class="header" href="#pattern-2-tree-distance-dp">Pattern 2: Tree Distance DP</a></h4>
<p><strong>Problem</strong>: Find maximum distance from each node.</p>
<pre><code class="language-python">def tree_distance_dp(graph, n):
    """Maximum distance from each node in tree"""
    # dp_down[v] = max distance going down from v
    # dp_up[v] = max distance going up from v
    dp_down = [0] * n
    dp_up = [0] * n

    def dfs_down(node, parent):
        """Calculate max distance going down"""
        max_dist = 0
        for child in graph[node]:
            if child != parent:
                dfs_down(child, node)
                max_dist = max(max_dist, 1 + dp_down[child])
        dp_down[node] = max_dist

    def dfs_up(node, parent):
        """Calculate max distance going up or to siblings"""
        # Find two largest child distances
        distances = []
        for child in graph[node]:
            if child != parent:
                distances.append(dp_down[child])
        distances.sort(reverse=True)

        for child in graph[node]:
            if child != parent:
                # Distance going up through parent
                up_dist = dp_up[node] + 1

                # Distance to sibling through parent
                if distances and dp_down[child] == distances[0]:
                    # This child has max distance, use second max
                    sibling_dist = (distances[1] + 2) if len(distances) &gt; 1 else 0
                else:
                    sibling_dist = distances[0] + 2 if distances else 0

                dp_up[child] = max(up_dist, sibling_dist)
                dfs_up(child, node)

    dfs_down(0, -1)
    dfs_up(0, -1)

    # Answer for each node
    return [max(dp_down[i], dp_up[i]) for i in range(n)]

# Time: O(n), Space: O(n)
</code></pre>
<h4 id="pattern-3-rerooting-technique"><a class="header" href="#pattern-3-rerooting-technique">Pattern 3: Rerooting Technique</a></h4>
<p><strong>Problem</strong>: Compute answer for each node as root.</p>
<pre><code class="language-python">def tree_rerooting(graph, n):
    """Compute DP for each node as root using rerooting"""
    dp = [0] * n
    ans = [0] * n

    def dfs1(node, parent):
        """First DFS: compute subtree answers"""
        result = 0
        for child in graph[node]:
            if child != parent:
                result += dfs1(child, node) + 1
        dp[node] = result
        return result

    def dfs2(node, parent, parent_contribution):
        """Second DFS: reroot and compute answers"""
        ans[node] = dp[node] + parent_contribution

        for child in graph[node]:
            if child != parent:
                # Remove child's contribution
                without_child = ans[node] - (dp[child] + 1)
                # Reroot to child
                dfs2(child, node, without_child + 1)

    dfs1(0, -1)
    dfs2(0, -1, 0)
    return ans

# Time: O(n), Space: O(n)
</code></pre>
<h3 id="probabilistic-dp"><a class="header" href="#probabilistic-dp">Probabilistic DP</a></h3>
<p>Handle problems involving probabilities and expected values.</p>
<h4 id="expected-value-dp"><a class="header" href="#expected-value-dp">Expected Value DP</a></h4>
<p><strong>Problem</strong>: Expected number of dice rolls to reach target.</p>
<pre><code class="language-python">def expected_dice_rolls(target):
    """Expected rolls to reach target with fair die (1-6)"""
    # dp[i] = expected rolls to reach target from i
    dp = [0] * (target + 7)

    for i in range(target - 1, -1, -1):
        # From position i, roll die
        expected = 0
        for dice in range(1, 7):
            next_pos = min(i + dice, target)
            if next_pos == target:
                expected += 1  # Reached target in 1 roll
            else:
                expected += 1 + dp[next_pos]  # 1 roll + expected from next
        dp[i] = expected / 6  # Average over all outcomes

    return dp[0]

# Time: O(target), Space: O(target)
</code></pre>
<h4 id="probability-dp"><a class="header" href="#probability-dp">Probability DP</a></h4>
<p><strong>Problem</strong>: Probability of reaching target score.</p>
<pre><code class="language-python">def probability_target(n, k, target):
    """
    Probability of reaching exactly target with n dice, k faces each
    """
    # dp[i][j] = probability of sum j using i dice
    dp = [[0.0] * (target + 1) for _ in range(n + 1)]
    dp[0][0] = 1.0  # Base: 0 dice, 0 sum

    for i in range(1, n + 1):
        for j in range(i, min(target + 1, i * k + 1)):
            # Roll current die
            for face in range(1, k + 1):
                if j - face &gt;= 0:
                    dp[i][j] += dp[i-1][j-face] / k

    return dp[n][target]

# Time: O(n × target × k), Space: O(n × target)
</code></pre>
<h4 id="expected-value-with-decisions"><a class="header" href="#expected-value-with-decisions">Expected Value with Decisions</a></h4>
<p><strong>Problem</strong>: Expected maximum value with optimal strategy.</p>
<pre><code class="language-python">def expected_maximum_value(prices):
    """
    Expected value selling stock optimally
    Each day: know future is randomly up/down
    """
    n = len(prices)
    # dp[i] = expected value starting from day i
    dp = [0] * (n + 1)

    for i in range(n - 1, -1, -1):
        # Option 1: Sell now
        sell_now = prices[i]

        # Option 2: Wait (assume 50% up, 50% down)
        if i &lt; n - 1:
            wait = (dp[i+1] * 1.1 + dp[i+1] * 0.9) / 2  # Expected next value
        else:
            wait = 0

        dp[i] = max(sell_now, wait)

    return dp[0]

# Time: O(n), Space: O(n)
</code></pre>
<h3 id="profile-dp"><a class="header" href="#profile-dp">Profile DP</a></h3>
<p>For grid problems where you need to track column state.</p>
<p><strong>Problem</strong>: Tiling a board with dominoes.</p>
<pre><code class="language-python">def domino_tiling(n, m):
    """Count ways to tile n×m board with 1×2 dominoes"""
    # dp[col][mask] = ways to reach col with profile mask
    # mask[i] = 1 if cell (i, col) is filled from previous column

    def fits(mask, i, n):
        """Check if we can place tiles starting from row i"""
        if i == n:
            return mask == 0  # All cells must be filled

        if mask &amp; (1 &lt;&lt; i):  # Already filled
            return fits(mask, i + 1, n)

        # Try vertical tile (fills current column)
        result = fits(mask | (1 &lt;&lt; i), i + 1, n)

        # Try horizontal tile (extends to next column)
        if i + 1 &lt; n and not (mask &amp; (1 &lt;&lt; (i + 1))):
            new_mask = mask | (1 &lt;&lt; i) | (1 &lt;&lt; (i + 1))
            result += fits(new_mask, i + 2, n)

        return result

    # dp[col][mask]
    dp = [{} for _ in range(m + 1)]
    dp[0][0] = 1

    for col in range(m):
        for mask, ways in dp[col].items():
            # Try all next profiles
            def fill_column(row, curr_mask, next_mask):
                if row == n:
                    dp[col + 1][next_mask] = dp[col + 1].get(next_mask, 0) + ways
                    return

                if curr_mask &amp; (1 &lt;&lt; row):  # Already filled
                    fill_column(row + 1, curr_mask, next_mask)
                else:
                    # Place vertical tile
                    fill_column(row + 1, curr_mask | (1 &lt;&lt; row), next_mask)

                    # Place horizontal tile
                    if row + 1 &lt; n and not (curr_mask &amp; (1 &lt;&lt; (row + 1))):
                        new_curr = curr_mask | (1 &lt;&lt; row) | (1 &lt;&lt; (row + 1))
                        new_next = next_mask | (1 &lt;&lt; row) | (1 &lt;&lt; (row + 1))
                        fill_column(row + 2, new_curr, new_next)

            fill_column(0, mask, 0)

    return dp[m].get(0, 0)

# Time: O(m × 2^n × n), Space: O(2^n)
</code></pre>
<h3 id="sos-sum-over-subsets-dp"><a class="header" href="#sos-sum-over-subsets-dp">SOS (Sum over Subsets) DP</a></h3>
<p>Efficiently compute sum over all subsets.</p>
<p><strong>Problem</strong>: For each mask, compute sum over all its submasks.</p>
<pre><code class="language-python">def sum_over_subsets(arr):
    """
    For each mask i, compute sum of arr[j] for all j that are submasks of i
    """
    n = len(arr)
    max_mask = n  # Assuming arr indexed by mask values
    log_n = max_mask.bit_length()

    dp = arr[:]

    # Iterate over bits
    for i in range(log_n):
        # Iterate over masks
        for mask in range(max_mask):
            if mask &amp; (1 &lt;&lt; i):
                # Add contribution from mask without bit i
                dp[mask] += dp[mask ^ (1 &lt;&lt; i)]

    return dp

# Time: O(n × log n) where n = 2^k
# Without SOS DP: O(3^k) for k bits
</code></pre>
<p><strong>Example: Count AND pairs</strong></p>
<pre><code class="language-python">def count_and_pairs(arr, target):
    """Count pairs where arr[i] &amp; arr[j] == target"""
    max_val = max(arr)
    freq = [0] * (max_val + 1)

    # Count frequency
    for num in arr:
        freq[num] += 1

    # SOS DP
    dp = freq[:]
    for i in range(20):  # Assuming 20-bit numbers
        for mask in range(max_val + 1):
            if mask &amp; (1 &lt;&lt; i):
                dp[mask] += dp[mask ^ (1 &lt;&lt; i)]

    # Count pairs
    count = 0
    for num in arr:
        # Find supermasks that AND with num gives target
        supermask = num | target
        if supermask &lt;= max_val:
            count += dp[supermask]

    return count

# Time: O(n + M log M) where M is max value
</code></pre>
<h2 id="complexity-analysis"><a class="header" href="#complexity-analysis">Complexity Analysis</a></h2>
<h3 id="time-complexity-patterns"><a class="header" href="#time-complexity-patterns">Time Complexity Patterns</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Typical Complexity</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>1D DP</td><td>O(n) to O(n²)</td><td>Fibonacci, House Robber</td></tr>
<tr><td>2D DP</td><td>O(n²) to O(n³)</td><td>LCS, Edit Distance</td></tr>
<tr><td>Knapsack</td><td>O(n × W)</td><td>0/1 Knapsack, Coin Change</td></tr>
<tr><td>Substring</td><td>O(n²) to O(n³)</td><td>Palindrome problems</td></tr>
<tr><td>Interval DP</td><td>O(n³)</td><td>Matrix chain, Burst balloons</td></tr>
<tr><td>Bitmask DP</td><td>O(2ⁿ × n) to O(2ⁿ × n²)</td><td>TSP, Subset problems</td></tr>
</tbody>
</table>
</div>
<h3 id="space-complexity-optimization"><a class="header" href="#space-complexity-optimization">Space Complexity Optimization</a></h3>
<ol>
<li><strong>Rolling array</strong>: O(n × m) → O(m) for many 2D DP problems</li>
<li><strong>In-place modification</strong>: Use input array as DP table</li>
<li><strong>State elimination</strong>: Remove redundant state dimensions</li>
</ol>
<h3 id="comparison-naive-vs-dp"><a class="header" href="#comparison-naive-vs-dp">Comparison: Naive vs DP</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Problem</th><th>Naive</th><th>DP</th><th>Improvement</th></tr>
</thead>
<tbody>
<tr><td>Fibonacci</td><td>O(2ⁿ)</td><td>O(n)</td><td>Exponential → Linear</td></tr>
<tr><td>LCS</td><td>O(2^(m+n))</td><td>O(m×n)</td><td>Exponential → Polynomial</td></tr>
<tr><td>Knapsack</td><td>O(2ⁿ)</td><td>O(n×W)</td><td>Exponential → Pseudo-polynomial</td></tr>
<tr><td>Coin Change</td><td>O(S^n)</td><td>O(n×amount)</td><td>Exponential → Polynomial</td></tr>
</tbody>
</table>
</div>
<h2 id="implementation-tips"><a class="header" href="#implementation-tips">Implementation Tips</a></h2>
<h3 id="1-define-the-state"><a class="header" href="#1-define-the-state">1. Define the State</a></h3>
<p><strong>Questions to ask</strong>:</p>
<ul>
<li>What information is needed to solve subproblems?</li>
<li>What’s the minimum state needed (avoid redundancy)?</li>
<li>Can I solve for state X using smaller states?</li>
</ul>
<p><strong>Example</strong>: For LCS, state is <code>(i, j)</code> representing position in both strings.</p>
<h3 id="2-define-the-recurrence-relation"><a class="header" href="#2-define-the-recurrence-relation">2. Define the Recurrence Relation</a></h3>
<p>Express the solution in terms of smaller subproblems.</p>
<p><strong>Template</strong>:</p>
<pre><code>dp[current_state] = optimal_choice(
    dp[smaller_state_1],
    dp[smaller_state_2],
    ...
)
</code></pre>
<h3 id="3-identify-base-cases"><a class="header" href="#3-identify-base-cases">3. Identify Base Cases</a></h3>
<p>What are the smallest subproblems you can solve directly?</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Empty string: <code>dp[0][...] = 0</code></li>
<li>Single element: <code>dp[i][i] = ...</code></li>
</ul>
<h3 id="4-determine-iteration-order"><a class="header" href="#4-determine-iteration-order">4. Determine Iteration Order</a></h3>
<p>Ensure you compute smaller subproblems before larger ones.</p>
<p><strong>Patterns</strong>:</p>
<ul>
<li>1D: Iterate i from small to large</li>
<li>2D: Iterate i, then j (or by diagonal/length)</li>
<li>Intervals: Iterate by increasing interval length</li>
</ul>
<h3 id="5-initialize-the-dp-table"><a class="header" href="#5-initialize-the-dp-table">5. Initialize the DP Table</a></h3>
<p>Set base cases and default values (0, infinity, false, etc.)</p>
<h3 id="6-implement-and-optimize"><a class="header" href="#6-implement-and-optimize">6. Implement and Optimize</a></h3>
<p>Start with clear memoization, then optimize to tabulation and space reduction.</p>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-wrong-base-cases"><a class="header" href="#1-wrong-base-cases">1. Wrong Base Cases</a></h3>
<pre><code class="language-python"># Wrong: doesn't handle n=0
def fib(n):
    dp = [0] * n
    # IndexError when n=0!

# Correct
def fib(n):
    if n &lt;= 1:
        return n
    dp = [0] * (n + 1)
</code></pre>
<h3 id="2-wrong-iteration-order"><a class="header" href="#2-wrong-iteration-order">2. Wrong Iteration Order</a></h3>
<pre><code class="language-python"># Wrong: using updated values in 0/1 knapsack
for item in items:
    for w in range(W + 1):  # Forward iteration
        dp[w] = max(dp[w], dp[w - weight] + value)

# Correct: backward iteration prevents using updated values
for item in items:
    for w in range(W, weight - 1, -1):
        dp[w] = max(dp[w], dp[w - weight] + value)
</code></pre>
<h3 id="3-off-by-one-errors"><a class="header" href="#3-off-by-one-errors">3. Off-by-One Errors</a></h3>
<p>Be careful with array indices vs. problem indices.</p>
<pre><code class="language-python"># dp[i] represents first i elements (0-indexed array)
# So element at index i-1 in array
dp[i] = f(array[i-1], dp[i-1])
</code></pre>
<h3 id="4-integer-overflow"><a class="header" href="#4-integer-overflow">4. Integer Overflow</a></h3>
<p>For counting problems with large results:</p>
<pre><code class="language-python">MOD = 10**9 + 7

def count_ways(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        dp[i] = (dp[i-1] + dp[i-2]) % MOD  # Take modulo
    return dp[n]
</code></pre>
<h3 id="5-not-considering-all-transitions"><a class="header" href="#5-not-considering-all-transitions">5. Not Considering All Transitions</a></h3>
<p>Ensure your recurrence considers all possible ways to reach a state.</p>
<h3 id="6-mutable-default-arguments"><a class="header" href="#6-mutable-default-arguments">6. Mutable Default Arguments</a></h3>
<pre><code class="language-python"># Wrong: memo is shared across calls!
def dp(n, memo={}):
    ...

# Correct
def dp(n, memo=None):
    if memo is None:
        memo = {}
    ...
</code></pre>
<h3 id="matrix-exponentiation-with-dp"><a class="header" href="#matrix-exponentiation-with-dp">Matrix Exponentiation with DP</a></h3>
<p>Optimize linear recurrences using matrix exponentiation.</p>
<p><strong>Problem</strong>: Compute nth Fibonacci number in O(log n).</p>
<pre><code class="language-python">def matrix_mult(A, B):
    """Multiply two 2x2 matrices"""
    return [
        [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
        [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
    ]

def matrix_pow(M, n):
    """Compute M^n using binary exponentiation"""
    if n == 1:
        return M
    if n % 2 == 0:
        half = matrix_pow(M, n // 2)
        return matrix_mult(half, half)
    else:
        return matrix_mult(M, matrix_pow(M, n - 1))

def fibonacci_fast(n):
    """Compute nth Fibonacci in O(log n)"""
    if n &lt;= 1:
        return n

    # Transformation matrix for Fibonacci
    M = [[1, 1], [1, 0]]
    result = matrix_pow(M, n)
    return result[0][1]

# Time: O(log n), Space: O(log n)
# Standard DP: O(n) time
</code></pre>
<p><strong>General linear recurrence</strong>:</p>
<pre><code class="language-python">def linear_recurrence_fast(coeffs, init, n):
    """
    Solve f(n) = c1*f(n-1) + c2*f(n-2) + ... + ck*f(n-k)
    coeffs = [c1, c2, ..., ck]
    init = [f(0), f(1), ..., f(k-1)]
    """
    k = len(coeffs)
    if n &lt; k:
        return init[n]

    # Build transformation matrix
    M = [[0] * k for _ in range(k)]
    M[0] = coeffs
    for i in range(1, k):
        M[i][i-1] = 1

    def mat_mult(A, B):
        size = len(A)
        C = [[0] * size for _ in range(size)]
        for i in range(size):
            for j in range(size):
                for k in range(size):
                    C[i][j] += A[i][k] * B[k][j]
        return C

    def mat_pow(mat, exp):
        if exp == 1:
            return mat
        if exp % 2 == 0:
            half = mat_pow(mat, exp // 2)
            return mat_mult(half, half)
        return mat_mult(mat, mat_pow(mat, exp - 1))

    # Apply transformation n - k + 1 times
    result_mat = mat_pow(M, n - k + 1)

    # Compute result from initial values
    result = 0
    for i in range(k):
        result += result_mat[0][i] * init[k - 1 - i]

    return result

# Time: O(k³ log n), Space: O(k²)
</code></pre>
<h3 id="dp-with-number-theory"><a class="header" href="#dp-with-number-theory">DP with Number Theory</a></h3>
<p>Combine DP with mathematical properties.</p>
<h4 id="counting-with-modular-arithmetic"><a class="header" href="#counting-with-modular-arithmetic">Counting with Modular Arithmetic</a></h4>
<pre><code class="language-python">MOD = 10**9 + 7

def count_ways_mod(n, k):
    """Count ways to reach n using steps 1 to k, modulo MOD"""
    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n + 1):
        for step in range(1, min(i, k) + 1):
            dp[i] = (dp[i] + dp[i - step]) % MOD

    return dp[n]

# Time: O(n × k), Space: O(n)
</code></pre>
<h4 id="dp-with-gcdlcm"><a class="header" href="#dp-with-gcdlcm">DP with GCD/LCM</a></h4>
<pre><code class="language-python">import math

def max_gcd_path(grid):
    """Maximum GCD along path from top-left to bottom-right"""
    m, n = len(grid), len(grid[0])
    # dp[i][j] = set of possible GCDs reaching (i, j)
    dp = [[set() for _ in range(n)] for _ in range(m)]

    dp[0][0].add(grid[0][0])

    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                continue

            # From top
            if i &gt; 0:
                for g in dp[i-1][j]:
                    dp[i][j].add(math.gcd(g, grid[i][j]))

            # From left
            if j &gt; 0:
                for g in dp[i][j-1]:
                    dp[i][j].add(math.gcd(g, grid[i][j]))

    return max(dp[m-1][n-1])

# Time: O(m × n × G × log V) where G is number of unique GCDs, V is max value
</code></pre>
<h4 id="digit-dp-with-constraints"><a class="header" href="#digit-dp-with-constraints">Digit DP with Constraints</a></h4>
<pre><code class="language-python">def count_numbers_with_digit_sum(n, target_sum):
    """Count numbers from 1 to n with digit sum equal to target_sum"""
    s = str(n)
    memo = {}

    def dp(pos, sum_so_far, tight, started):
        """
        pos: current position
        sum_so_far: sum of digits chosen
        tight: whether we're still bounded by n
        started: whether we've placed a non-zero digit
        """
        if pos == len(s):
            return 1 if (started and sum_so_far == target_sum) else 0

        state = (pos, sum_so_far, tight, started)
        if state in memo:
            return memo[state]

        limit = int(s[pos]) if tight else 9
        result = 0

        for digit in range(0, limit + 1):
            if not started and digit == 0:
                # Leading zero
                result += dp(pos + 1, sum_so_far, False, False)
            else:
                new_sum = sum_so_far + digit
                if new_sum &lt;= target_sum:  # Prune
                    new_tight = tight and (digit == limit)
                    result += dp(pos + 1, new_sum, new_tight, True)

        memo[state] = result
        return result

    return dp(0, 0, True, False)

# Time: O(len(n) × target_sum × 2 × 2 × 10)
</code></pre>
<h2 id="problem-solving-framework"><a class="header" href="#problem-solving-framework">Problem-Solving Framework</a></h2>
<h3 id="step-by-step-approach"><a class="header" href="#step-by-step-approach">Step-by-Step Approach</a></h3>
<ol>
<li>
<p><strong>Understand the problem</strong></p>
<ul>
<li>What are we optimizing/counting/deciding?</li>
<li>What are the constraints?</li>
</ul>
</li>
<li>
<p><strong>Check if DP is applicable</strong></p>
<ul>
<li>Optimal substructure?</li>
<li>Overlapping subproblems?</li>
<li>Can you identify a recurrence?</li>
</ul>
</li>
<li>
<p><strong>Define the state</strong></p>
<ul>
<li>What parameters uniquely identify a subproblem?</li>
<li>Minimize dimensions if possible</li>
</ul>
</li>
<li>
<p><strong>Write the recurrence</strong></p>
<ul>
<li>How does <code>dp[current]</code> relate to previous states?</li>
<li>Consider all transitions</li>
</ul>
</li>
<li>
<p><strong>Identify base cases</strong></p>
<ul>
<li>What are the simplest subproblems?</li>
</ul>
</li>
<li>
<p><strong>Choose implementation</strong></p>
<ul>
<li>Start with memoization (easier to implement)</li>
<li>Optimize to tabulation if needed</li>
<li>Consider space optimization</li>
</ul>
</li>
<li>
<p><strong>Code and test</strong></p>
<ul>
<li>Test base cases</li>
<li>Test small examples</li>
<li>Verify time/space complexity</li>
</ul>
</li>
</ol>
<h3 id="debugging-dp-solutions"><a class="header" href="#debugging-dp-solutions">Debugging DP Solutions</a></h3>
<h4 id="common-debugging-strategies"><a class="header" href="#common-debugging-strategies">Common Debugging Strategies</a></h4>
<ol>
<li><strong>Print the DP table</strong></li>
</ol>
<pre><code class="language-python">def debug_dp_table(dp):
    """Visualize DP table"""
    for i, row in enumerate(dp):
        print(f"dp[{i}] = {row}")
</code></pre>
<ol start="2">
<li><strong>Verify base cases</strong></li>
</ol>
<pre><code class="language-python">def verify_base_cases():
    """Test smallest inputs"""
    assert climb_stairs(1) == 1
    assert climb_stairs(2) == 2
    assert climb_stairs(3) == 3
</code></pre>
<ol start="3">
<li><strong>Check recurrence manually</strong></li>
</ol>
<pre><code class="language-python">def manual_check():
    """Manually verify recurrence for small n"""
    # For climbing stairs: dp[3] should equal dp[2] + dp[1]
    assert dp[3] == dp[2] + dp[1]
</code></pre>
<ol start="4">
<li><strong>Compare with brute force</strong></li>
</ol>
<pre><code class="language-python">def brute_force(n):
    """Exponential but correct solution"""
    if n &lt;= 1:
        return 1
    return brute_force(n-1) + brute_force(n-2)

def test_against_brute_force():
    """Verify DP against brute force for small inputs"""
    for n in range(1, 15):
        assert climb_stairs(n) == brute_force(n)
</code></pre>
<ol start="5">
<li><strong>Trace execution</strong></li>
</ol>
<pre><code class="language-python">def dp_with_trace(n, memo=None):
    """Add tracing to see execution flow"""
    if memo is None:
        memo = {}

    print(f"Computing dp({n})")

    if n in memo:
        print(f"  -&gt; Found in memo: {memo[n]}")
        return memo[n]

    if n &lt;= 1:
        print(f"  -&gt; Base case: {n}")
        return n

    result = dp_with_trace(n-1, memo) + dp_with_trace(n-2, memo)
    memo[n] = result
    print(f"  -&gt; Computed dp({n}) = {result}")
    return result
</code></pre>
<h4 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h4>
<pre><code class="language-python">import time
import functools

def benchmark_dp_solutions():
    """Compare different DP approaches"""
    n = 30

    # Memoization
    start = time.time()
    @functools.lru_cache(None)
    def fib_memo(n):
        return n if n &lt;= 1 else fib_memo(n-1) + fib_memo(n-2)
    result1 = fib_memo(n)
    time1 = time.time() - start

    # Tabulation
    start = time.time()
    def fib_tab(n):
        if n &lt;= 1: return n
        dp = [0] * (n + 1)
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
    result2 = fib_tab(n)
    time2 = time.time() - start

    # Space-optimized
    start = time.time()
    def fib_opt(n):
        if n &lt;= 1: return n
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    result3 = fib_opt(n)
    time3 = time.time() - start

    print(f"Memoization: {time1:.6f}s")
    print(f"Tabulation:  {time2:.6f}s")
    print(f"Optimized:   {time3:.6f}s")
</code></pre>
<h3 id="optimization-checklist"><a class="header" href="#optimization-checklist">Optimization Checklist</a></h3>
<p>Before submitting your DP solution, verify:</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>State is minimal</strong>: No redundant dimensions</li>
<li><input disabled="" type="checkbox"> <strong>Base cases are correct</strong>: Handle edge cases (n=0, empty array, etc.)</li>
<li><input disabled="" type="checkbox"> <strong>Recurrence is complete</strong>: All transitions considered</li>
<li><input disabled="" type="checkbox"> <strong>Iteration order is correct</strong>: Smaller subproblems computed first</li>
<li><input disabled="" type="checkbox"> <strong>Space can be optimized</strong>: Check if rolling array applies</li>
<li><input disabled="" type="checkbox"> <strong>Integer overflow handled</strong>: Use modulo if needed</li>
<li><input disabled="" type="checkbox"> <strong>Time complexity is acceptable</strong>: Ensure it fits constraints</li>
<li><input disabled="" type="checkbox"> <strong>Tested on examples</strong>: Small inputs, edge cases, large inputs</li>
</ul>
<h2 id="real-world-applications"><a class="header" href="#real-world-applications">Real-World Applications</a></h2>
<h3 id="1-text-processing"><a class="header" href="#1-text-processing">1. Text Processing</a></h3>
<ul>
<li>Spell checkers (edit distance)</li>
<li>Diff tools (LCS)</li>
<li>Plagiarism detection (longest common substring)</li>
</ul>
<h3 id="2-computational-biology"><a class="header" href="#2-computational-biology">2. Computational Biology</a></h3>
<ul>
<li>DNA sequence alignment</li>
<li>Protein folding prediction</li>
<li>Gene prediction</li>
</ul>
<h3 id="3-resource-allocation"><a class="header" href="#3-resource-allocation">3. Resource Allocation</a></h3>
<ul>
<li>Memory management</li>
<li>Cache algorithms</li>
<li>Budget optimization</li>
</ul>
<h3 id="4-graphics-and-image-processing"><a class="header" href="#4-graphics-and-image-processing">4. Graphics and Image Processing</a></h3>
<ul>
<li>Seam carving (content-aware image resizing)</li>
<li>Image segmentation</li>
<li>Path finding in graphics</li>
</ul>
<h3 id="5-compiler-optimization"><a class="header" href="#5-compiler-optimization">5. Compiler Optimization</a></h3>
<ul>
<li>Register allocation</li>
<li>Code generation</li>
<li>Instruction scheduling</li>
</ul>
<h3 id="6-network-routing"><a class="header" href="#6-network-routing">6. Network Routing</a></h3>
<ul>
<li>Shortest paths with constraints</li>
<li>Network flow optimization</li>
<li>Bandwidth allocation</li>
</ul>
<h3 id="7-game-theory"><a class="header" href="#7-game-theory">7. Game Theory</a></h3>
<ul>
<li>Optimal game playing strategies</li>
<li>Move prediction</li>
<li>Score maximization</li>
</ul>
<h3 id="8-finance"><a class="header" href="#8-finance">8. Finance</a></h3>
<ul>
<li>Portfolio optimization</li>
<li>Option pricing</li>
<li>Risk management</li>
</ul>
<h3 id="9-machine-learning"><a class="header" href="#9-machine-learning">9. Machine Learning</a></h3>
<ul>
<li>Sequence alignment in NLP</li>
<li>Hidden Markov Models (Viterbi algorithm)</li>
<li>Reinforcement learning (value iteration, policy iteration)</li>
</ul>
<h2 id="advanced-case-studies"><a class="header" href="#advanced-case-studies">Advanced Case Studies</a></h2>
<h3 id="case-study-1-autocomplete-system"><a class="header" href="#case-study-1-autocomplete-system">Case Study 1: Autocomplete System</a></h3>
<p><strong>Problem</strong>: Design an autocomplete system that suggests top k sentences based on input.</p>
<p><strong>DP Application</strong>: Trie + DP for ranking.</p>
<pre><code class="language-python">class TrieNode:
    def __init__(self):
        self.children = {}
        self.sentences = []  # (sentence, frequency) pairs

class AutocompleteSystem:
    def __init__(self, sentences, times):
        self.root = TrieNode()
        self.current = self.root
        self.prefix = ""

        # Build trie with DP for top-k at each node
        for sentence, freq in zip(sentences, times):
            self._add_sentence(sentence, freq)

    def _add_sentence(self, sentence, freq):
        node = self.root
        for char in sentence:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
            # DP: maintain top k sentences at each node
            node.sentences.append((sentence, freq))
            node.sentences.sort(key=lambda x: (-x[1], x[0]))
            node.sentences = node.sentences[:3]  # Keep top 3

    def input(self, c):
        if c == '#':
            # Save sentence
            self._add_sentence(self.prefix, 1)
            self.prefix = ""
            self.current = self.root
            return []

        self.prefix += c
        if self.current and c in self.current.children:
            self.current = self.current.children[c]
            return [s for s, _ in self.current.sentences]
        else:
            self.current = None
            return []

# Time: O(k × L) per input, where L is sentence length
# Space: O(T) where T is total characters in trie
</code></pre>
<h3 id="case-study-2-video-encoding-optimization"><a class="header" href="#case-study-2-video-encoding-optimization">Case Study 2: Video Encoding Optimization</a></h3>
<p><strong>Problem</strong>: Optimize video encoding by selecting keyframes to minimize file size while maintaining quality.</p>
<p><strong>DP Application</strong>: Interval DP with quality constraints.</p>
<pre><code class="language-python">def optimize_video_encoding(frames, max_distance):
    """
    Select keyframes to minimize encoding cost
    frames[i] = quality score of frame i
    max_distance = maximum frames between keyframes
    """
    n = len(frames)
    # dp[i] = min cost to encode frames[0..i]
    dp = [float('inf')] * n
    keyframes = [[] for _ in range(n)]

    # Cost function: more distance between keyframes = lower quality
    def encoding_cost(start, end):
        distance = end - start
        if distance &gt; max_distance:
            return float('inf')
        # Cost increases with distance
        base_cost = distance * 10
        quality_loss = sum(frames[start+1:end+1]) * distance
        return base_cost + quality_loss

    # Base case
    dp[0] = 0
    keyframes[0] = [0]

    for i in range(1, n):
        # Try each possible previous keyframe
        for prev_keyframe in range(max(0, i - max_distance), i + 1):
            cost = encoding_cost(prev_keyframe, i)
            total_cost = (dp[prev_keyframe] if prev_keyframe &gt; 0 else 0) + cost

            if total_cost &lt; dp[i]:
                dp[i] = total_cost
                keyframes[i] = keyframes[prev_keyframe - 1] + [i] if prev_keyframe &gt; 0 else [i]

    return dp[n-1], keyframes[n-1]

# Time: O(n × max_distance), Space: O(n)
</code></pre>
<h3 id="case-study-3-supply-chain-optimization"><a class="header" href="#case-study-3-supply-chain-optimization">Case Study 3: Supply Chain Optimization</a></h3>
<p><strong>Problem</strong>: Minimize cost of ordering and storing inventory over time.</p>
<p><strong>DP Application</strong>: Inventory management with holding costs.</p>
<pre><code class="language-python">def optimize_inventory(demand, order_cost, holding_cost, capacity):
    """
    Optimize inventory orders over time
    demand[i] = demand in period i
    order_cost = fixed cost per order
    holding_cost = cost per unit per period
    capacity = warehouse capacity
    """
    n = len(demand)
    # dp[i] = min cost to satisfy demand for periods 0..i
    dp = [float('inf')] * n
    orders = [None] * n

    for i in range(n):
        # Try ordering for periods j to i in one order
        total_demand = 0
        for j in range(i, -1, -1):
            total_demand += demand[j]

            if total_demand &gt; capacity:
                break

            # Calculate holding cost for this order
            hold_cost = 0
            cumulative = 0
            for k in range(j, i + 1):
                cumulative += demand[k]
                # Hold cumulative units for (i - k) periods
                hold_cost += cumulative * holding_cost * (i - k)

            # Total cost
            prev_cost = dp[j-1] if j &gt; 0 else 0
            total = prev_cost + order_cost + hold_cost

            if total &lt; dp[i]:
                dp[i] = total
                orders[i] = (j, i, total_demand)

    # Reconstruct ordering strategy
    strategy = []
    i = n - 1
    while i &gt;= 0:
        strategy.append(orders[i])
        i = orders[i][0] - 1

    return dp[n-1], list(reversed(strategy))

# Time: O(n²), Space: O(n)
</code></pre>
<h3 id="case-study-4-route-planning-with-time-windows"><a class="header" href="#case-study-4-route-planning-with-time-windows">Case Study 4: Route Planning with Time Windows</a></h3>
<p><strong>Problem</strong>: Find optimal delivery route with time window constraints.</p>
<p><strong>DP Application</strong>: State includes time, making this a 2D DP problem.</p>
<pre><code class="language-python">def delivery_route_dp(locations, time_windows, travel_time):
    """
    Find optimal delivery sequence
    locations = list of delivery points
    time_windows[i] = (earliest, latest) time for location i
    travel_time[i][j] = time from location i to j
    """
    n = len(locations)
    # dp[mask][last][time] = min cost to visit locations in mask, ending at last, at time
    # Use dictionary for sparse storage
    dp = {}

    def solve(visited, last, current_time):
        state = (visited, last, current_time)
        if state in dp:
            return dp[state]

        # All locations visited
        if visited == (1 &lt;&lt; n) - 1:
            return 0

        min_cost = float('inf')

        # Try visiting each unvisited location
        for next_loc in range(n):
            if visited &amp; (1 &lt;&lt; next_loc):
                continue

            # Travel to next location
            arrival_time = current_time + travel_time[last][next_loc]
            earliest, latest = time_windows[next_loc]

            # Check if we can make the time window
            if arrival_time &lt;= latest:
                # Wait if we arrive early
                service_time = max(arrival_time, earliest)
                wait_cost = max(0, earliest - arrival_time)

                # Recurse
                future_cost = solve(
                    visited | (1 &lt;&lt; next_loc),
                    next_loc,
                    service_time + 1  # Service takes 1 unit
                )

                total_cost = wait_cost + future_cost
                min_cost = min(min_cost, total_cost)

        dp[state] = min_cost
        return min_cost

    # Start from depot (location 0) at time 0
    return solve(1, 0, 0)

# Time: O(n² × 2^n × T) where T is time range
# Space: O(2^n × T)
</code></pre>
<h3 id="case-study-5-natural-language-processing---text-segmentation"><a class="header" href="#case-study-5-natural-language-processing---text-segmentation">Case Study 5: Natural Language Processing - Text Segmentation</a></h3>
<p><strong>Problem</strong>: Segment text into words using a dictionary (Chinese word segmentation).</p>
<p><strong>DP Application</strong>: String DP with dictionary lookup.</p>
<pre><code class="language-python">def segment_text(text, dictionary, language_model):
    """
    Segment text into words optimally
    text = unsegmented text
    dictionary = set of valid words
    language_model = function giving probability of word sequence
    """
    n = len(text)
    # dp[i] = (max_prob, segmentation) for text[0..i]
    dp = [(0, [])] * (n + 1)
    dp[0] = (1.0, [])

    for i in range(1, n + 1):
        best_prob = 0
        best_seg = []

        # Try all possible last words
        for j in range(i):
            word = text[j:i]
            if word in dictionary:
                prev_prob, prev_seg = dp[j]
                # Use language model for word probability
                word_prob = language_model(prev_seg, word)
                total_prob = prev_prob * word_prob

                if total_prob &gt; best_prob:
                    best_prob = total_prob
                    best_seg = prev_seg + [word]

        dp[i] = (best_prob, best_seg)

    return dp[n][1]

# Example with simple language model
def simple_language_model(prev_words, new_word):
    """Simple unigram model"""
    # In practice, use bigram/trigram probabilities
    freq = {
        'hello': 0.01,
        'world': 0.008,
        'the': 0.05,
        # ... more word frequencies
    }
    return freq.get(new_word, 0.0001)

# Time: O(n² × D) where D is dictionary lookup time
# Space: O(n × W) where W is average segmentation length
</code></pre>
<h3 id="case-study-6-database-query-optimization"><a class="header" href="#case-study-6-database-query-optimization">Case Study 6: Database Query Optimization</a></h3>
<p><strong>Problem</strong>: Optimize join order for multiple database tables.</p>
<p><strong>DP Application</strong>: Bitmask DP for subset enumeration.</p>
<pre><code class="language-python">def optimize_join_order(tables, join_costs):
    """
    Find optimal order to join database tables
    tables = list of table names
    join_costs[i][j] = cost to join tables i and j
    """
    n = len(tables)
    # dp[mask] = (min_cost, join_order) for tables in mask
    dp = {}
    dp[0] = (0, [])

    # Initialize single tables
    for i in range(n):
        dp[1 &lt;&lt; i] = (0, [tables[i]])

    # Try all subsets
    for mask in range(1, 1 &lt;&lt; n):
        if mask not in dp:
            continue

        current_cost, current_order = dp[mask]

        # Try joining with each table not in mask
        for i in range(n):
            if mask &amp; (1 &lt;&lt; i):
                continue

            new_mask = mask | (1 &lt;&lt; i)

            # Calculate cost of joining table i
            join_cost = 0
            for j in range(n):
                if mask &amp; (1 &lt;&lt; j):
                    join_cost += join_costs[j][i]

            total_cost = current_cost + join_cost
            new_order = current_order + [tables[i]]

            if new_mask not in dp or total_cost &lt; dp[new_mask][0]:
                dp[new_mask] = (total_cost, new_order)

    full_mask = (1 &lt;&lt; n) - 1
    return dp[full_mask]

# Time: O(n² × 2^n), Space: O(2^n)
</code></pre>
<h3 id="case-study-7-image-seam-carving-content-aware-resizing"><a class="header" href="#case-study-7-image-seam-carving-content-aware-resizing">Case Study 7: Image Seam Carving (Content-Aware Resizing)</a></h3>
<p><strong>Problem</strong>: Resize image by removing least important seams.</p>
<p><strong>DP Application</strong>: Grid DP with energy minimization.</p>
<pre><code class="language-python">def seam_carving(image, energy_function):
    """
    Find minimum energy vertical seam for content-aware resizing
    image = 2D array of pixels
    energy_function = function to compute pixel importance
    """
    m, n = len(image), len(image[0])

    # Compute energy for each pixel
    energy = [[energy_function(image, i, j) for j in range(n)] for i in range(m)]

    # dp[i][j] = min energy to reach pixel (i, j)
    dp = [[float('inf')] * n for _ in range(m)]
    parent = [[None] * n for _ in range(m)]

    # Base case: first row
    for j in range(n):
        dp[0][j] = energy[0][j]

    # Fill DP table
    for i in range(1, m):
        for j in range(n):
            # Try coming from three possible parents
            for pj in range(max(0, j-1), min(n, j+2)):
                if dp[i-1][pj] + energy[i][j] &lt; dp[i][j]:
                    dp[i][j] = dp[i-1][pj] + energy[i][j]
                    parent[i][j] = pj

    # Find minimum in last row
    min_col = min(range(n), key=lambda j: dp[m-1][j])

    # Backtrack to find seam
    seam = []
    col = min_col
    for i in range(m-1, -1, -1):
        seam.append((i, col))
        if parent[i][col] is not None:
            col = parent[i][col]

    return list(reversed(seam)), dp[m-1][min_col]

def simple_energy(image, i, j):
    """Simple gradient-based energy function"""
    m, n = len(image), len(image[0])
    energy = 0

    # Horizontal gradient
    if j &gt; 0 and j &lt; n - 1:
        energy += abs(image[i][j+1] - image[i][j-1])

    # Vertical gradient
    if i &gt; 0 and i &lt; m - 1:
        energy += abs(image[i+1][j] - image[i-1][j])

    return energy

# Time: O(m × n), Space: O(m × n)
</code></pre>
<h2 id="practice-problems-by-difficulty"><a class="header" href="#practice-problems-by-difficulty">Practice Problems by Difficulty</a></h2>
<h3 id="beginner"><a class="header" href="#beginner">Beginner</a></h3>
<ol>
<li>Climbing Stairs (LeetCode 70)</li>
<li>Min Cost Climbing Stairs (LeetCode 746)</li>
<li>House Robber (LeetCode 198)</li>
<li>Maximum Subarray (LeetCode 53)</li>
<li>Best Time to Buy and Sell Stock (LeetCode 121)</li>
</ol>
<h3 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h3>
<ol>
<li>Longest Increasing Subsequence (LeetCode 300)</li>
<li>Coin Change (LeetCode 322)</li>
<li>Word Break (LeetCode 139)</li>
<li>Unique Paths (LeetCode 62)</li>
<li>Longest Common Subsequence (LeetCode 1143)</li>
<li>Edit Distance (LeetCode 72)</li>
<li>Partition Equal Subset Sum (LeetCode 416)</li>
<li>Decode Ways (LeetCode 91)</li>
</ol>
<h3 id="advanced"><a class="header" href="#advanced">Advanced</a></h3>
<ol>
<li>Burst Balloons (LeetCode 312)</li>
<li>Regular Expression Matching (LeetCode 10)</li>
<li>Wildcard Matching (LeetCode 44)</li>
<li>Distinct Subsequences (LeetCode 115)</li>
<li>Interleaving String (LeetCode 97)</li>
<li>Palindrome Partitioning II (LeetCode 132)</li>
<li>Best Time to Buy and Sell Stock IV (LeetCode 188)</li>
<li>Cherry Pickup (LeetCode 741)</li>
</ol>
<h3 id="expert"><a class="header" href="#expert">Expert</a></h3>
<ol>
<li>Minimum Window Subsequence (LeetCode 727)</li>
<li>Count Different Palindromic Subsequences (LeetCode 730)</li>
<li>Strange Printer (LeetCode 664)</li>
<li>Frog Jump (LeetCode 403)</li>
<li>Number of Music Playlists (LeetCode 920)</li>
</ol>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="when-to-use-dp"><a class="header" href="#when-to-use-dp">When to Use DP</a></h3>
<p>✅ <strong>Use DP when</strong>:</p>
<ul>
<li>Problem asks for optimum (max/min) or count</li>
<li>Decisions lead to subproblems with similar structure</li>
<li>Same subproblems appear multiple times</li>
<li>Problem has optimal substructure</li>
</ul>
<p>❌ <strong>Don’t use DP when</strong>:</p>
<ul>
<li>Problem needs actual combinations/permutations (use backtracking)</li>
<li>Greedy approach works</li>
<li>Problem is NP-complete without special structure</li>
<li>State space is too large</li>
</ul>
<h3 id="dp-vs-other-paradigms"><a class="header" href="#dp-vs-other-paradigms">DP vs Other Paradigms</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Paradigm</th><th>When to Use</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>DP</strong></td><td>Overlapping subproblems, optimal substructure</td><td>LCS, Knapsack</td></tr>
<tr><td><strong>Greedy</strong></td><td>Optimal substructure, greedy choice property</td><td>Huffman coding, Activity selection</td></tr>
<tr><td><strong>Divide &amp; Conquer</strong></td><td>Non-overlapping subproblems</td><td>Merge sort, Quick sort</td></tr>
<tr><td><strong>Backtracking</strong></td><td>Need all solutions, not just optimal</td><td>N-Queens, Sudoku</td></tr>
</tbody>
</table>
</div>
<h3 id="state-transition-patterns"><a class="header" href="#state-transition-patterns">State Transition Patterns</a></h3>
<pre><code class="language-python"># 1. Take or skip
dp[i] = max(skip, take)

# 2. Extend or reset
dp[i] = max(dp[i-1] + arr[i], arr[i])

# 3. Minimum of choices
dp[i] = min(choice1, choice2, ...)

# 4. Sum of ways
dp[i] = sum(dp[j] for j in valid_previous_states)

# 5. 2D combination
dp[i][j] = f(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
</code></pre>
<h2 id="eli10-explain-like-im-10"><a class="header" href="#eli10-explain-like-im-10">ELI10 (Explain Like I’m 10)</a></h2>
<p>Imagine you’re climbing a staircase and you can either take 1 step or 2 steps at a time. How many different ways can you reach the top?</p>
<p>You could try every single path (slow!), or you could be smart:</p>
<p>“To reach step 5, I either came from step 4 (one 1-step) or step 3 (one 2-step). So: ways(5) = ways(4) + ways(3)”</p>
<p>That’s DP! Instead of redoing all the work, you remember answers to smaller problems and build up to the big answer. Like remembering your times tables instead of counting on your fingers every time!</p>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<h3 id="online-judges"><a class="header" href="#online-judges">Online Judges</a></h3>
<ul>
<li><a href="https://leetcode.com/tag/dynamic-programming/">LeetCode DP Problems</a> - 500+ problems</li>
<li><a href="https://codeforces.com/problemset/tags/dp">Codeforces DP Tag</a> - Competitive programming</li>
<li><a href="https://atcoder.jp/contests/dp">AtCoder DP Contest</a> - Educational DP problems</li>
</ul>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<ul>
<li>“Introduction to Algorithms” (CLRS) - Chapter 15</li>
<li>“Algorithm Design” by Kleinberg &amp; Tardos - Chapter 6</li>
<li>“Dynamic Programming for Coding Interviews” by Meenakshi &amp; Kamal Rawat</li>
</ul>
<h3 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h3>
<ul>
<li><a href="https://www.geeksforgeeks.org/dynamic-programming/">GeeksforGeeks DP Tutorial</a></li>
<li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/">TopCoder DP Tutorial</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr">Tushar Roy’s YouTube DP Playlist</a></li>
</ul>
<h3 id="visualizations"><a class="header" href="#visualizations">Visualizations</a></h3>
<ul>
<li><a href="https://visualgo.net/en/recursion">VisuAlgo Dynamic Programming</a> - Interactive visualizations</li>
<li><a href="https://algorithm-visualizer.org/">Algorithm Visualizer</a></li>
</ul>
<h3 id="practice-platforms"><a class="header" href="#practice-platforms">Practice Platforms</a></h3>
<ul>
<li><a href="https://neetcode.io/roadmap">NeetCode DP Roadmap</a> - Curated problem list</li>
<li><a href="https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU">Blind 75</a> - Essential interview problems</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../algorithms/recursion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../algorithms/backtracking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../algorithms/recursion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../algorithms/backtracking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
