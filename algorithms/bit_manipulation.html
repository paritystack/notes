<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bit Manipulation - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-4bbf961e.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-e85e57c5.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="bit-manipulation"><a class="header" href="#bit-manipulation">Bit Manipulation</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#eli10-explanation">ELI10 Explanation</a></li>
<li><a href="#fundamentals">Fundamentals</a>
<ul>
<li><a href="#binary-representation">Binary Representation</a></li>
<li><a href="#bitwise-operators">Bitwise Operators</a></li>
</ul>
</li>
<li><a href="#common-bit-tricks">Common Bit Tricks</a>
<ul>
<li><a href="#check-if-power-of-2">Check if Power of 2</a></li>
<li><a href="#count-set-bits">Count Set Bits</a></li>
<li><a href="#get-set-clear-toggle-bits">Get, Set, Clear, Toggle Bits</a></li>
<li><a href="#xor-properties">XOR Properties</a></li>
<li><a href="#isolate-rightmost-set-bit">Isolate Rightmost Set Bit</a></li>
<li><a href="#remove-rightmost-set-bit">Remove Rightmost Set Bit</a></li>
</ul>
</li>
<li><a href="#advanced-techniques">Advanced Techniques</a>
<ul>
<li><a href="#bit-masking">Bit Masking</a></li>
<li><a href="#gray-code">Gray Code</a></li>
<li><a href="#bit-packing">Bit Packing</a></li>
</ul>
</li>
<li><a href="#common-patterns">Common Patterns</a></li>
<li><a href="#interview-problems">Interview Problems</a></li>
<li><a href="#complexity-analysis">Complexity Analysis</a></li>
<li><a href="#when-to-use">When to Use</a></li>
<li><a href="#common-pitfalls">Common Pitfalls</a></li>
<li><a href="#practice-problems">Practice Problems</a></li>
<li><a href="#additional-resources">Additional Resources</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Bit manipulation involves working directly with bits (0s and 1s) to perform operations efficiently. It’s a fundamental technique used in:</p>
<ul>
<li>Low-level programming (device drivers, embedded systems)</li>
<li>Performance optimization</li>
<li>Cryptography and hashing</li>
<li>Compression algorithms</li>
<li>Competitive programming</li>
<li>Interview problems</li>
</ul>
<p>Bit manipulation can often solve problems with <strong>O(1) space</strong> and very fast execution times.</p>
<h2 id="eli10-explanation"><a class="header" href="#eli10-explanation">ELI10 Explanation</a></h2>
<p>Imagine you have a row of light switches, and each switch can be either ON (1) or OFF (0).</p>
<pre><code>Position: 7 6 5 4 3 2 1 0
Switch:   0 1 0 1 1 0 1 0  (This is the number 90 in binary!)
</code></pre>
<p>Bit manipulation is like having special tools to work with these switches:</p>
<ul>
<li><strong>AND</strong> - Both switches must be ON for the result to be ON</li>
<li><strong>OR</strong> - At least one switch must be ON</li>
<li><strong>XOR</strong> - Exactly one switch must be ON (not both, not neither)</li>
<li><strong>NOT</strong> - Flip all switches</li>
<li><strong>Shift</strong> - Slide all switches left or right</li>
</ul>
<p>These simple operations let us do amazing things super fast!</p>
<h2 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h2>
<h3 id="binary-representation"><a class="header" href="#binary-representation">Binary Representation</a></h3>
<p>Every integer can be represented in binary (base 2):</p>
<pre><code class="language-python"># Decimal to Binary examples
5  = 0b00000101  # 4 + 1
10 = 0b00001010  # 8 + 2
15 = 0b00001111  # 8 + 4 + 2 + 1
16 = 0b00010000  # 16

def decimal_to_binary(n: int) -&gt; str:
    """Convert decimal to binary string."""
    if n == 0:
        return "0"

    binary = ""
    while n &gt; 0:
        binary = str(n &amp; 1) + binary
        n &gt;&gt;= 1
    return binary

# Python built-in
print(bin(10))  # '0b1010'
print(bin(10)[2:])  # '1010' (remove '0b' prefix)
</code></pre>
<h3 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h3>
<pre><code class="language-python"># Basic operators (using 8-bit representation for clarity)
a = 0b00001100  # 12
b = 0b00001010  # 10

# AND (&amp;) - Both bits must be 1
print(bin(a &amp; b))  # 0b00001000 = 8
# 1100
# 1010 &amp;
# ----
# 1000

# OR (|) - At least one bit must be 1
print(bin(a | b))  # 0b00001110 = 14
# 1100
# 1010 |
# ----
# 1110

# XOR (^) - Exactly one bit must be 1
print(bin(a ^ b))  # 0b00000110 = 6
# 1100
# 1010 ^
# ----
# 0110

# NOT (~) - Flip all bits (careful: Python uses signed integers)
print(bin(~a &amp; 0xFF))  # 0b11110011 = 243 (for 8-bit)

# Left Shift (&lt;&lt;) - Multiply by 2^n
print(bin(a &lt;&lt; 2))  # 0b00110000 = 48 (12 * 4)

# Right Shift (&gt;&gt;) - Divide by 2^n
print(bin(a &gt;&gt; 2))  # 0b00000011 = 3 (12 // 4)
</code></pre>
<h2 id="common-bit-tricks"><a class="header" href="#common-bit-tricks">Common Bit Tricks</a></h2>
<h3 id="check-if-power-of-2"><a class="header" href="#check-if-power-of-2">Check if Power of 2</a></h3>
<p>A number is a power of 2 if it has exactly one bit set.</p>
<pre><code class="language-python">def is_power_of_two(n: int) -&gt; bool:
    """
    Check if n is a power of 2.

    Power of 2: exactly one bit is set
    Examples:
        8  = 1000
        7  = 0111
        8&amp;7 = 0000

    Time: O(1), Space: O(1)
    """
    return n &gt; 0 and (n &amp; (n - 1)) == 0

# Examples
print(is_power_of_two(8))   # True  (2^3)
print(is_power_of_two(16))  # True  (2^4)
print(is_power_of_two(18))  # False
print(is_power_of_two(1))   # True  (2^0)

# Why it works:
# Power of 2:     1000 (8)
# n - 1:          0111 (7)
# n &amp; (n-1):      0000
#
# Not power of 2: 1010 (10)
# n - 1:          1001 (9)
# n &amp; (n-1):      1000 (not zero!)
</code></pre>
<h3 id="count-set-bits"><a class="header" href="#count-set-bits">Count Set Bits</a></h3>
<p>Count the number of 1s in binary representation (Hamming Weight).</p>
<pre><code class="language-python">def count_set_bits_naive(n: int) -&gt; int:
    """
    Count set bits by checking each bit.
    Time: O(log n) - number of bits
    """
    count = 0
    while n:
        count += n &amp; 1
        n &gt;&gt;= 1
    return count

def count_set_bits_kernighan(n: int) -&gt; int:
    """
    Brian Kernighan's Algorithm - faster for sparse bits.
    Each operation removes the rightmost set bit.

    Time: O(k) where k = number of set bits
    """
    count = 0
    while n:
        n &amp;= (n - 1)  # Remove rightmost set bit
        count += 1
    return count

# Example trace:
# n = 10 = 1010
# Iteration 1: n = 1010 &amp; 1001 = 1000, count = 1
# Iteration 2: n = 1000 &amp; 0111 = 0000, count = 2

def count_set_bits_builtin(n: int) -&gt; int:
    """Use Python's built-in bin() and count()."""
    return bin(n).count('1')

# Lookup table method (fastest for repeated calls)
def count_set_bits_lookup(n: int) -&gt; int:
    """
    Use precomputed table for 8-bit chunks.
    Time: O(1) for 32-bit numbers
    """
    # Precompute for 0-255
    table = [bin(i).count('1') for i in range(256)]

    count = 0
    while n:
        count += table[n &amp; 0xFF]  # Check last 8 bits
        n &gt;&gt;= 8  # Move to next 8 bits
    return count

# Examples
print(count_set_bits_kernighan(15))  # 4 (1111)
print(count_set_bits_kernighan(7))   # 3 (0111)
print(count_set_bits_kernighan(8))   # 1 (1000)
</code></pre>
<h3 id="get-set-clear-toggle-bits"><a class="header" href="#get-set-clear-toggle-bits">Get, Set, Clear, Toggle Bits</a></h3>
<pre><code class="language-python">def get_bit(num: int, i: int) -&gt; int:
    """
    Get the bit at position i (0-indexed from right).
    Returns 0 or 1.
    """
    return (num &gt;&gt; i) &amp; 1

def set_bit(num: int, i: int) -&gt; int:
    """Set the bit at position i to 1."""
    return num | (1 &lt;&lt; i)

def clear_bit(num: int, i: int) -&gt; int:
    """Set the bit at position i to 0."""
    return num &amp; ~(1 &lt;&lt; i)

def toggle_bit(num: int, i: int) -&gt; int:
    """Flip the bit at position i."""
    return num ^ (1 &lt;&lt; i)

def update_bit(num: int, i: int, value: int) -&gt; int:
    """
    Update bit at position i to given value (0 or 1).
    """
    # Clear the bit, then OR with shifted value
    mask = ~(1 &lt;&lt; i)
    return (num &amp; mask) | (value &lt;&lt; i)

# Example usage
n = 0b01010110  # 86

print(bin(get_bit(n, 2)))        # 1
print(bin(set_bit(n, 0)))        # 0b01010111 (87)
print(bin(clear_bit(n, 1)))      # 0b01010100 (84)
print(bin(toggle_bit(n, 0)))     # 0b01010111 (87)
print(bin(update_bit(n, 3, 0)))  # 0b01010110 -&gt; 0b01010110

# Visual example:
# n =           01010110
# Position:     76543210
#
# get_bit(n, 2):    Check bit 2 -&gt; 1
# set_bit(n, 0):    01010111 (set rightmost to 1)
# clear_bit(n, 1):  01010100 (clear bit 1)
# toggle_bit(n, 0): 01010111 (flip bit 0)
</code></pre>
<h3 id="xor-properties"><a class="header" href="#xor-properties">XOR Properties</a></h3>
<p>XOR has unique mathematical properties that make it extremely useful.</p>
<pre><code class="language-python">"""
XOR Properties:
1. x ^ 0 = x           (Identity)
2. x ^ x = 0           (Self-inverse)
3. x ^ y = y ^ x       (Commutative)
4. (x ^ y) ^ z = x ^ (y ^ z)  (Associative)
5. If a ^ b = c, then a ^ c = b and b ^ c = a (Reversible)
"""

def find_unique_number(nums: list[int]) -&gt; int:
    """
    Find the unique number when all others appear twice.
    Uses XOR property: x ^ x = 0

    Example: [4, 1, 2, 1, 2] -&gt; 4
    4 ^ 1 ^ 2 ^ 1 ^ 2 = 4 ^ (1^1) ^ (2^2) = 4 ^ 0 ^ 0 = 4

    Time: O(n), Space: O(1)
    """
    result = 0
    for num in nums:
        result ^= num
    return result

def swap_numbers(a: int, b: int) -&gt; tuple[int, int]:
    """
    Swap two numbers without temporary variable.
    Uses XOR property.
    """
    print(f"Before: a={a}, b={b}")
    a = a ^ b
    b = a ^ b  # b = (a^b)^b = a
    a = a ^ b  # a = (a^b)^a = b
    print(f"After: a={a}, b={b}")
    return a, b

def find_two_unique_numbers(nums: list[int]) -&gt; list[int]:
    """
    Find two unique numbers when all others appear twice.

    Example: [1, 2, 1, 3, 2, 5] -&gt; [3, 5]

    Strategy:
    1. XOR all numbers: result = 3 ^ 5
    2. Find any set bit in result (diff between 3 and 5)
    3. Partition numbers by that bit
    4. XOR each partition separately

    Time: O(n), Space: O(1)
    """
    # Step 1: XOR all numbers
    xor_all = 0
    for num in nums:
        xor_all ^= num
    # xor_all now contains a ^ b (the two unique numbers)

    # Step 2: Find rightmost set bit (where a and b differ)
    rightmost_bit = xor_all &amp; (-xor_all)

    # Step 3: Partition and XOR
    num1, num2 = 0, 0
    for num in nums:
        if num &amp; rightmost_bit:
            num1 ^= num
        else:
            num2 ^= num

    return [num1, num2]

# Examples
print(find_unique_number([4, 1, 2, 1, 2]))  # 4
print(find_two_unique_numbers([1, 2, 1, 3, 2, 5]))  # [3, 5]
swap_numbers(5, 10)  # Swaps to (10, 5)
</code></pre>
<h3 id="isolate-rightmost-set-bit"><a class="header" href="#isolate-rightmost-set-bit">Isolate Rightmost Set Bit</a></h3>
<pre><code class="language-python">def isolate_rightmost_set_bit(n: int) -&gt; int:
    """
    Isolate the rightmost (least significant) set bit.

    Uses: n &amp; (-n) or n &amp; (~n + 1)

    Why it works:
    -n is the two's complement (invert bits and add 1)

    Example: n = 12 = 1100
    -n = -(1100) = 0011 + 1 = 0100
    n &amp; -n = 1100 &amp; 0100 = 0100 = 4
    """
    return n &amp; (-n)

# Examples with visualization
def visualize_isolate(n: int):
    result = n &amp; (-n)
    print(f"n     = {n:4d} = {bin(n)}")
    print(f"-n    = {-n:4d} = {bin(-n &amp; 0xFF)}")
    print(f"n&amp;-n  = {result:4d} = {bin(result)}")
    print()

visualize_isolate(12)  # Isolates bit at position 2 (value 4)
visualize_isolate(10)  # Isolates bit at position 1 (value 2)
visualize_isolate(7)   # Isolates bit at position 0 (value 1)

# Application: Find position of rightmost set bit
def rightmost_set_bit_position(n: int) -&gt; int:
    """
    Find position (0-indexed) of rightmost set bit.
    Returns -1 if no bits are set.
    """
    if n == 0:
        return -1

    isolated = n &amp; (-n)
    position = 0
    while isolated &gt; 1:
        isolated &gt;&gt;= 1
        position += 1
    return position

print(rightmost_set_bit_position(12))  # 2
print(rightmost_set_bit_position(10))  # 1
</code></pre>
<h3 id="remove-rightmost-set-bit"><a class="header" href="#remove-rightmost-set-bit">Remove Rightmost Set Bit</a></h3>
<pre><code class="language-python">def remove_rightmost_set_bit(n: int) -&gt; int:
    """
    Remove the rightmost (least significant) set bit.

    Uses: n &amp; (n - 1)

    This is the key operation in Brian Kernighan's algorithm!
    """
    return n &amp; (n - 1)

# Examples with visualization
def visualize_remove(n: int):
    result = n &amp; (n - 1)
    print(f"n     = {n:4d} = {bin(n)}")
    print(f"n-1   = {n-1:4d} = {bin(n-1)}")
    print(f"n&amp;n-1 = {result:4d} = {bin(result)}")
    print()

visualize_remove(12)  # 1100 -&gt; 1000 (removes rightmost 1)
visualize_remove(10)  # 1010 -&gt; 1000 (removes rightmost 1)
visualize_remove(7)   # 0111 -&gt; 0110 (removes rightmost 1)

# Application: Check if n is power of 4
def is_power_of_four(n: int) -&gt; bool:
    """
    Check if n is a power of 4.

    Strategy:
    1. Must be power of 2: n &amp; (n-1) == 0
    2. The set bit must be at even position (0, 2, 4, 6...)
    3. Use mask 0x55555555 = 0b01010101010101010101010101010101
    """
    if n &lt;= 0:
        return False

    # Check power of 2
    if n &amp; (n - 1) != 0:
        return False

    # Check bit at even position
    return (n &amp; 0x55555555) != 0

print(is_power_of_four(16))  # True (2^4)
print(is_power_of_four(8))   # False (2^3)
print(is_power_of_four(64))  # True (2^6)
</code></pre>
<h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<h3 id="bit-masking"><a class="header" href="#bit-masking">Bit Masking</a></h3>
<p>Using bits to represent sets and perform set operations efficiently.</p>
<pre><code class="language-python">class BitMask:
    """
    Represent a set using bits. Each bit position represents an element.
    Perfect for small universes (0-63 with int64).

    Example: Set {0, 2, 5} = 0b00100101 = 37
    """

    @staticmethod
    def add_element(mask: int, elem: int) -&gt; int:
        """Add element to set."""
        return mask | (1 &lt;&lt; elem)

    @staticmethod
    def remove_element(mask: int, elem: int) -&gt; int:
        """Remove element from set."""
        return mask &amp; ~(1 &lt;&lt; elem)

    @staticmethod
    def contains(mask: int, elem: int) -&gt; bool:
        """Check if element is in set."""
        return (mask &amp; (1 &lt;&lt; elem)) != 0

    @staticmethod
    def union(mask1: int, mask2: int) -&gt; int:
        """Union of two sets."""
        return mask1 | mask2

    @staticmethod
    def intersection(mask1: int, mask2: int) -&gt; int:
        """Intersection of two sets."""
        return mask1 &amp; mask2

    @staticmethod
    def difference(mask1: int, mask2: int) -&gt; int:
        """Set difference (elements in mask1 but not mask2)."""
        return mask1 &amp; ~mask2

    @staticmethod
    def subset(mask1: int, mask2: int) -&gt; bool:
        """Check if mask1 is subset of mask2."""
        return (mask1 &amp; mask2) == mask1

    @staticmethod
    def size(mask: int) -&gt; int:
        """Count elements in set."""
        count = 0
        while mask:
            mask &amp;= mask - 1
            count += 1
        return count

    @staticmethod
    def iterate_subsets(mask: int) -&gt; list[int]:
        """
        Generate all subsets of the given mask.
        Uses the trick: subset = (subset - 1) &amp; mask
        """
        subsets = []
        subset = mask
        while True:
            subsets.append(subset)
            if subset == 0:
                break
            subset = (subset - 1) &amp; mask
        return subsets

# Example usage
mask = 0  # Empty set
mask = BitMask.add_element(mask, 0)  # {0}
mask = BitMask.add_element(mask, 2)  # {0, 2}
mask = BitMask.add_element(mask, 5)  # {0, 2, 5}

print(f"Set: {bin(mask)}")  # 0b100101
print(f"Contains 2: {BitMask.contains(mask, 2)}")  # True
print(f"Contains 3: {BitMask.contains(mask, 3)}")  # False
print(f"Size: {BitMask.size(mask)}")  # 3

# Subsets of {0, 2}
subsets = BitMask.iterate_subsets(0b101)
print(f"Subsets: {[bin(s) for s in subsets]}")
# [0b101, 0b100, 0b1, 0b0] = [{0,2}, {2}, {0}, {}]
</code></pre>
<h3 id="gray-code"><a class="header" href="#gray-code">Gray Code</a></h3>
<p>A sequence where consecutive numbers differ by exactly one bit.</p>
<pre><code class="language-python">def generate_gray_code(n: int) -&gt; list[int]:
    """
    Generate n-bit Gray code sequence.

    Gray code property: consecutive numbers differ by 1 bit.
    Formula: gray(i) = i ^ (i &gt;&gt; 1)

    Time: O(2^n), Space: O(2^n)
    """
    result = []
    for i in range(1 &lt;&lt; n):  # 2^n numbers
        gray = i ^ (i &gt;&gt; 1)
        result.append(gray)
    return result

def gray_to_binary(gray: int) -&gt; int:
    """Convert Gray code to binary."""
    binary = gray
    while gray &gt; 0:
        gray &gt;&gt;= 1
        binary ^= gray
    return binary

# Example: 3-bit Gray code
gray_codes = generate_gray_code(3)
print("Gray Code Sequence:")
for i, gray in enumerate(gray_codes):
    print(f"{i}: {bin(gray)[2:].zfill(3)} (binary: {bin(i)[2:].zfill(3)})")

# Output:
# 0: 000 (binary: 000)
# 1: 001 (binary: 001) - differs by 1 bit from previous
# 2: 011 (binary: 010) - differs by 1 bit from previous
# 3: 010 (binary: 011) - differs by 1 bit from previous
# 4: 110 (binary: 100)
# 5: 111 (binary: 101)
# 6: 101 (binary: 110)
# 7: 100 (binary: 111)
</code></pre>
<h3 id="bit-packing"><a class="header" href="#bit-packing">Bit Packing</a></h3>
<p>Store multiple small values in a single integer.</p>
<pre><code class="language-python">class BitPacker:
    """
    Pack multiple values into a single integer.
    Useful for state compression in DP problems.

    Example: Store RGB color (each 0-255) in one int
    """

    @staticmethod
    def pack_rgb(r: int, g: int, b: int) -&gt; int:
        """
        Pack 3 color values (0-255) into one integer.
        Format: 0xRRGGBB
        """
        return (r &lt;&lt; 16) | (g &lt;&lt; 8) | b

    @staticmethod
    def unpack_rgb(color: int) -&gt; tuple[int, int, int]:
        """Extract RGB values from packed integer."""
        r = (color &gt;&gt; 16) &amp; 0xFF
        g = (color &gt;&gt; 8) &amp; 0xFF
        b = color &amp; 0xFF
        return (r, g, b)

    @staticmethod
    def pack_coordinates(x: int, y: int) -&gt; int:
        """
        Pack 2D coordinates (assuming 16-bit each).
        Useful for memoization in grid problems.
        """
        return (x &lt;&lt; 16) | y

    @staticmethod
    def unpack_coordinates(packed: int) -&gt; tuple[int, int]:
        """Extract coordinates from packed integer."""
        x = (packed &gt;&gt; 16) &amp; 0xFFFF
        y = packed &amp; 0xFFFF
        return (x, y)

# Example usage
color = BitPacker.pack_rgb(255, 128, 64)
print(f"Packed color: {hex(color)}")  # 0xff8040
r, g, b = BitPacker.unpack_rgb(color)
print(f"RGB: ({r}, {g}, {b})")  # (255, 128, 64)

# State compression for DP
def unique_paths_bitmask(grid: list[list[int]]) -&gt; int:
    """
    Example: Use bitmask to represent visited cells.
    For a 4x4 grid, we can use 16 bits to track visits.
    """
    m, n = len(grid), len(grid[0])

    # Pack (x, y, visited_mask) into memoization key
    memo = {}

    def dfs(x: int, y: int, visited: int) -&gt; int:
        if x == m - 1 and y == n - 1:
            return 1

        # Pack state for memoization
        state = (x &lt;&lt; 20) | (y &lt;&lt; 10) | visited
        if state in memo:
            return memo[state]

        paths = 0
        for dx, dy in [(0, 1), (1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 &lt;= nx &lt; m and 0 &lt;= ny &lt; n:
                cell_bit = nx * n + ny
                if not (visited &amp; (1 &lt;&lt; cell_bit)):
                    new_visited = visited | (1 &lt;&lt; cell_bit)
                    paths += dfs(nx, ny, new_visited)

        memo[state] = paths
        return paths

    return dfs(0, 0, 1)  # Start with (0,0) visited
</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="pattern-1-toggleflip-bits-in-range"><a class="header" href="#pattern-1-toggleflip-bits-in-range">Pattern 1: Toggle/Flip Bits in Range</a></h3>
<pre><code class="language-python">def flip_bits_in_range(n: int, left: int, right: int) -&gt; int:
    """
    Flip bits from position left to right (0-indexed).

    Example: n = 0b10101 (21), flip bits 1-3
    Result:  0b11011 (27)
    """
    # Create mask: 1s in range [left, right]
    mask = ((1 &lt;&lt; (right - left + 1)) - 1) &lt;&lt; left
    return n ^ mask

print(bin(flip_bits_in_range(0b10101, 1, 3)))  # 0b11011
</code></pre>
<h3 id="pattern-2-find-missing-number"><a class="header" href="#pattern-2-find-missing-number">Pattern 2: Find Missing Number</a></h3>
<pre><code class="language-python">def find_missing_number(nums: list[int]) -&gt; int:
    """
    Find missing number in array [0, n].
    Uses XOR: x ^ x = 0

    Example: [3, 0, 1] -&gt; 2 is missing

    Time: O(n), Space: O(1)
    """
    result = len(nums)
    for i, num in enumerate(nums):
        result ^= i ^ num
    return result

# Alternative: XOR all numbers 0 to n with array elements
def find_missing_number_v2(nums: list[int]) -&gt; int:
    """Same problem, clearer logic."""
    xor_all = 0
    xor_array = 0

    for i in range(len(nums) + 1):
        xor_all ^= i

    for num in nums:
        xor_array ^= num

    return xor_all ^ xor_array

print(find_missing_number([3, 0, 1]))  # 2
print(find_missing_number([9,6,4,2,3,5,7,0,1]))  # 8
</code></pre>
<h3 id="pattern-3-reverse-bits"><a class="header" href="#pattern-3-reverse-bits">Pattern 3: Reverse Bits</a></h3>
<pre><code class="language-python">def reverse_bits(n: int) -&gt; int:
    """
    Reverse bits of a 32-bit unsigned integer.

    Example: 00000010100101000001111010011100
          -&gt; 00111001011110000010100101000000

    Time: O(1), Space: O(1)
    """
    result = 0
    for i in range(32):
        # Get bit from right, add to left
        result = (result &lt;&lt; 1) | (n &amp; 1)
        n &gt;&gt;= 1
    return result

# Optimized version using divide and conquer
def reverse_bits_optimized(n: int) -&gt; int:
    """
    Reverse bits in O(log(bits)) operations.
    Uses divide and conquer approach.
    """
    # Swap adjacent bits
    n = ((n &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1)
    # Swap adjacent pairs
    n = ((n &amp; 0xcccccccc) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2)
    # Swap adjacent nibbles
    n = ((n &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4)
    # Swap adjacent bytes
    n = ((n &amp; 0xff00ff00) &gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8)
    # Swap adjacent 2-bytes
    n = (n &gt;&gt; 16) | (n &lt;&lt; 16)

    return n &amp; 0xFFFFFFFF  # Ensure 32-bit

print(bin(reverse_bits(0b00000010100101000001111010011100)))
</code></pre>
<h3 id="pattern-4-generate-all-subsets"><a class="header" href="#pattern-4-generate-all-subsets">Pattern 4: Generate All Subsets</a></h3>
<pre><code class="language-python">def generate_subsets(nums: list[int]) -&gt; list[list[int]]:
    """
    Generate all subsets using bit manipulation.
    For n elements, there are 2^n subsets.

    Each subset corresponds to a binary number:
    - If bit i is set, include nums[i]

    Time: O(n * 2^n), Space: O(n * 2^n)
    """
    n = len(nums)
    subsets = []

    # Iterate through all possible bit patterns
    for mask in range(1 &lt;&lt; n):  # 2^n patterns
        subset = []
        for i in range(n):
            # Check if i-th bit is set
            if mask &amp; (1 &lt;&lt; i):
                subset.append(nums[i])
        subsets.append(subset)

    return subsets

# Example with trace
def generate_subsets_traced(nums: list[int]) -&gt; list[list[int]]:
    """Generate subsets with detailed trace."""
    n = len(nums)
    subsets = []

    print(f"Generating subsets for {nums}")
    print(f"Total subsets: {1 &lt;&lt; n}")
    print()

    for mask in range(1 &lt;&lt; n):
        subset = []
        print(f"Mask: {mask:03b}", end=" -&gt; ")

        for i in range(n):
            if mask &amp; (1 &lt;&lt; i):
                subset.append(nums[i])
                print(f"nums[{i}]={nums[i]}", end=" ")

        subsets.append(subset)
        print(f"= {subset}")

    return subsets

# Example
result = generate_subsets([1, 2, 3])
print(f"\nAll subsets of [1,2,3]: {result}")
# [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]

# With trace for [1, 2]
generate_subsets_traced([1, 2])
</code></pre>
<h2 id="interview-problems"><a class="header" href="#interview-problems">Interview Problems</a></h2>
<h3 id="problem-1-single-number"><a class="header" href="#problem-1-single-number">Problem 1: Single Number</a></h3>
<pre><code class="language-python">def single_number(nums: list[int]) -&gt; int:
    """
    LeetCode 136: Every element appears twice except one.
    Find the single one.

    Solution: XOR all numbers (duplicates cancel out).
    Time: O(n), Space: O(1)
    """
    result = 0
    for num in nums:
        result ^= num
    return result
</code></pre>
<h3 id="problem-2-single-number-iii"><a class="header" href="#problem-2-single-number-iii">Problem 2: Single Number III</a></h3>
<pre><code class="language-python">def single_number_iii(nums: list[int]) -&gt; list[int]:
    """
    LeetCode 260: Every element appears twice except two.
    Find both single numbers.

    Time: O(n), Space: O(1)
    """
    # Already implemented above in XOR Properties section
    return find_two_unique_numbers(nums)
</code></pre>
<h3 id="problem-3-maximum-xor-of-two-numbers"><a class="header" href="#problem-3-maximum-xor-of-two-numbers">Problem 3: Maximum XOR of Two Numbers</a></h3>
<pre><code class="language-python">class TrieNode:
    def __init__(self):
        self.children = {}

def find_maximum_xor(nums: list[int]) -&gt; int:
    """
    LeetCode 421: Find maximum XOR of two numbers in array.

    Strategy: Build Trie of binary representations, then for each
    number, try to find the path that maximizes XOR (choose opposite bits).

    Time: O(n * 32), Space: O(n * 32)
    """
    root = TrieNode()

    # Build Trie (32 bits per number)
    for num in nums:
        node = root
        for i in range(31, -1, -1):
            bit = (num &gt;&gt; i) &amp; 1
            if bit not in node.children:
                node.children[bit] = TrieNode()
            node = node.children[bit]

    max_xor = 0

    # For each number, find maximum XOR
    for num in nums:
        node = root
        current_xor = 0

        for i in range(31, -1, -1):
            bit = (num &gt;&gt; i) &amp; 1
            # Try to go opposite direction for maximum XOR
            toggled_bit = 1 - bit

            if toggled_bit in node.children:
                current_xor |= (1 &lt;&lt; i)
                node = node.children[toggled_bit]
            else:
                node = node.children[bit]

        max_xor = max(max_xor, current_xor)

    return max_xor

print(find_maximum_xor([3, 10, 5, 25, 2, 8]))  # 28 (5 ^ 25)
</code></pre>
<h3 id="problem-4-counting-bits"><a class="header" href="#problem-4-counting-bits">Problem 4: Counting Bits</a></h3>
<pre><code class="language-python">def counting_bits(n: int) -&gt; list[int]:
    """
    LeetCode 338: Count set bits for all numbers 0 to n.

    DP approach: bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)
    - i &gt;&gt; 1: remove rightmost bit
    - i &amp; 1: check if rightmost bit is 1

    Time: O(n), Space: O(n)
    """
    bits = [0] * (n + 1)
    for i in range(1, n + 1):
        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)
    return bits

# Alternative: bits[i] = bits[i &amp; (i-1)] + 1
def counting_bits_v2(n: int) -&gt; list[int]:
    """Using Brian Kernighan's insight."""
    bits = [0] * (n + 1)
    for i in range(1, n + 1):
        bits[i] = bits[i &amp; (i - 1)] + 1
    return bits

print(counting_bits(5))  # [0, 1, 1, 2, 1, 2]
</code></pre>
<h3 id="problem-5-utf-8-validation"><a class="header" href="#problem-5-utf-8-validation">Problem 5: UTF-8 Validation</a></h3>
<pre><code class="language-python">def valid_utf8(data: list[int]) -&gt; bool:
    """
    LeetCode 393: Validate UTF-8 encoding.

    UTF-8 rules:
    - 1-byte: 0xxxxxxx
    - 2-byte: 110xxxxx 10xxxxxx
    - 3-byte: 1110xxxx 10xxxxxx 10xxxxxx
    - 4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

    Time: O(n), Space: O(1)
    """
    def get_byte_count(byte: int) -&gt; int:
        """Get number of bytes in this UTF-8 character."""
        if (byte &gt;&gt; 7) == 0b0:
            return 1
        elif (byte &gt;&gt; 5) == 0b110:
            return 2
        elif (byte &gt;&gt; 4) == 0b1110:
            return 3
        elif (byte &gt;&gt; 3) == 0b11110:
            return 4
        else:
            return 0  # Invalid

    i = 0
    while i &lt; len(data):
        byte_count = get_byte_count(data[i])

        if byte_count == 0 or i + byte_count &gt; len(data):
            return False

        # Check continuation bytes (must be 10xxxxxx)
        for j in range(1, byte_count):
            if (data[i + j] &gt;&gt; 6) != 0b10:
                return False

        i += byte_count

    return True

print(valid_utf8([197, 130, 1]))  # True (2-byte + 1-byte)
print(valid_utf8([235, 140, 4]))  # False
</code></pre>
<h3 id="problem-6-bitwise-and-of-range"><a class="header" href="#problem-6-bitwise-and-of-range">Problem 6: Bitwise AND of Range</a></h3>
<pre><code class="language-python">def range_bitwise_and(left: int, right: int) -&gt; int:
    """
    LeetCode 201: Bitwise AND of all numbers in range [left, right].

    Key insight: Result keeps only the common prefix bits.
    All other bits will have both 0 and 1 in the range.

    Strategy: Find common prefix by right-shifting both until equal.

    Time: O(log n), Space: O(1)
    """
    shift = 0
    while left != right:
        left &gt;&gt;= 1
        right &gt;&gt;= 1
        shift += 1

    return left &lt;&lt; shift

# Example: [5, 7]
# 5 = 101
# 6 = 110
# 7 = 111
# AND = 100 (only first bit is common)

print(range_bitwise_and(5, 7))  # 4
print(range_bitwise_and(1, 2147483647))  # 0
</code></pre>
<h2 id="complexity-analysis"><a class="header" href="#complexity-analysis">Complexity Analysis</a></h2>
<p>Most bit manipulation operations are <strong>O(1)</strong> or <strong>O(k)</strong> where k is the number of bits:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr>
</thead>
<tbody>
<tr><td>AND, OR, XOR, NOT</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Shift left/right</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Check/Set/Clear bit</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Count set bits (naive)</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Count set bits (Kernighan)</td><td>O(k) where k = set bits</td><td>O(1)</td></tr>
<tr><td>Check power of 2</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Generate subsets</td><td>O(n * 2^n)</td><td>O(2^n)</td></tr>
<tr><td>Find unique number</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Maximum XOR (Trie)</td><td>O(n * 32)</td><td>O(n * 32)</td></tr>
</tbody>
</table>
</div>
<p><strong>Key advantages:</strong></p>
<ul>
<li>Often replace O(n) space with O(1) using bitmasks</li>
<li>Very fast in practice (hardware-level operations)</li>
<li>Useful for state compression in DP</li>
</ul>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p><strong>Use bit manipulation when:</strong></p>
<ol>
<li>
<p><strong>Set operations on small universe</strong> (0-63 elements)</p>
<ul>
<li>Faster than HashSet for small sets</li>
<li>O(1) operations vs O(1) amortized</li>
</ul>
</li>
<li>
<p><strong>Finding duplicates/unique elements</strong></p>
<ul>
<li>XOR properties eliminate duplicates</li>
<li>O(1) space vs O(n) with hash map</li>
</ul>
</li>
<li>
<p><strong>State compression in DP</strong></p>
<ul>
<li>Represent visited states as bitmask</li>
<li>Reduce dimensions in DP table</li>
</ul>
</li>
<li>
<p><strong>Performance-critical code</strong></p>
<ul>
<li>Multiply/divide by powers of 2 with shifts</li>
<li>Check even/odd with &amp; 1</li>
</ul>
</li>
<li>
<p><strong>Space optimization</strong></p>
<ul>
<li>Pack multiple boolean flags in one integer</li>
<li>Store small values together</li>
</ul>
</li>
<li>
<p><strong>Mathematical properties</strong></p>
<ul>
<li>GCD algorithms</li>
<li>Prime checking optimizations</li>
<li>Number theory problems</li>
</ul>
</li>
</ol>
<p><strong>Don’t use when:</strong></p>
<ul>
<li>Readability is more important than performance</li>
<li>Working with large sets (use proper data structures)</li>
<li>Debugging is difficult (bit operations are opaque)</li>
<li>Team unfamiliar with techniques</li>
</ul>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-signed-vs-unsigned-integers"><a class="header" href="#1-signed-vs-unsigned-integers">1. Signed vs Unsigned Integers</a></h3>
<pre><code class="language-python"># Python has arbitrary precision integers
# Be careful with right shift on negative numbers
n = -8
print(n &gt;&gt; 1)  # -4 (arithmetic shift, preserves sign)

# Use unsigned shift equivalent:
def unsigned_right_shift(n: int, shift: int) -&gt; int:
    """Simulate unsigned right shift."""
    return (n &amp; 0xFFFFFFFF) &gt;&gt; shift if n &lt; 0 else n &gt;&gt; shift
</code></pre>
<h3 id="2-operator-precedence"><a class="header" href="#2-operator-precedence">2. Operator Precedence</a></h3>
<pre><code class="language-python"># Bitwise operators have lower precedence than comparison
n = 5
# Wrong: if n &amp; 1 == 1:  # Parsed as: n &amp; (1 == 1)
# Correct:
if (n &amp; 1) == 1:  # Check if odd
    print("Odd")

# Always use parentheses for clarity!
</code></pre>
<h3 id="3-integer-overflow-in-other-languages"><a class="header" href="#3-integer-overflow-in-other-languages">3. Integer Overflow (in other languages)</a></h3>
<pre><code class="language-python"># Not an issue in Python, but in Java/C++:
# int x = 1 &lt;&lt; 31;  // Overflow! Becomes negative
# Use: long x = 1L &lt;&lt; 31;

# Python handles this automatically:
print(1 &lt;&lt; 100)  # Works fine!
</code></pre>
<h3 id="4-off-by-one-errors"><a class="header" href="#4-off-by-one-errors">4. Off-by-One Errors</a></h3>
<pre><code class="language-python"># Creating mask for n bits
# Wrong: (1 &lt;&lt; n)     # This has n+1 bits!
# Correct: (1 &lt;&lt; n) - 1  # This has n bits

print(bin(1 &lt;&lt; 3))      # 0b1000 (4 bits)
print(bin((1 &lt;&lt; 3) - 1))  # 0b111 (3 bits of 1s)
</code></pre>
<h3 id="5-forgetting-edge-cases"><a class="header" href="#5-forgetting-edge-cases">5. Forgetting Edge Cases</a></h3>
<pre><code class="language-python">def is_power_of_two(n: int) -&gt; bool:
    # Wrong: return (n &amp; (n - 1)) == 0
    # Correct: must check n &gt; 0 first!
    return n &gt; 0 and (n &amp; (n - 1)) == 0

# Edge cases:
print(is_power_of_two(0))   # False (not power of 2)
print(is_power_of_two(-8))  # False (negative)
print(is_power_of_two(1))   # True (2^0)
</code></pre>
<h2 id="practice-problems"><a class="header" href="#practice-problems">Practice Problems</a></h2>
<h3 id="easy"><a class="header" href="#easy">Easy</a></h3>
<ol>
<li><strong>Single Number</strong> (LeetCode 136)</li>
<li><strong>Number of 1 Bits</strong> (LeetCode 191)</li>
<li><strong>Reverse Bits</strong> (LeetCode 190)</li>
<li><strong>Power of Two</strong> (LeetCode 231)</li>
<li><strong>Power of Four</strong> (LeetCode 342)</li>
<li><strong>Missing Number</strong> (LeetCode 268)</li>
<li><strong>Hamming Distance</strong> (LeetCode 461)</li>
<li><strong>Binary Number with Alternating Bits</strong> (LeetCode 693)</li>
<li><strong>Prime Number of Set Bits</strong> (LeetCode 762)</li>
</ol>
<h3 id="medium"><a class="header" href="#medium">Medium</a></h3>
<ol start="10">
<li><strong>Single Number II</strong> (LeetCode 137) - element appears 3 times</li>
<li><strong>Single Number III</strong> (LeetCode 260) - two unique elements</li>
<li><strong>Bitwise AND of Numbers Range</strong> (LeetCode 201)</li>
<li><strong>Counting Bits</strong> (LeetCode 338)</li>
<li><strong>Maximum XOR of Two Numbers</strong> (LeetCode 421)</li>
<li><strong>UTF-8 Validation</strong> (LeetCode 393)</li>
<li><strong>Sum of Two Integers</strong> (LeetCode 371) - without +/-</li>
<li><strong>Repeated DNA Sequences</strong> (LeetCode 187)</li>
<li><strong>Gray Code</strong> (LeetCode 89)</li>
<li><strong>Subsets</strong> (LeetCode 78)</li>
<li><strong>Find the Duplicate Number</strong> (LeetCode 287)</li>
</ol>
<h3 id="hard"><a class="header" href="#hard">Hard</a></h3>
<ol start="21">
<li><strong>Maximum XOR with Element from Array</strong> (LeetCode 1707)</li>
<li><strong>Minimum XOR Sum of Two Arrays</strong> (LeetCode 1879)</li>
<li><strong>Find XOR Sum of All Pairs Bitwise AND</strong> (LeetCode 1835)</li>
<li><strong>Maximize XOR for Each Query</strong> (LeetCode 1829)</li>
</ol>
<h3 id="bonus-challenges"><a class="header" href="#bonus-challenges">Bonus Challenges</a></h3>
<ol start="25">
<li>Implement bitset operations (union, intersection, etc.)</li>
<li>Solve Sudoku using bitmasks</li>
<li>Traveling Salesman with bitmask DP</li>
<li>Count valid permutations using bitmasks</li>
</ol>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<h3 id="online-tools"><a class="header" href="#online-tools">Online Tools</a></h3>
<ul>
<li><strong>Bit Visualizer</strong>: https://visualgo.net/en/bitmask</li>
<li><strong>Binary Calculator</strong>: https://www.rapidtables.com/convert/number/binary-calculator.html</li>
</ul>
<h3 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h3>
<ul>
<li><strong>HackerEarth</strong>: Bit Manipulation Tutorial</li>
<li><strong>TopCoder</strong>: A Bit of Fun: Fun with Bits</li>
<li><strong>GeeksforGeeks</strong>: Bit Manipulation</li>
</ul>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<ul>
<li><strong>Hacker’s Delight</strong> by Henry S. Warren Jr. (the bible of bit manipulation)</li>
<li><strong>Programming Pearls</strong> by Jon Bentley</li>
<li><strong>The Art of Computer Programming, Vol 4A</strong> by Donald Knuth</li>
</ul>
<h3 id="practice-platforms"><a class="header" href="#practice-platforms">Practice Platforms</a></h3>
<ul>
<li>LeetCode Tag: Bit Manipulation</li>
<li>Codeforces: Bitmask DP problems</li>
<li>HackerRank: Bit Manipulation track</li>
</ul>
<hr>
<p><strong>Key Takeaways:</strong></p>
<ol>
<li>Bit manipulation provides O(1) time and space for many operations</li>
<li>XOR has unique properties (self-inverse, associative) useful for finding unique elements</li>
<li>Common patterns: check/set/clear bits, counting bits, generating subsets</li>
<li>Great for interviews: shows strong CS fundamentals</li>
<li>Trade-off: code clarity vs performance</li>
</ol>
<p>Master these techniques and you’ll have a powerful tool for optimization and problem-solving!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../algorithms/binary_search_patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../algorithms/complexity_cheatsheet.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../algorithms/binary_search_patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../algorithms/complexity_cheatsheet.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
