<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WebRTC - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="webrtc-web-real-time-communication"><a class="header" href="#webrtc-web-real-time-communication">WebRTC (Web Real-Time Communication)</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>WebRTC (Web Real-Time Communication) is an open-source framework that enables real-time peer-to-peer communication directly between web browsers and mobile applications. It supports video, audio, and arbitrary data transfer without requiring plugins or third-party software.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<pre><code>1. Peer-to-Peer Communication
   - Direct browser-to-browser connections
   - Low latency (no server relay required*)
   - Reduced bandwidth costs

2. Media Support
   - Audio streaming
   - Video streaming
   - Screen sharing
   - Data channels for arbitrary data

3. Built-in Security
   - Mandatory encryption (DTLS, SRTP)
   - No unencrypted media transmission
   - Secure signaling required

4. NAT/Firewall Traversal
   - ICE protocol for connectivity
   - STUN for public address discovery
   - TURN as relay fallback

5. Adaptive Quality
   - Bandwidth estimation
   - Codec negotiation
   - Quality adjusts to network conditions

* Direct P2P when possible; TURN relay as fallback
</code></pre>
<h2 id="webrtc-architecture"><a class="header" href="#webrtc-architecture">WebRTC Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    WebRTC Application                        │
│  (JavaScript API in browser or native mobile app)           │
└────────────────────┬────────────────────────────────────────┘
                     │
     ┌───────────────┼───────────────┐
     │               │               │
     ▼               ▼               ▼
┌─────────┐   ┌──────────┐   ┌──────────┐
│  Media  │   │   Data   │   │ Signaling│
│ Streams │   │ Channels │   │ (Custom) │
└─────────┘   └──────────┘   └──────────┘
     │               │               │
     ▼               ▼               │
┌─────────────────────────┐         │
│   WebRTC Core APIs      │         │
│                         │         │
│ - getUserMedia()        │         │
│ - RTCPeerConnection     │         │
│ - RTCDataChannel        │         │
└─────────────────────────┘         │
     │                               │
     ▼                               │
┌─────────────────────────┐         │
│   ICE/STUN/TURN         │         │
│ (NAT Traversal)         │         │
└─────────────────────────┘         │
     │                               │
     └───────────────┬───────────────┘
                     │
                     ▼
           ┌──────────────────┐
           │   Network Layer   │
           │  (UDP/TCP/TLS)    │
           └──────────────────┘
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="1-getusermedia-api"><a class="header" href="#1-getusermedia-api">1. getUserMedia API</a></h3>
<p>Access local camera and microphone:</p>
<pre><code class="language-javascript">// Basic usage
async function getLocalMedia() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    });

    // Display local video
    document.getElementById('localVideo').srcObject = stream;
    return stream;
  } catch (error) {
    console.error('Error accessing media devices:', error);
  }
}

// Advanced constraints
const constraints = {
  video: {
    width: { min: 640, ideal: 1280, max: 1920 },
    height: { min: 480, ideal: 720, max: 1080 },
    frameRate: { ideal: 30, max: 60 },
    facingMode: 'user' // or 'environment' for rear camera
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  }
};

const stream = await navigator.mediaDevices.getUserMedia(constraints);

// List available devices
const devices = await navigator.mediaDevices.enumerateDevices();
devices.forEach(device =&gt; {
  console.log(`${device.kind}: ${device.label} (${device.deviceId})`);
});

// Screen sharing
const screenStream = await navigator.mediaDevices.getDisplayMedia({
  video: {
    cursor: 'always',
    displaySurface: 'monitor' // 'window', 'application', 'browser'
  },
  audio: false
});
</code></pre>
<h3 id="2-rtcpeerconnection"><a class="header" href="#2-rtcpeerconnection">2. RTCPeerConnection</a></h3>
<p>Core API for peer-to-peer connection:</p>
<pre><code class="language-javascript">// Create peer connection
const configuration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    {
      urls: 'turn:turn.example.com:3478',
      username: 'user',
      credential: 'pass'
    }
  ],
  iceCandidatePoolSize: 10
};

const peerConnection = new RTCPeerConnection(configuration);

// Add local stream to connection
localStream.getTracks().forEach(track =&gt; {
  peerConnection.addTrack(track, localStream);
});

// Listen for remote stream
peerConnection.ontrack = (event) =&gt; {
  const remoteVideo = document.getElementById('remoteVideo');
  if (remoteVideo.srcObject !== event.streams[0]) {
    remoteVideo.srcObject = event.streams[0];
    console.log('Received remote stream');
  }
};

// Handle ICE candidates
peerConnection.onicecandidate = (event) =&gt; {
  if (event.candidate) {
    // Send candidate to remote peer via signaling
    sendToSignalingServer({
      type: 'ice-candidate',
      candidate: event.candidate
    });
  }
};

// Monitor connection state
peerConnection.onconnectionstatechange = () =&gt; {
  console.log('Connection state:', peerConnection.connectionState);
  // States: new, connecting, connected, disconnected, failed, closed
};

peerConnection.oniceconnectionstatechange = () =&gt; {
  console.log('ICE state:', peerConnection.iceConnectionState);
  // States: new, checking, connected, completed, failed, disconnected, closed
};
</code></pre>
<h3 id="3-rtcdatachannel"><a class="header" href="#3-rtcdatachannel">3. RTCDataChannel</a></h3>
<p>Bi-directional data transfer:</p>
<pre><code class="language-javascript">// Sender creates data channel
const dataChannel = peerConnection.createDataChannel('chat', {
  ordered: true,        // Guarantee order
  maxRetransmits: 3     // Retry failed messages 3 times
  // OR: maxPacketLifeTime: 3000  // Drop after 3 seconds
});

dataChannel.onopen = () =&gt; {
  console.log('Data channel opened');
  dataChannel.send('Hello!');
};

dataChannel.onmessage = (event) =&gt; {
  console.log('Received:', event.data);
};

dataChannel.onerror = (error) =&gt; {
  console.error('Data channel error:', error);
};

dataChannel.onclose = () =&gt; {
  console.log('Data channel closed');
};

// Receiver listens for data channel
peerConnection.ondatachannel = (event) =&gt; {
  const receiveChannel = event.channel;

  receiveChannel.onmessage = (event) =&gt; {
    console.log('Received:', event.data);
  };

  receiveChannel.onopen = () =&gt; {
    console.log('Receive channel opened');
  };
};

// Send different data types
dataChannel.send('Text message');
dataChannel.send(JSON.stringify({ type: 'chat', message: 'Hi' }));
dataChannel.send(new Uint8Array([1, 2, 3, 4])); // Binary
dataChannel.send(new Blob(['file content'])); // Blob

// Check buffered amount before sending large data
if (dataChannel.bufferedAmount === 0) {
  dataChannel.send(largeData);
}
</code></pre>
<h2 id="connection-establishment-signaling"><a class="header" href="#connection-establishment-signaling">Connection Establishment (Signaling)</a></h2>
<p>WebRTC doesn't define signaling - you implement it yourself:</p>
<h3 id="offeranswer-exchange-sdp"><a class="header" href="#offeranswer-exchange-sdp">Offer/Answer Exchange (SDP)</a></h3>
<pre><code class="language-javascript">// ============================================
// Caller (Initiator)
// ============================================

// 1. Create offer
const offer = await peerConnection.createOffer({
  offerToReceiveAudio: true,
  offerToReceiveVideo: true
});

// 2. Set local description
await peerConnection.setLocalDescription(offer);

// 3. Send offer to remote peer via signaling
sendToSignalingServer({
  type: 'offer',
  sdp: peerConnection.localDescription
});

// 4. Receive answer from signaling server
signalingSocket.on('answer', async (answer) =&gt; {
  await peerConnection.setRemoteDescription(
    new RTCSessionDescription(answer)
  );
});

// ============================================
// Callee (Responder)
// ============================================

// 1. Receive offer from signaling server
signalingSocket.on('offer', async (offer) =&gt; {
  // 2. Set remote description
  await peerConnection.setRemoteDescription(
    new RTCSessionDescription(offer)
  );

  // 3. Create answer
  const answer = await peerConnection.createAnswer();

  // 4. Set local description
  await peerConnection.setLocalDescription(answer);

  // 5. Send answer back via signaling
  sendToSignalingServer({
    type: 'answer',
    sdp: peerConnection.localDescription
  });
});

// ============================================
// Both Peers
// ============================================

// Handle ICE candidates
peerConnection.onicecandidate = (event) =&gt; {
  if (event.candidate) {
    sendToSignalingServer({
      type: 'ice-candidate',
      candidate: event.candidate
    });
  }
};

// Receive ICE candidates from signaling
signalingSocket.on('ice-candidate', async (candidate) =&gt; {
  try {
    await peerConnection.addIceCandidate(
      new RTCIceCandidate(candidate)
    );
  } catch (error) {
    console.error('Error adding ICE candidate:', error);
  }
});
</code></pre>
<h3 id="sdp-session-description-protocol"><a class="header" href="#sdp-session-description-protocol">SDP (Session Description Protocol)</a></h3>
<p>SDP describes the media session:</p>
<pre><code>Example SDP Offer:

v=0
o=- 123456789 2 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE 0 1
a=msid-semantic: WMS stream1

m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:F7gI
a=ice-pwd:x9cml6RvRClHPcAy
a=ice-options:trickle
a=fingerprint:sha-256 8B:87:09:8A:5D:C2:...
a=setup:actpass
a=mid:0
a=sendrecv
a=rtcp-mux
a=rtpmap:111 opus/48000/2
a=rtpmap:103 ISAC/16000
a=rtpmap:104 ISAC/32000

m=video 9 UDP/TLS/RTP/SAVPF 96 97 98
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:F7gI
a=ice-pwd:x9cml6RvRClHPcAy
a=ice-options:trickle
a=fingerprint:sha-256 8B:87:09:8A:5D:C2:...
a=setup:actpass
a=mid:1
a=sendrecv
a=rtcp-mux
a=rtpmap:96 VP8/90000
a=rtpmap:97 VP9/90000
a=rtpmap:98 H264/90000

Key Fields:
- v=0: SDP version
- m=: Media description (audio/video)
- c=: Connection information
- a=: Attributes (ICE, codecs, etc.)
- rtpmap: RTP payload mapping
- ice-ufrag/ice-pwd: ICE credentials
- fingerprint: DTLS certificate fingerprint
</code></pre>
<h2 id="signaling-implementation-examples"><a class="header" href="#signaling-implementation-examples">Signaling Implementation Examples</a></h2>
<h3 id="websocket-signaling-server-nodejs"><a class="header" href="#websocket-signaling-server-nodejs">WebSocket Signaling Server (Node.js)</a></h3>
<pre><code class="language-javascript">// Server
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

const rooms = new Map(); // roomId -&gt; Set of clients

wss.on('connection', (ws) =&gt; {
  console.log('Client connected');

  ws.on('message', (data) =&gt; {
    const message = JSON.parse(data);

    switch (message.type) {
      case 'join':
        // Join room
        if (!rooms.has(message.room)) {
          rooms.set(message.room, new Set());
        }
        rooms.get(message.room).add(ws);
        ws.room = message.room;

        // Notify others in room
        broadcast(message.room, ws, {
          type: 'user-joined',
          userId: message.userId
        });
        break;

      case 'offer':
      case 'answer':
      case 'ice-candidate':
        // Forward to specific peer or broadcast
        if (message.target) {
          sendToUser(message.target, message);
        } else {
          broadcast(ws.room, ws, message);
        }
        break;

      case 'leave':
        leaveRoom(ws);
        break;
    }
  });

  ws.on('close', () =&gt; {
    console.log('Client disconnected');
    leaveRoom(ws);
  });
});

function broadcast(room, sender, message) {
  if (!rooms.has(room)) return;

  rooms.get(room).forEach(client =&gt; {
    if (client !== sender &amp;&amp; client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(message));
    }
  });
}

function leaveRoom(ws) {
  if (ws.room &amp;&amp; rooms.has(ws.room)) {
    rooms.get(ws.room).delete(ws);
    broadcast(ws.room, ws, {
      type: 'user-left',
      userId: ws.userId
    });
  }
}

console.log('Signaling server running on ws://localhost:8080');
</code></pre>
<h3 id="client-side-signaling"><a class="header" href="#client-side-signaling">Client-Side Signaling</a></h3>
<pre><code class="language-javascript">// Client
class SignalingClient {
  constructor(url) {
    this.socket = new WebSocket(url);
    this.handlers = new Map();

    this.socket.onmessage = (event) =&gt; {
      const message = JSON.parse(event.data);
      const handler = this.handlers.get(message.type);
      if (handler) {
        handler(message);
      }
    };

    this.socket.onopen = () =&gt; {
      console.log('Signaling connected');
    };

    this.socket.onerror = (error) =&gt; {
      console.error('Signaling error:', error);
    };

    this.socket.onclose = () =&gt; {
      console.log('Signaling disconnected');
    };
  }

  on(type, handler) {
    this.handlers.set(type, handler);
  }

  send(message) {
    this.socket.send(JSON.stringify(message));
  }

  join(room, userId) {
    this.send({ type: 'join', room, userId });
  }

  sendOffer(offer, target) {
    this.send({ type: 'offer', sdp: offer, target });
  }

  sendAnswer(answer, target) {
    this.send({ type: 'answer', sdp: answer, target });
  }

  sendIceCandidate(candidate, target) {
    this.send({ type: 'ice-candidate', candidate, target });
  }
}

// Usage
const signaling = new SignalingClient('ws://localhost:8080');

signaling.on('offer', handleOffer);
signaling.on('answer', handleAnswer);
signaling.on('ice-candidate', handleIceCandidate);

signaling.join('room123', 'user1');
</code></pre>
<h2 id="complete-webrtc-example"><a class="header" href="#complete-webrtc-example">Complete WebRTC Example</a></h2>
<h3 id="simple-video-chat-application"><a class="header" href="#simple-video-chat-application">Simple Video Chat Application</a></h3>
<pre><code class="language-javascript">class WebRTCVideoChat {
  constructor(signalingUrl) {
    this.signaling = new SignalingClient(signalingUrl);
    this.peerConnection = null;
    this.localStream = null;

    this.setupSignaling();
  }

  setupSignaling() {
    this.signaling.on('offer', async (message) =&gt; {
      await this.handleOffer(message.sdp, message.sender);
    });

    this.signaling.on('answer', async (message) =&gt; {
      await this.handleAnswer(message.sdp);
    });

    this.signaling.on('ice-candidate', async (message) =&gt; {
      await this.handleIceCandidate(message.candidate);
    });

    this.signaling.on('user-joined', (message) =&gt; {
      console.log('User joined:', message.userId);
      // Initiate call if you're the caller
    });
  }

  async start(localVideoElement, remoteVideoElement) {
    // Get local media
    this.localStream = await navigator.mediaDevices.getUserMedia({
      video: { width: 1280, height: 720 },
      audio: true
    });

    localVideoElement.srcObject = this.localStream;

    // Create peer connection
    this.peerConnection = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
      ]
    });

    // Add local stream
    this.localStream.getTracks().forEach(track =&gt; {
      this.peerConnection.addTrack(track, this.localStream);
    });

    // Handle remote stream
    this.peerConnection.ontrack = (event) =&gt; {
      remoteVideoElement.srcObject = event.streams[0];
    };

    // Handle ICE candidates
    this.peerConnection.onicecandidate = (event) =&gt; {
      if (event.candidate) {
        this.signaling.sendIceCandidate(event.candidate);
      }
    };

    // Monitor connection
    this.peerConnection.onconnectionstatechange = () =&gt; {
      console.log('Connection state:',
        this.peerConnection.connectionState);
    };
  }

  async call() {
    // Create and send offer
    const offer = await this.peerConnection.createOffer();
    await this.peerConnection.setLocalDescription(offer);
    this.signaling.sendOffer(offer);
  }

  async handleOffer(offer, sender) {
    await this.peerConnection.setRemoteDescription(
      new RTCSessionDescription(offer)
    );

    const answer = await this.peerConnection.createAnswer();
    await this.peerConnection.setLocalDescription(answer);

    this.signaling.sendAnswer(answer, sender);
  }

  async handleAnswer(answer) {
    await this.peerConnection.setRemoteDescription(
      new RTCSessionDescription(answer)
    );
  }

  async handleIceCandidate(candidate) {
    await this.peerConnection.addIceCandidate(
      new RTCIceCandidate(candidate)
    );
  }

  hangup() {
    if (this.peerConnection) {
      this.peerConnection.close();
      this.peerConnection = null;
    }

    if (this.localStream) {
      this.localStream.getTracks().forEach(track =&gt; track.stop());
      this.localStream = null;
    }
  }

  toggleAudio() {
    const audioTrack = this.localStream.getAudioTracks()[0];
    audioTrack.enabled = !audioTrack.enabled;
    return audioTrack.enabled;
  }

  toggleVideo() {
    const videoTrack = this.localStream.getVideoTracks()[0];
    videoTrack.enabled = !videoTrack.enabled;
    return videoTrack.enabled;
  }
}

// Usage
const chat = new WebRTCVideoChat('ws://localhost:8080');

const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

await chat.start(localVideo, remoteVideo);
chat.signaling.join('room123', 'user1');

// When ready to call
document.getElementById('callButton').onclick = () =&gt; chat.call();
document.getElementById('hangupButton').onclick = () =&gt; chat.hangup();
document.getElementById('muteButton').onclick = () =&gt; chat.toggleAudio();
document.getElementById('videoButton').onclick = () =&gt; chat.toggleVideo();
</code></pre>
<h2 id="media-codecs"><a class="header" href="#media-codecs">Media Codecs</a></h2>
<h3 id="audio-codecs"><a class="header" href="#audio-codecs">Audio Codecs</a></h3>
<pre><code>Opus (Preferred)
- Bitrate: 6-510 kbps
- Latency: 5-66.5 ms
- Best quality and efficiency
- Supports stereo and mono
- Adaptive bitrate

G.711 (PCMU/PCMA)
- Bitrate: 64 kbps
- Latency: Low
- Widely supported
- Lower quality than Opus

iSAC
- Bitrate: 10-32 kbps
- Adaptive bitrate
- Good for low bandwidth

iLBC
- Bitrate: 13.33 or 15.2 kbps
- Packet loss resilience
- Voice only
</code></pre>
<h3 id="video-codecs"><a class="header" href="#video-codecs">Video Codecs</a></h3>
<pre><code>VP8 (Mandatory in WebRTC)
- Open source
- Good quality
- Hardware acceleration common
- Bitrate: 100-2000 kbps typically

VP9 (Better than VP8)
- 50% better compression than VP8
- Supports 4K
- Lower bandwidth usage
- Newer, less hardware support

H.264 (Most compatible)
- Patent-encumbered
- Excellent hardware support
- Multiple profiles (Baseline, Main, High)
- Most widely supported

AV1 (Future)
- Best compression
- Open source
- Still emerging
- Limited hardware support
</code></pre>
<h3 id="codec-selection"><a class="header" href="#codec-selection">Codec Selection</a></h3>
<pre><code class="language-javascript">// Prefer specific codec
function preferCodec(sdp, codecName) {
  const lines = sdp.split('\n');
  const mLineIndex = lines.findIndex(line =&gt; line.startsWith('m=video'));
  if (mLineIndex === -1) return sdp;

  const codecRegex = new RegExp(`rtpmap:(\\d+) ${codecName}`, 'i');
  const codecPayload = lines
    .find(line =&gt; codecRegex.test(line))
    ?.match(codecRegex)?.[1];

  if (!codecPayload) return sdp;

  const mLine = lines[mLineIndex].split(' ');
  const codecs = mLine.slice(3);

  // Move preferred codec to front
  const newCodecs = [
    codecPayload,
    ...codecs.filter(c =&gt; c !== codecPayload)
  ];

  mLine.splice(3, codecs.length, ...newCodecs);
  lines[mLineIndex] = mLine.join(' ');

  return lines.join('\n');
}

// Usage
const offer = await peerConnection.createOffer();
offer.sdp = preferCodec(offer.sdp, 'VP9');
await peerConnection.setLocalDescription(offer);
</code></pre>
<h2 id="quality-adaptation"><a class="header" href="#quality-adaptation">Quality Adaptation</a></h2>
<h3 id="bandwidth-estimation"><a class="header" href="#bandwidth-estimation">Bandwidth Estimation</a></h3>
<pre><code class="language-javascript">// Monitor bandwidth
peerConnection.getStats().then(stats =&gt; {
  stats.forEach(report =&gt; {
    if (report.type === 'candidate-pair' &amp;&amp; report.state === 'succeeded') {
      console.log('Available bandwidth:',
        report.availableOutgoingBitrate);
      console.log('Current bandwidth:',
        report.currentRoundTripTime);
    }

    if (report.type === 'inbound-rtp' &amp;&amp; report.mediaType === 'video') {
      console.log('Bytes received:', report.bytesReceived);
      console.log('Packets lost:', report.packetsLost);
      console.log('Jitter:', report.jitter);
    }
  });
});

// Periodic monitoring
setInterval(async () =&gt; {
  const stats = await peerConnection.getStats();
  analyzeStats(stats);
}, 1000);
</code></pre>
<h3 id="simulcast-multiple-qualities"><a class="header" href="#simulcast-multiple-qualities">Simulcast (Multiple Qualities)</a></h3>
<pre><code class="language-javascript">// Sender: Send multiple resolutions
const sender = peerConnection
  .getSenders()
  .find(s =&gt; s.track.kind === 'video');

const parameters = sender.getParameters();
if (!parameters.encodings) {
  parameters.encodings = [
    { rid: 'h', maxBitrate: 1500000 },  // High quality
    { rid: 'm', maxBitrate: 600000, scaleResolutionDownBy: 2 },  // Medium
    { rid: 'l', maxBitrate: 200000, scaleResolutionDownBy: 4 }   // Low
  ];
}

await sender.setParameters(parameters);

// Receiver: Select layer
const receiver = peerConnection
  .getReceivers()
  .find(r =&gt; r.track.kind === 'video');

// Request specific layer
receiver.getParameters().encodings = [
  { active: true, rid: 'm' }  // Request medium quality
];
</code></pre>
<h3 id="manual-bitrate-control"><a class="header" href="#manual-bitrate-control">Manual Bitrate Control</a></h3>
<pre><code class="language-javascript">async function setMaxBitrate(peerConnection, maxBitrate) {
  const sender = peerConnection
    .getSenders()
    .find(s =&gt; s.track.kind === 'video');

  const parameters = sender.getParameters();

  if (!parameters.encodings) {
    parameters.encodings = [{}];
  }

  parameters.encodings[0].maxBitrate = maxBitrate;

  await sender.setParameters(parameters);
  console.log(`Set max bitrate to ${maxBitrate} bps`);
}

// Usage
setMaxBitrate(peerConnection, 500000); // 500 kbps
</code></pre>
<h2 id="data-channels-use-cases"><a class="header" href="#data-channels-use-cases">Data Channels Use Cases</a></h2>
<h3 id="file-transfer"><a class="header" href="#file-transfer">File Transfer</a></h3>
<pre><code class="language-javascript">class FileTransfer {
  constructor(dataChannel) {
    this.channel = dataChannel;
    this.chunkSize = 16384; // 16 KB chunks
  }

  async sendFile(file) {
    const arrayBuffer = await file.arrayBuffer();
    const totalChunks = Math.ceil(arrayBuffer.byteLength / this.chunkSize);

    // Send metadata
    this.channel.send(JSON.stringify({
      type: 'file-start',
      name: file.name,
      size: file.size,
      totalChunks: totalChunks
    }));

    // Send chunks
    for (let i = 0; i &lt; totalChunks; i++) {
      const start = i * this.chunkSize;
      const end = Math.min(start + this.chunkSize, arrayBuffer.byteLength);
      const chunk = arrayBuffer.slice(start, end);

      // Wait if buffer is filling up
      while (this.channel.bufferedAmount &gt; this.chunkSize * 10) {
        await new Promise(resolve =&gt; setTimeout(resolve, 10));
      }

      this.channel.send(chunk);

      // Progress update
      const progress = ((i + 1) / totalChunks * 100).toFixed(1);
      console.log(`Sending: ${progress}%`);
    }

    // Send completion
    this.channel.send(JSON.stringify({ type: 'file-end' }));
  }

  receiveFile(onProgress, onComplete) {
    const chunks = [];
    let metadata = null;

    this.channel.onmessage = (event) =&gt; {
      if (typeof event.data === 'string') {
        const message = JSON.parse(event.data);

        if (message.type === 'file-start') {
          metadata = message;
          chunks.length = 0;
        } else if (message.type === 'file-end') {
          const blob = new Blob(chunks);
          onComplete(blob, metadata);
        }
      } else {
        // Binary chunk
        chunks.push(event.data);

        if (metadata) {
          const progress = (chunks.length / metadata.totalChunks * 100)
            .toFixed(1);
          onProgress(progress);
        }
      }
    };
  }
}

// Usage
const fileTransfer = new FileTransfer(dataChannel);

// Sender
document.getElementById('fileInput').onchange = async (e) =&gt; {
  const file = e.target.files[0];
  await fileTransfer.sendFile(file);
};

// Receiver
fileTransfer.receiveFile(
  (progress) =&gt; console.log(`Receiving: ${progress}%`),
  (blob, metadata) =&gt; {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = metadata.name;
    a.click();
  }
);
</code></pre>
<h3 id="gamingreal-time-data"><a class="header" href="#gamingreal-time-data">Gaming/Real-time Data</a></h3>
<pre><code class="language-javascript">class GameDataChannel {
  constructor(dataChannel) {
    this.channel = dataChannel;
    this.channel.binaryType = 'arraybuffer';

    // Unreliable, unordered for low latency
    this.channel = peerConnection.createDataChannel('game', {
      ordered: false,
      maxRetransmits: 0
    });
  }

  sendPlayerPosition(x, y, angle) {
    const buffer = new ArrayBuffer(12);
    const view = new DataView(buffer);

    view.setFloat32(0, x, true);
    view.setFloat32(4, y, true);
    view.setFloat32(8, angle, true);

    this.channel.send(buffer);
  }

  onPlayerPosition(callback) {
    this.channel.onmessage = (event) =&gt; {
      const view = new DataView(event.data);

      const x = view.getFloat32(0, true);
      const y = view.getFloat32(4, true);
      const angle = view.getFloat32(8, true);

      callback(x, y, angle);
    };
  }
}

// Usage
const gameChannel = new GameDataChannel(dataChannel);

// Send position 60 times per second
setInterval(() =&gt; {
  gameChannel.sendPlayerPosition(
    player.x,
    player.y,
    player.angle
  );
}, 1000 / 60);

gameChannel.onPlayerPosition((x, y, angle) =&gt; {
  updateRemotePlayer(x, y, angle);
});
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<pre><code>WebRTC Security Stack:

Application Data
       ↓
SRTP (Secure RTP)
  - Encrypts media (audio/video)
  - AES encryption
  - HMAC authentication
       ↓
DTLS (Datagram TLS)
  - Encrypts data channels
  - Key exchange for SRTP
  - Certificate verification
       ↓
UDP/TCP Transport

All WebRTC traffic is encrypted!
No option for unencrypted communication.
</code></pre>
<h3 id="certificate-verification"><a class="header" href="#certificate-verification">Certificate Verification</a></h3>
<pre><code class="language-javascript">// Verify peer certificate fingerprint
peerConnection.onicecandidate = (event) =&gt; {
  if (event.candidate === null) {
    // Get local certificate
    peerConnection.getConfiguration().certificates.forEach(cert =&gt; {
      cert.getFingerprints().forEach(fingerprint =&gt; {
        console.log('Local fingerprint:', fingerprint);
        // Send to peer via secure signaling
        // Peer should verify this matches SDP
      });
    });
  }
};

// Check SDP fingerprint matches expected
function verifySdpFingerprint(sdp, expectedFingerprint) {
  const fingerprintMatch = sdp.match(/a=fingerprint:(\S+) (\S+)/);
  if (!fingerprintMatch) {
    throw new Error('No fingerprint in SDP');
  }

  const [, algorithm, fingerprint] = fingerprintMatch;

  if (fingerprint !== expectedFingerprint) {
    throw new Error('Fingerprint mismatch! Possible MITM attack.');
  }

  return true;
}
</code></pre>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<pre><code>1. Secure Signaling
   - Use TLS/WSS for signaling
   - Authenticate users
   - Verify peer identity

2. Certificate Pinning
   - Verify SDP fingerprints
   - Out-of-band verification if possible

3. Access Control
   - Verify room/session authorization
   - Implement user authentication
   - Rate limiting

4. Media Permissions
   - Request minimal permissions
   - Explain why access is needed
   - Allow users to deny

5. Privacy
   - Minimize data collection
   - No recording without consent
   - Clear privacy policy

6. Network Security
   - Use TURN with authentication
   - Restrict TURN access
   - Monitor for abuse
</code></pre>
<h2 id="debugging-and-troubleshooting"><a class="header" href="#debugging-and-troubleshooting">Debugging and Troubleshooting</a></h2>
<h3 id="enable-debug-logs"><a class="header" href="#enable-debug-logs">Enable Debug Logs</a></h3>
<pre><code class="language-javascript">// Chrome: Enable WebRTC internals
// Navigate to: chrome://webrtc-internals

// Firefox: Enable logging
// Navigate to: about:webrtc

// Console logging
peerConnection.addEventListener('track', e =&gt; {
  console.log('Track event:', e);
});

peerConnection.addEventListener('icecandidate', e =&gt; {
  console.log('ICE candidate:', e.candidate);
});

peerConnection.addEventListener('icecandidateerror', e =&gt; {
  console.error('ICE candidate error:', e);
});

peerConnection.addEventListener('connectionstatechange', e =&gt; {
  console.log('Connection state:', peerConnection.connectionState);
});

peerConnection.addEventListener('iceconnectionstatechange', e =&gt; {
  console.log('ICE connection state:',
    peerConnection.iceConnectionState);
});
</code></pre>
<h3 id="get-detailed-statistics"><a class="header" href="#get-detailed-statistics">Get Detailed Statistics</a></h3>
<pre><code class="language-javascript">async function getDetailedStats(peerConnection) {
  const stats = await peerConnection.getStats();
  const report = {};

  stats.forEach(stat =&gt; {
    if (stat.type === 'inbound-rtp' &amp;&amp; stat.kind === 'video') {
      report.video = {
        bytesReceived: stat.bytesReceived,
        packetsReceived: stat.packetsReceived,
        packetsLost: stat.packetsLost,
        jitter: stat.jitter,
        frameWidth: stat.frameWidth,
        frameHeight: stat.frameHeight,
        framesPerSecond: stat.framesPerSecond,
        framesDecoded: stat.framesDecoded,
        framesDropped: stat.framesDropped
      };
    }

    if (stat.type === 'inbound-rtp' &amp;&amp; stat.kind === 'audio') {
      report.audio = {
        bytesReceived: stat.bytesReceived,
        packetsReceived: stat.packetsReceived,
        packetsLost: stat.packetsLost,
        jitter: stat.jitter,
        audioLevel: stat.audioLevel
      };
    }

    if (stat.type === 'candidate-pair' &amp;&amp; stat.state === 'succeeded') {
      report.connection = {
        localCandidateType: stat.localCandidateType,
        remoteCandidateType: stat.remoteCandidateType,
        currentRoundTripTime: stat.currentRoundTripTime,
        availableOutgoingBitrate: stat.availableOutgoingBitrate,
        bytesReceived: stat.bytesReceived,
        bytesSent: stat.bytesSent
      };
    }
  });

  return report;
}

// Monitor every second
setInterval(async () =&gt; {
  const stats = await getDetailedStats(peerConnection);
  console.table(stats);
}, 1000);
</code></pre>
<h3 id="common-issues-and-solutions"><a class="header" href="#common-issues-and-solutions">Common Issues and Solutions</a></h3>
<pre><code>Issue: ICE connection fails
Solutions:
- Check STUN/TURN server configuration
- Verify firewall allows UDP traffic
- Add TURN server as fallback
- Check ICE candidate gathering

Issue: No video/audio
Solutions:
- Verify getUserMedia constraints
- Check browser permissions
- Verify tracks added to peer connection
- Check ontrack event handler

Issue: One-way audio/video
Solutions:
- Verify both peers add tracks
- Check SDP offer/answer exchange
- Verify both peers handle ontrack
- Check NAT/firewall rules

Issue: Poor quality
Solutions:
- Reduce resolution/bitrate
- Enable simulcast
- Check network bandwidth
- Monitor packet loss
- Verify codec support

Issue: High latency
Solutions:
- Use TURN server closer to users
- Enable unreliable data channels for gaming
- Reduce buffering
- Optimize codec settings
</code></pre>
<h2 id="browser-support"><a class="header" href="#browser-support">Browser Support</a></h2>
<pre><code>Desktop Browsers:
✓ Chrome 23+
✓ Firefox 22+
✓ Safari 11+
✓ Edge 79+ (Chromium-based)
✓ Opera 18+

Mobile Browsers:
✓ Chrome Android 28+
✓ Firefox Android 24+
✓ Safari iOS 11+
✓ Samsung Internet 4+

Feature Support:
- getUserMedia: All modern browsers
- RTCPeerConnection: All modern browsers
- RTCDataChannel: All modern browsers
- Screen sharing: Desktop only (most browsers)
- VP9 codec: Chrome, Firefox, Edge
- H.264 codec: All browsers (licensing)

Check: https://caniuse.com/rtcpeerconnection
</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="tips-for-better-performance"><a class="header" href="#tips-for-better-performance">Tips for Better Performance</a></h3>
<pre><code class="language-javascript">// 1. Reuse peer connections
const peerConnections = new Map();

function getOrCreatePeerConnection(peerId) {
  if (!peerConnections.has(peerId)) {
    peerConnections.set(peerId, createPeerConnection());
  }
  return peerConnections.get(peerId);
}

// 2. Batch ICE candidates (trickle ICE)
const pendingCandidates = [];

peerConnection.onicecandidate = (event) =&gt; {
  if (event.candidate) {
    pendingCandidates.push(event.candidate);

    // Send in batches
    if (pendingCandidates.length &gt;= 5) {
      signaling.send({
        type: 'ice-candidates',
        candidates: pendingCandidates.splice(0)
      });
    }
  }
};

// 3. Use efficient codecs
// VP9 or H.264 for video, Opus for audio

// 4. Enable hardware acceleration
// Automatic in most browsers

// 5. Limit resolution based on network
async function adaptToNetwork(peerConnection) {
  const stats = await peerConnection.getStats();
  // Analyze and adjust bitrate/resolution
}

// 6. Use object fit for video elements
&lt;video style="object-fit: cover;" /&gt;

// 7. Clean up resources
function cleanup() {
  localStream?.getTracks().forEach(track =&gt; track.stop());
  peerConnection?.close();
  dataChannel?.close();
}
</code></pre>
<h2 id="eli10-webrtc-explained-simply"><a class="header" href="#eli10-webrtc-explained-simply">ELI10: WebRTC Explained Simply</a></h2>
<p>WebRTC lets browsers talk directly to each other without a server in the middle:</p>
<h3 id="traditional-communication"><a class="header" href="#traditional-communication">Traditional Communication</a></h3>
<pre><code>Your Browser → Server → Friend's Browser
- Everything goes through server
- Server sees all your data
- Costs more (server bandwidth)
- Higher latency
</code></pre>
<h3 id="webrtc-communication"><a class="header" href="#webrtc-communication">WebRTC Communication</a></h3>
<pre><code>Your Browser ←→ Friend's Browser
- Direct connection (peer-to-peer)
- Server only introduces you
- Private (server can't see)
- Faster (no middleman)
</code></pre>
<h3 id="the-process"><a class="header" href="#the-process">The Process</a></h3>
<pre><code>1. Get Permission
   "Can I use your camera and microphone?"

2. Signaling (Meeting)
   Server: "Hey Browser A, meet Browser B"
   Exchange: "Here's how to reach me"

3. ICE/STUN (Finding the Path)
   "What's my public address?"
   "Can we connect directly?"

4. Connection!
   Direct video/audio/data
   Encrypted automatically

5. If Direct Fails
   TURN server relays traffic
   Still encrypted
</code></pre>
<h3 id="real-world-analogy"><a class="header" href="#real-world-analogy">Real-World Analogy</a></h3>
<pre><code>Traditional: Passing notes through teacher
WebRTC: Sitting next to friend and talking
Signaling: Teacher introduces you
STUN: Finding where each person sits
TURN: Using walkie-talkies if too far
</code></pre>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">MDN WebRTC API</a></li>
<li><a href="https://www.w3.org/TR/webrtc/">WebRTC Specification</a></li>
<li><a href="https://webrtc.github.io/samples/">WebRTC Samples</a></li>
</ul>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li><a href="chrome://webrtc-internals">chrome://webrtc-internals</a> - Chrome debugging</li>
<li><a href="about:webrtc">about:webrtc</a> - Firefox debugging</li>
<li><a href="https://test.webrtc.org/">WebRTC Troubleshooter</a></li>
</ul>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<ul>
<li><a href="https://simplewebrtc.com/">SimpleWebRTC</a> - Simplified WebRTC</li>
<li><a href="https://peerjs.com/">PeerJS</a> - Easy peer-to-peer</li>
<li><a href="https://janus.conf.meetecho.com/">Janus Gateway</a> - WebRTC server</li>
<li><a href="https://www.kurento.org/">Kurento</a> - Media server</li>
</ul>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<ul>
<li><a href="https://networktest.twilio.com/">WebRTC Network Tester</a></li>
<li><a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/">STUN/TURN Server Test</a></li>
</ul>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<ul>
<li><em>Real-Time Communication with WebRTC</em> by Salvatore Loreto</li>
<li><em>WebRTC Cookbook</em> by Andrii Sergiienko</li>
<li><em>High Performance Browser Networking</em> by Ilya Grigorik</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../networking/websocket.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../finance/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../networking/websocket.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../finance/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
