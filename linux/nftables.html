<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>nftables - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-93581825.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-a4fa5267.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="nftables"><a class="header" href="#nftables">nftables</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>nftables</strong> is the modern Linux kernel packet filtering framework that replaces the legacy iptables, ip6tables, arptables, and ebtables frameworks. It was merged into the Linux kernel in version 3.13 (January 2014) and provides a unified interface for packet filtering, network address translation (NAT), and packet mangling.</p>
<h3 id="why-nftables"><a class="header" href="#why-nftables">Why nftables?</a></h3>
<p>The legacy iptables framework had several limitations:</p>
<ul>
<li>Separate tools for different protocols (iptables, ip6tables, arptables, ebtables)</li>
<li>Code duplication across different tools</li>
<li>Limited performance for large rulesets</li>
<li>Rule updates were not atomic</li>
<li>Complex syntax with many different match extensions</li>
</ul>
<p>nftables addresses these issues with:</p>
<ul>
<li><strong>Unified syntax</strong> across all protocols</li>
<li><strong>Better performance</strong> through improved data structures (sets, maps)</li>
<li><strong>Atomic rule updates</strong> - all-or-nothing rule changes</li>
<li><strong>Simplified syntax</strong> with more intuitive expressions</li>
<li><strong>Built-in scripting</strong> capabilities</li>
<li><strong>Smaller kernel footprint</strong> - generic classification engine</li>
<li><strong>No protocol-specific kernel modules</strong> required</li>
</ul>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<ul>
<li>Single <code>nft</code> command for all operations</li>
<li>Address family support: IPv4, IPv6, ARP, bridge, inet (IPv4+IPv6), netdev</li>
<li>Advanced data structures: sets, maps, dictionaries</li>
<li>Concatenations for multi-dimensional matching</li>
<li>Native support for intervals and ranges</li>
<li>Better integration with connection tracking</li>
<li>JSON API for programmatic access</li>
<li>Improved rule debugging and tracing</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="netfilter-hooks"><a class="header" href="#netfilter-hooks">Netfilter Hooks</a></h3>
<p>nftables uses the same Netfilter hooks as iptables:</p>
<pre><code>                                   ┌──────────────┐
                                   │   Network    │
                                   │   Interface  │
                                   └──────┬───────┘
                                          │
                                          ▼
                                   ┌──────────────┐
                                   │  PREROUTING  │ ◄── DNAT, early filtering
                                   └──────┬───────┘
                                          │
                              ┌───────────┴───────────┐
                              │                       │
                              ▼                       ▼
                       ┌─────────────┐         ┌──────────┐
                       │   FORWARD   │         │  INPUT   │ ◄── Local process
                       └──────┬──────┘         └──────────┘
                              │                       ▲
                              │                       │
                              ▼                 ┌──────────┐
                       ┌─────────────┐         │  OUTPUT  │ ◄── Locally generated
                       │ POSTROUTING │         └──────────┘
                       └──────┬──────┘               ▲
                              │                       │
                              └───────────┬───────────┘
                                          │
                                          ▼
                                   ┌──────────────┐
                                   │   Network    │
                                   │   Interface  │
                                   └──────────────┘
</code></pre>
<h3 id="address-families"><a class="header" href="#address-families">Address Families</a></h3>
<p>nftables organizes rules by address family:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Family</th><th>Description</th><th>Kernel support</th></tr>
</thead>
<tbody>
<tr><td><code>ip</code></td><td>IPv4 packets only</td><td>3.13+</td></tr>
<tr><td><code>ip6</code></td><td>IPv6 packets only</td><td>3.13+</td></tr>
<tr><td><code>inet</code></td><td>Both IPv4 and IPv6 (recommended)</td><td>3.14+</td></tr>
<tr><td><code>arp</code></td><td>ARP packets</td><td>3.13+</td></tr>
<tr><td><code>bridge</code></td><td>Bridge layer (ebtables replacement)</td><td>3.18+</td></tr>
<tr><td><code>netdev</code></td><td>Ingress hook (pre-routing)</td><td>4.2+</td></tr>
</tbody>
</table>
</div>
<h3 id="components-hierarchy"><a class="header" href="#components-hierarchy">Components Hierarchy</a></h3>
<pre><code>Address Family (ip, ip6, inet, arp, bridge, netdev)
  │
  └── Table (filter, nat, mangle, etc. - arbitrary names)
       │
       └── Chain (input, forward, output, prerouting, postrouting - arbitrary names)
            │
            └── Rule (match expressions + verdict)
</code></pre>
<h3 id="tables"><a class="header" href="#tables">Tables</a></h3>
<p>Tables are containers for chains. Unlike iptables, table names are arbitrary and you can create custom tables:</p>
<pre><code class="language-bash"># Create a custom table
nft add table inet my_firewall

# List all tables
nft list tables

# Delete a table
nft delete table inet my_firewall
</code></pre>
<h3 id="chains"><a class="header" href="#chains">Chains</a></h3>
<p>Chains contain rules. There are two types:</p>
<ol>
<li><strong>Base chains</strong> - attached to netfilter hooks</li>
<li><strong>Regular chains</strong> - for jump targets (like custom chains in iptables)</li>
</ol>
<p>Base chain properties:</p>
<ul>
<li><code>type</code>: filter, nat, route</li>
<li><code>hook</code>: prerouting, input, forward, output, postrouting</li>
<li><code>priority</code>: integer value (lower = earlier processing)</li>
<li><code>policy</code>: accept, drop (default verdict)</li>
</ul>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>Rules consist of:</p>
<ul>
<li><strong>Match expressions</strong> - conditions to match packets</li>
<li><strong>Statements</strong> - actions to take (verdict, counter, log, etc.)</li>
</ul>
<h3 id="verdicts"><a class="header" href="#verdicts">Verdicts</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Verdict</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>accept</code></td><td>Accept the packet</td></tr>
<tr><td><code>drop</code></td><td>Drop the packet silently</td></tr>
<tr><td><code>reject</code></td><td>Drop with ICMP/TCP RST error</td></tr>
<tr><td><code>queue</code></td><td>Pass to userspace</td></tr>
<tr><td><code>continue</code></td><td>Continue evaluation with next rule</td></tr>
<tr><td><code>return</code></td><td>Return to calling chain</td></tr>
<tr><td><code>jump &lt;chain&gt;</code></td><td>Jump to chain</td></tr>
<tr><td><code>goto &lt;chain&gt;</code></td><td>Goto chain (can’t return)</td></tr>
</tbody>
</table>
</div>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h3>
<pre><code class="language-bash"># Install nftables
sudo apt update
sudo apt install nftables

# Check version
nft --version

# Enable service
sudo systemctl enable nftables
sudo systemctl start nftables
</code></pre>
<h3 id="red-hatcentosfedora"><a class="header" href="#red-hatcentosfedora">Red Hat/CentOS/Fedora</a></h3>
<pre><code class="language-bash"># Install nftables
sudo dnf install nftables

# Enable service
sudo systemctl enable nftables
sudo systemctl start nftables
</code></pre>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<pre><code class="language-bash"># Install nftables
sudo pacman -S nftables

# Enable service
sudo systemctl enable nftables
sudo systemctl start nftables
</code></pre>
<h3 id="kernel-requirements"><a class="header" href="#kernel-requirements">Kernel Requirements</a></h3>
<ul>
<li>Minimum kernel: 3.13</li>
<li>Recommended: 4.14+ for full feature set</li>
<li>Check kernel support:</li>
</ul>
<pre><code class="language-bash"># Check if nftables module is loaded
lsmod | grep nf_tables

# Load module manually
sudo modprobe nf_tables
</code></pre>
<h2 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h2>
<h3 id="creating-tables"><a class="header" href="#creating-tables">Creating Tables</a></h3>
<pre><code class="language-bash"># Create IPv4 table
nft add table ip my_filter

# Create IPv6 table
nft add table ip6 my_filter6

# Create dual-stack table (recommended)
nft add table inet my_filter

# Create table for bridge
nft add table bridge br_filter
</code></pre>
<h3 id="creating-chains"><a class="header" href="#creating-chains">Creating Chains</a></h3>
<pre><code class="language-bash"># Create base chain for input filtering
nft add chain inet my_filter input { \
    type filter hook input priority 0 \; \
    policy drop \; \
}

# Create base chain for output
nft add chain inet my_filter output { \
    type filter hook output priority 0 \; \
    policy accept \; \
}

# Create regular chain (for jumping)
nft add chain inet my_filter tcp_chain
</code></pre>
<h3 id="chain-priorities"><a class="header" href="#chain-priorities">Chain Priorities</a></h3>
<p>Priority determines chain order (lower number = earlier processing):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Priority</th><th>Name</th><th>Value</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>NF_IP_PRI_CONNTRACK_DEFRAG</td><td></td><td>-400</td><td>Defragmentation</td></tr>
<tr><td>NF_IP_PRI_RAW</td><td>raw</td><td>-300</td><td>Before connection tracking</td></tr>
<tr><td>NF_IP_PRI_SELINUX_FIRST</td><td></td><td>-225</td><td>SELinux operations</td></tr>
<tr><td>NF_IP_PRI_CONNTRACK</td><td></td><td>-200</td><td>Connection tracking</td></tr>
<tr><td>NF_IP_PRI_MANGLE</td><td>mangle</td><td>-150</td><td>Packet mangling</td></tr>
<tr><td>NF_IP_PRI_NAT_DST</td><td>dstnat</td><td>-100</td><td>DNAT</td></tr>
<tr><td>NF_IP_PRI_FILTER</td><td>filter</td><td>0</td><td>Standard filtering</td></tr>
<tr><td>NF_IP_PRI_SECURITY</td><td>security</td><td>50</td><td>Security tables</td></tr>
<tr><td>NF_IP_PRI_NAT_SRC</td><td>srcnat</td><td>100</td><td>SNAT</td></tr>
<tr><td>NF_IP_PRI_SELINUX_LAST</td><td></td><td>225</td><td>SELinux</td></tr>
<tr><td>NF_IP_PRI_CONNTRACK_HELPER</td><td></td><td>300</td><td>Connection tracking helpers</td></tr>
</tbody>
</table>
</div>
<h3 id="adding-rules"><a class="header" href="#adding-rules">Adding Rules</a></h3>
<pre><code class="language-bash"># Add rule to accept established connections
nft add rule inet my_filter input ct state established,related accept

# Add rule to drop invalid packets
nft add rule inet my_filter input ct state invalid drop

# Add rule to accept SSH
nft add rule inet my_filter input tcp dport 22 accept

# Insert rule at beginning (position 0)
nft insert rule inet my_filter input position 0 ct state new accept

# Add rule with counter
nft add rule inet my_filter input tcp dport 80 counter accept

# Add rule with log
nft add rule inet my_filter input tcp dport 443 log prefix \"HTTPS: \" accept
</code></pre>
<h3 id="listing-rules"><a class="header" href="#listing-rules">Listing Rules</a></h3>
<pre><code class="language-bash"># List all rules
nft list ruleset

# List specific table
nft list table inet my_filter

# List specific chain
nft list chain inet my_filter input

# List with handles (for deletion)
nft --handle list ruleset

# List in JSON format
nft -j list ruleset

# List with counters
nft list table inet my_filter
</code></pre>
<h3 id="deleting-rules"><a class="header" href="#deleting-rules">Deleting Rules</a></h3>
<pre><code class="language-bash"># Delete rule by handle
nft delete rule inet my_filter input handle 5

# Delete entire chain
nft delete chain inet my_filter input

# Delete entire table
nft delete table inet my_filter

# Flush all rules in chain (keep chain)
nft flush chain inet my_filter input

# Flush all rules in table
nft flush table inet my_filter

# Flush everything
nft flush ruleset
</code></pre>
<h3 id="saving-and-restoring"><a class="header" href="#saving-and-restoring">Saving and Restoring</a></h3>
<pre><code class="language-bash"># Save current ruleset to file
nft list ruleset &gt; /etc/nftables.conf

# Restore from file
nft -f /etc/nftables.conf

# Atomic replacement (test mode)
nft -c -f /etc/nftables.conf  # Check syntax only
nft -f /etc/nftables.conf      # Apply if syntax OK

# Debian/Ubuntu service uses
/etc/nftables.conf
</code></pre>
<h2 id="basic-filtering"><a class="header" href="#basic-filtering">Basic Filtering</a></h2>
<h3 id="protocol-filtering"><a class="header" href="#protocol-filtering">Protocol Filtering</a></h3>
<pre><code class="language-bash"># Accept TCP traffic
nft add rule inet my_filter input ip protocol tcp accept

# Accept UDP traffic
nft add rule inet my_filter input ip protocol udp accept

# Accept ICMP (IPv4)
nft add rule inet my_filter input ip protocol icmp accept

# Accept ICMPv6
nft add rule inet my_filter input meta l4proto ipv6-icmp accept

# Shorter syntax using meta
nft add rule inet my_filter input meta l4proto tcp accept
nft add rule inet my_filter input meta l4proto udp accept
</code></pre>
<h3 id="port-filtering"><a class="header" href="#port-filtering">Port Filtering</a></h3>
<pre><code class="language-bash"># Single port (SSH)
nft add rule inet my_filter input tcp dport 22 accept

# Multiple ports
nft add rule inet my_filter input tcp dport { 80, 443, 8080 } accept

# Port range
nft add rule inet my_filter input tcp dport 1024-65535 accept

# Source port
nft add rule inet my_filter output tcp sport 22 accept

# Both source and destination
nft add rule inet my_filter forward tcp sport 1024-65535 tcp dport 80 accept
</code></pre>
<h3 id="ip-address-filtering"><a class="header" href="#ip-address-filtering">IP Address Filtering</a></h3>
<pre><code class="language-bash"># Single IP address
nft add rule inet my_filter input ip saddr 192.168.1.100 accept

# CIDR notation
nft add rule inet my_filter input ip saddr 192.168.1.0/24 accept

# Multiple IPs
nft add rule inet my_filter input ip saddr { 192.168.1.100, 192.168.1.101 } accept

# IP range
nft add rule inet my_filter input ip saddr 192.168.1.100-192.168.1.200 accept

# Destination address
nft add rule inet my_filter output ip daddr 8.8.8.8 accept

# IPv6 address
nft add rule inet my_filter input ip6 saddr 2001:db8::/32 accept
</code></pre>
<h3 id="interface-filtering"><a class="header" href="#interface-filtering">Interface Filtering</a></h3>
<pre><code class="language-bash"># Input interface
nft add rule inet my_filter input iifname "eth0" accept

# Output interface
nft add rule inet my_filter output oifname "eth0" accept

# Multiple interfaces
nft add rule inet my_filter input iifname { "eth0", "eth1" } accept

# Wildcard matching
nft add rule inet my_filter input iifname "eth*" accept

# Loopback
nft add rule inet my_filter input iifname "lo" accept
</code></pre>
<h3 id="mac-address-filtering"><a class="header" href="#mac-address-filtering">MAC Address Filtering</a></h3>
<pre><code class="language-bash"># Match source MAC
nft add rule inet my_filter input ether saddr 00:11:22:33:44:55 accept

# Match destination MAC
nft add rule inet my_filter input ether daddr 00:11:22:33:44:55 accept

# Multiple MACs
nft add rule inet my_filter input ether saddr { \
    00:11:22:33:44:55, \
    00:11:22:33:44:56 \
} accept
</code></pre>
<h3 id="connection-state-filtering"><a class="header" href="#connection-state-filtering">Connection State Filtering</a></h3>
<pre><code class="language-bash"># Accept established and related connections
nft add rule inet my_filter input ct state established,related accept

# Drop invalid packets
nft add rule inet my_filter input ct state invalid drop

# Accept new connections on specific port
nft add rule inet my_filter input tcp dport 80 ct state new accept

# Match specific states
nft add rule inet my_filter input ct state { established, related, new } accept

# Connection tracking states:
# - new: First packet of connection
# - established: Part of existing connection
# - related: Related to established connection (e.g., FTP data)
# - invalid: Packet doesn't match any connection
# - untracked: Packet marked to bypass tracking
</code></pre>
<h3 id="icmp-filtering"><a class="header" href="#icmp-filtering">ICMP Filtering</a></h3>
<pre><code class="language-bash"># Accept all ICMP (IPv4)
nft add rule inet my_filter input ip protocol icmp accept

# Accept specific ICMP types (echo-request = ping)
nft add rule inet my_filter input icmp type echo-request accept

# Accept echo-reply
nft add rule inet my_filter input icmp type echo-reply accept

# Limit ping rate
nft add rule inet my_filter input icmp type echo-request limit rate 5/second accept

# ICMPv6 essential types (required for IPv6)
nft add rule inet my_filter input icmpv6 type { \
    destination-unreachable, \
    packet-too-big, \
    time-exceeded, \
    parameter-problem, \
    echo-request, \
    echo-reply \
} accept

# IPv6 neighbor discovery (required)
nft add rule inet my_filter input icmpv6 type { \
    nd-neighbor-solicit, \
    nd-neighbor-advert, \
    nd-router-advert, \
    nd-router-solicit \
} accept
</code></pre>
<h3 id="tcp-flags-filtering"><a class="header" href="#tcp-flags-filtering">TCP Flags Filtering</a></h3>
<pre><code class="language-bash"># Match SYN packets (new connections)
nft add rule inet my_filter input tcp flags syn tcp flags != ack counter

# Drop NULL packets
nft add rule inet my_filter input tcp flags == 0 drop

# Drop FIN+SYN packets (XMAS)
nft add rule inet my_filter input tcp flags \&amp; (fin|syn) == (fin|syn) drop

# Drop SYN+RST packets
nft add rule inet my_filter input tcp flags \&amp; (syn|rst) == (syn|rst) drop

# Accept only SYN for new connections
nft add rule inet my_filter input ct state new tcp flags != syn drop
</code></pre>
<h2 id="nat-network-address-translation"><a class="header" href="#nat-network-address-translation">NAT (Network Address Translation)</a></h2>
<h3 id="nat-table-setup"><a class="header" href="#nat-table-setup">NAT Table Setup</a></h3>
<pre><code class="language-bash"># Create NAT table
nft add table inet nat

# Create prerouting chain for DNAT
nft add chain inet nat prerouting { \
    type nat hook prerouting priority -100 \; \
}

# Create postrouting chain for SNAT
nft add chain inet nat postrouting { \
    type nat hook postrouting priority 100 \; \
}
</code></pre>
<h3 id="snat-source-nat"><a class="header" href="#snat-source-nat">SNAT (Source NAT)</a></h3>
<pre><code class="language-bash"># SNAT to specific IP
nft add rule inet nat postrouting oifname "eth0" ip saddr 192.168.1.0/24 snat to 203.0.113.1

# SNAT with port range
nft add rule inet nat postrouting oifname "eth0" snat to 203.0.113.1:1024-65535

# SNAT to multiple IPs (load balancing)
nft add rule inet nat postrouting oifname "eth0" snat to 203.0.113.1-203.0.113.10

# Conditional SNAT
nft add rule inet nat postrouting oifname "eth0" ip daddr != 192.168.0.0/16 snat to 203.0.113.1
</code></pre>
<h3 id="masquerading"><a class="header" href="#masquerading">Masquerading</a></h3>
<p>Masquerading is SNAT with automatic IP detection (useful for dynamic IPs):</p>
<pre><code class="language-bash"># Basic masquerading
nft add rule inet nat postrouting oifname "eth0" masquerade

# Masquerade with port range
nft add rule inet nat postrouting oifname "eth0" masquerade to :1024-65535

# Masquerade specific subnet
nft add rule inet nat postrouting oifname "ppp0" ip saddr 192.168.1.0/24 masquerade

# Masquerade for IPv6
nft add rule inet nat postrouting oifname "eth0" ip6 saddr fd00::/64 masquerade
</code></pre>
<h3 id="dnat-destination-nat"><a class="header" href="#dnat-destination-nat">DNAT (Destination NAT)</a></h3>
<pre><code class="language-bash"># Port forwarding (simple)
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to 192.168.1.100

# Port forwarding with port change
nft add rule inet nat prerouting iifname "eth0" tcp dport 8080 dnat to 192.168.1.100:80

# DNAT with IP range (load balancing)
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to 192.168.1.100-192.168.1.110

# DNAT with port range
nft add rule inet nat prerouting tcp dport 5000-5999 dnat to 192.168.1.100:6000-6999

# Conditional DNAT
nft add rule inet nat prerouting iifname "eth0" ip saddr 203.0.113.0/24 tcp dport 80 dnat to 192.168.1.100
</code></pre>
<h3 id="port-forwarding-examples"><a class="header" href="#port-forwarding-examples">Port Forwarding Examples</a></h3>
<pre><code class="language-bash"># Forward HTTP to internal server
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to 192.168.1.10:80

# Forward HTTPS to internal server
nft add rule inet nat prerouting iifname "eth0" tcp dport 443 dnat to 192.168.1.10:443

# Forward SSH to different port
nft add rule inet nat prerouting iifname "eth0" tcp dport 2222 dnat to 192.168.1.10:22

# Forward range of ports
nft add rule inet nat prerouting iifname "eth0" tcp dport 3000-3100 dnat to 192.168.1.10

# Forward to multiple servers (round-robin)
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to numgen inc mod 3 map { \
    0 : 192.168.1.10, \
    1 : 192.168.1.11, \
    2 : 192.168.1.12 \
}
</code></pre>
<h3 id="11-nat"><a class="header" href="#11-nat">1:1 NAT</a></h3>
<pre><code class="language-bash"># Bidirectional 1:1 NAT
# Public IP 203.0.113.10 &lt;-&gt; Private IP 192.168.1.10

# DNAT (inbound)
nft add rule inet nat prerouting iifname "eth0" ip daddr 203.0.113.10 dnat to 192.168.1.10

# SNAT (outbound)
nft add rule inet nat postrouting oifname "eth0" ip saddr 192.168.1.10 snat to 203.0.113.10
</code></pre>
<h3 id="hairpin-nat-nat-loopback"><a class="header" href="#hairpin-nat-nat-loopback">Hairpin NAT (NAT Loopback)</a></h3>
<p>Allow internal hosts to access internal servers via public IP:</p>
<pre><code class="language-bash"># Create filter table rule to allow forwarding
nft add rule inet filter forward iifname "br0" oifname "br0" accept

# DNAT for external access
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to 192.168.1.10:80

# SNAT for hairpin (internal to internal via public IP)
nft add rule inet nat postrouting oifname "br0" ip saddr 192.168.1.0/24 ip daddr 192.168.1.10 masquerade

# DNAT for hairpin
nft add rule inet nat prerouting iifname "br0" tcp dport 80 dnat to 192.168.1.10:80
</code></pre>
<h3 id="full-nat-example-router"><a class="header" href="#full-nat-example-router">Full NAT Example (Router)</a></h3>
<pre><code class="language-bash"># Enable IP forwarding
echo 1 &gt; /proc/sys/net/ipv4/ip_forward

# Create tables
nft add table inet filter
nft add table inet nat

# Filter chains
nft add chain inet filter input { type filter hook input priority 0 \; policy drop \; }
nft add chain inet filter forward { type filter hook forward priority 0 \; policy drop \; }
nft add chain inet filter output { type filter hook output priority 0 \; policy accept \; }

# NAT chains
nft add chain inet nat prerouting { type nat hook prerouting priority -100 \; }
nft add chain inet nat postrouting { type nat hook postrouting priority 100 \; }

# Input rules
nft add rule inet filter input iifname "lo" accept
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input iifname "eth1" ct state new accept  # LAN
nft add rule inet filter input icmp type echo-request limit rate 5/second accept

# Forward rules
nft add rule inet filter forward ct state established,related accept
nft add rule inet filter forward iifname "eth1" oifname "eth0" accept  # LAN to WAN

# NAT rules
nft add rule inet nat postrouting oifname "eth0" masquerade

# Port forwarding (example: web server)
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to 192.168.1.10
nft add rule inet filter forward iifname "eth0" oifname "eth1" tcp dport 80 ct state new accept
</code></pre>
<h2 id="advanced-features---sets"><a class="header" href="#advanced-features---sets">Advanced Features - Sets</a></h2>
<p>Sets are collections of elements that can be matched efficiently.</p>
<h3 id="anonymous-sets"><a class="header" href="#anonymous-sets">Anonymous Sets</a></h3>
<p>Anonymous sets are defined inline with the rule:</p>
<pre><code class="language-bash"># Set of ports
nft add rule inet my_filter input tcp dport { 22, 80, 443 } accept

# Set of IP addresses
nft add rule inet my_filter input ip saddr { 192.168.1.1, 192.168.1.2 } accept

# Mixed set
nft add rule inet my_filter input tcp dport { 22, 80, 443, 8080-8090 } accept
</code></pre>
<h3 id="named-sets"><a class="header" href="#named-sets">Named Sets</a></h3>
<p>Named sets can be reused across multiple rules:</p>
<pre><code class="language-bash"># Create set of IPv4 addresses
nft add set inet my_filter allowed_ips { \
    type ipv4_addr \; \
    flags interval \; \
}

# Add elements to set
nft add element inet my_filter allowed_ips { 192.168.1.1, 192.168.1.2, 192.168.1.0/24 }

# Use set in rule
nft add rule inet my_filter input ip saddr @allowed_ips accept

# Create set of ports
nft add set inet my_filter web_ports { \
    type inet_service \; \
}

nft add element inet my_filter web_ports { 80, 443, 8080, 8443 }
nft add rule inet my_filter input tcp dport @web_ports accept
</code></pre>
<h3 id="dynamic-sets-with-timeout"><a class="header" href="#dynamic-sets-with-timeout">Dynamic Sets (with Timeout)</a></h3>
<pre><code class="language-bash"># Create dynamic set with timeout
nft add set inet my_filter blocklist { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 1h \; \
}

# Add to set dynamically with update statement
nft add rule inet my_filter input tcp dport 22 ct state new \
    add @blocklist { ip saddr timeout 1h } \
    counter

# Drop packets from blocklist
nft add rule inet my_filter input ip saddr @blocklist drop
</code></pre>
<h3 id="set-types"><a class="header" href="#set-types">Set Types</a></h3>
<p>Available set types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ipv4_addr</code></td><td>IPv4 address</td></tr>
<tr><td><code>ipv6_addr</code></td><td>IPv6 address</td></tr>
<tr><td><code>ether_addr</code></td><td>Ethernet (MAC) address</td></tr>
<tr><td><code>inet_proto</code></td><td>Internet protocol (tcp, udp, etc.)</td></tr>
<tr><td><code>inet_service</code></td><td>Port number</td></tr>
<tr><td><code>mark</code></td><td>Packet mark</td></tr>
<tr><td><code>ifname</code></td><td>Interface name</td></tr>
</tbody>
</table>
</div>
<h3 id="intervals-in-sets"><a class="header" href="#intervals-in-sets">Intervals in Sets</a></h3>
<pre><code class="language-bash"># Create set with interval support
nft add set inet my_filter ip_ranges { \
    type ipv4_addr \; \
    flags interval \; \
}

# Add IP ranges
nft add element inet my_filter ip_ranges { \
    10.0.0.0-10.0.0.255, \
    192.168.0.0/16, \
    172.16.0.1-172.16.255.254 \
}

# Use in rule
nft add rule inet my_filter input ip saddr @ip_ranges drop
</code></pre>
<h3 id="blacklist-example"><a class="header" href="#blacklist-example">Blacklist Example</a></h3>
<pre><code class="language-bash"># Create blacklist set
nft add set inet my_filter blacklist { \
    type ipv4_addr \; \
    flags interval \; \
}

# Add malicious IPs
nft add element inet my_filter blacklist { \
    198.51.100.0/24, \
    203.0.113.0/24 \
}

# Drop traffic from blacklist (put early in chain)
nft insert rule inet my_filter input ip saddr @blacklist drop

# Add to blacklist on-the-fly
nft add element inet my_filter blacklist { 192.0.2.100 }
</code></pre>
<h3 id="whitelist-example"><a class="header" href="#whitelist-example">Whitelist Example</a></h3>
<pre><code class="language-bash"># Create whitelist
nft add set inet my_filter whitelist { \
    type ipv4_addr \; \
    flags interval \; \
}

# Add trusted IPs
nft add element inet my_filter whitelist { \
    192.168.1.0/24, \
    10.0.0.0/8 \
}

# Allow SSH only from whitelist
nft add rule inet my_filter input tcp dport 22 ip saddr @whitelist accept
nft add rule inet my_filter input tcp dport 22 drop
</code></pre>
<h3 id="port-knock-implementation"><a class="header" href="#port-knock-implementation">Port Knock Implementation</a></h3>
<pre><code class="language-bash"># Create sets for port knock sequence
nft add set inet my_filter knock1 { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 5s \; \
}

nft add set inet my_filter knock2 { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 5s \; \
}

nft add set inet my_filter knock3 { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 5s \; \
}

nft add set inet my_filter authorized { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 30s \; \
}

# Knock sequence: 7000, 8000, 9000
nft add rule inet my_filter input tcp dport 7000 \
    add @knock1 { ip saddr }

nft add rule inet my_filter input ip saddr @knock1 tcp dport 8000 \
    add @knock2 { ip saddr }

nft add rule inet my_filter input ip saddr @knock2 tcp dport 9000 \
    add @authorized { ip saddr timeout 30s }

# Allow SSH from authorized IPs
nft add rule inet my_filter input ip saddr @authorized tcp dport 22 accept
</code></pre>
<h2 id="advanced-features---maps"><a class="header" href="#advanced-features---maps">Advanced Features - Maps</a></h2>
<p>Maps associate keys with values for dynamic packet handling.</p>
<h3 id="basic-maps"><a class="header" href="#basic-maps">Basic Maps</a></h3>
<pre><code class="language-bash"># Create map for port-based NAT
nft add map inet nat port_nat { \
    type inet_service : ipv4_addr \; \
}

# Add mappings
nft add element inet nat port_nat { \
    80 : 192.168.1.10, \
    443 : 192.168.1.11, \
    25 : 192.168.1.12 \
}

# Use map for DNAT
nft add rule inet nat prerouting dnat to tcp dport map @port_nat
</code></pre>
<h3 id="verdict-maps"><a class="header" href="#verdict-maps">Verdict Maps</a></h3>
<p>Maps can return verdicts:</p>
<pre><code class="language-bash"># Create verdict map
nft add map inet my_filter port_policy { \
    type inet_service : verdict \; \
}

# Add port policies
nft add element inet my_filter port_policy { \
    22 : accept, \
    80 : accept, \
    443 : accept, \
    23 : drop \
}

# Apply map
nft add rule inet my_filter input tcp dport vmap @port_policy
</code></pre>
<h3 id="ip-based-routing-map"><a class="header" href="#ip-based-routing-map">IP-based Routing Map</a></h3>
<pre><code class="language-bash"># Create map for different SNAT based on destination
nft add map inet nat snat_map { \
    type ipv4_addr : ipv4_addr \; \
    flags interval \; \
}

nft add element inet nat snat_map { \
    10.0.0.0/8 : 192.168.1.1, \
    172.16.0.0/12 : 192.168.1.2, \
    0.0.0.0/0 : 203.0.113.1 \
}

nft add rule inet nat postrouting snat to ip daddr map @snat_map
</code></pre>
<h3 id="counter-map"><a class="header" href="#counter-map">Counter Map</a></h3>
<pre><code class="language-bash"># Create map for per-port counters
nft add map inet my_filter port_counters { \
    type inet_service : counter \; \
}

# Initialize counters
nft add element inet my_filter port_counters { \
    80 : counter, \
    443 : counter, \
    22 : counter \
}

# Count packets per port
nft add rule inet my_filter input tcp dport vmap @port_counters { \
    80 : accept, \
    443 : accept, \
    22 : accept \
}
</code></pre>
<h3 id="load-balancing-with-maps"><a class="header" href="#load-balancing-with-maps">Load Balancing with Maps</a></h3>
<pre><code class="language-bash"># Round-robin load balancing
nft add rule inet nat prerouting tcp dport 80 dnat to numgen inc mod 3 map { \
    0 : 192.168.1.10, \
    1 : 192.168.1.11, \
    2 : 192.168.1.12 \
}

# Random load balancing
nft add rule inet nat prerouting tcp dport 80 dnat to numgen random mod 3 map { \
    0 : 192.168.1.10, \
    1 : 192.168.1.11, \
    2 : 192.168.1.12 \
}

# Hash-based (consistent hashing)
nft add rule inet nat prerouting tcp dport 80 dnat to jhash ip saddr mod 3 map { \
    0 : 192.168.1.10, \
    1 : 192.168.1.11, \
    2 : 192.168.1.12 \
}
</code></pre>
<h2 id="advanced-features---concatenations"><a class="header" href="#advanced-features---concatenations">Advanced Features - Concatenations</a></h2>
<p>Concatenations allow matching multiple criteria simultaneously.</p>
<h3 id="basic-concatenation"><a class="header" href="#basic-concatenation">Basic Concatenation</a></h3>
<pre><code class="language-bash"># Match IP and port combination
nft add rule inet my_filter input ip saddr . tcp dport { \
    192.168.1.10 . 22, \
    192.168.1.11 . 80, \
    192.168.1.12 . 443 \
} accept
</code></pre>
<h3 id="concatenation-sets"><a class="header" href="#concatenation-sets">Concatenation Sets</a></h3>
<pre><code class="language-bash"># Create set with concatenation
nft add set inet my_filter allowed_connections { \
    type ipv4_addr . inet_service \; \
}

# Add elements
nft add element inet my_filter allowed_connections { \
    192.168.1.10 . 22, \
    192.168.1.10 . 80, \
    192.168.1.11 . 443 \
}

# Use in rule
nft add rule inet my_filter input ip saddr . tcp dport @allowed_connections accept
</code></pre>
<h3 id="concatenation-maps"><a class="header" href="#concatenation-maps">Concatenation Maps</a></h3>
<pre><code class="language-bash"># Create map with concatenated key
nft add map inet nat dnat_map { \
    type ipv4_addr . inet_service : ipv4_addr . inet_service \; \
}

# Add mappings (public IP:port -&gt; internal IP:port)
nft add element inet nat dnat_map { \
    203.0.113.1 . 80 : 192.168.1.10 . 80, \
    203.0.113.1 . 443 : 192.168.1.10 . 443, \
    203.0.113.1 . 25 : 192.168.1.11 . 25 \
}

# Use for DNAT
nft add rule inet nat prerouting dnat to ip daddr . tcp dport map @dnat_map
</code></pre>
<h3 id="interface--ip-concatenation"><a class="header" href="#interface--ip-concatenation">Interface + IP Concatenation</a></h3>
<pre><code class="language-bash"># Create set for interface and IP
nft add set inet my_filter trusted_sources { \
    type ifname . ipv4_addr \; \
}

# Add trusted sources
nft add element inet my_filter trusted_sources { \
    "eth0" . 192.168.1.0/24, \
    "eth1" . 10.0.0.0/8 \
}

# Use in rule
nft add rule inet my_filter input iifname . ip saddr @trusted_sources accept
</code></pre>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<h3 id="basic-rate-limiting"><a class="header" href="#basic-rate-limiting">Basic Rate Limiting</a></h3>
<pre><code class="language-bash"># Limit ICMP to 5 per second
nft add rule inet my_filter input icmp type echo-request limit rate 5/second accept

# Limit SSH connections (per source)
nft add rule inet my_filter input tcp dport 22 ct state new limit rate 3/minute accept

# Limit with burst
nft add rule inet my_filter input tcp dport 80 limit rate 100/second burst 200 packets accept
</code></pre>
<h3 id="rate-limiting-units"><a class="header" href="#rate-limiting-units">Rate Limiting Units</a></h3>
<pre><code class="language-bash"># Per second
nft add rule inet my_filter input limit rate 10/second accept

# Per minute
nft add rule inet my_filter input limit rate 60/minute accept

# Per hour
nft add rule inet my_filter input limit rate 1000/hour accept

# Per day
nft add rule inet my_filter input limit rate 10000/day accept

# Bytes per second
nft add rule inet my_filter input limit rate 1 mbytes/second accept
</code></pre>
<h3 id="per-source-rate-limiting"><a class="header" href="#per-source-rate-limiting">Per-Source Rate Limiting</a></h3>
<pre><code class="language-bash"># Create dynamic set for rate limiting per IP
nft add set inet my_filter rate_limit { \
    type ipv4_addr \; \
    size 65535 \; \
    flags dynamic \; \
}

# Limit new connections per source
nft add rule inet my_filter input tcp dport 80 ct state new \
    meter rate_limit { ip saddr limit rate 10/second } accept

# Alternative syntax
nft add rule inet my_filter input tcp dport 22 ct state new \
    meter ssh_limit { ip saddr timeout 1m limit rate 3/minute } accept
</code></pre>
<h3 id="syn-flood-protection"><a class="header" href="#syn-flood-protection">SYN Flood Protection</a></h3>
<pre><code class="language-bash"># Limit SYN packets
nft add rule inet my_filter input tcp flags syn tcp flags \&amp; \(fin\|syn\|rst\|ack\) == syn \
    meter syn_flood { ip saddr timeout 10s limit rate 25/second burst 50 packets } accept

nft add rule inet my_filter input tcp flags syn drop
</code></pre>
<h3 id="http-rate-limiting"><a class="header" href="#http-rate-limiting">HTTP Rate Limiting</a></h3>
<pre><code class="language-bash"># Limit HTTP requests per IP
nft add rule inet my_filter input tcp dport 80 ct state new \
    meter http_meter { ip saddr timeout 10s limit rate 20/second } accept

nft add rule inet my_filter input tcp dport 80 ct state new \
    log prefix "HTTP RATE LIMIT: " drop
</code></pre>
<h3 id="quota-limiting"><a class="header" href="#quota-limiting">Quota Limiting</a></h3>
<pre><code class="language-bash"># Allow 1GB quota
nft add rule inet my_filter forward quota 1 gbytes accept
nft add rule inet my_filter forward counter drop

# Per-user quota (using marks)
nft add rule inet my_filter forward meta mark 1 quota 100 mbytes accept
nft add rule inet my_filter forward meta mark 1 drop
</code></pre>
<h2 id="connection-tracking"><a class="header" href="#connection-tracking">Connection Tracking</a></h2>
<h3 id="connection-tracking-states"><a class="header" href="#connection-tracking-states">Connection Tracking States</a></h3>
<pre><code class="language-bash"># Accept established connections
nft add rule inet my_filter input ct state established accept

# Accept related connections (e.g., FTP data channel)
nft add rule inet my_filter input ct state related accept

# Drop invalid packets
nft add rule inet my_filter input ct state invalid drop

# Allow new connections on specific ports
nft add rule inet my_filter input tcp dport 80 ct state new accept
</code></pre>
<h3 id="connection-tracking-helpers"><a class="header" href="#connection-tracking-helpers">Connection Tracking Helpers</a></h3>
<pre><code class="language-bash"># Load FTP helper
modprobe nf_conntrack_ftp

# Use FTP helper
nft add rule inet filter input ct helper "ftp" accept

# SIP helper
modprobe nf_conntrack_sip
nft add rule inet filter input tcp dport 5060 ct helper set "sip"
</code></pre>
<h3 id="connection-mark-connmark"><a class="header" href="#connection-mark-connmark">Connection Mark (connmark)</a></h3>
<pre><code class="language-bash"># Mark connections
nft add rule inet my_filter prerouting tcp dport 80 ct mark set 1

# Match by connection mark
nft add rule inet my_filter forward ct mark 1 accept

# Restore mark from connection
nft add rule inet my_filter output ct mark != 0 meta mark set ct mark

# Save mark to connection
nft add rule inet my_filter input meta mark != 0 ct mark set meta mark
</code></pre>
<h3 id="connection-zones"><a class="header" href="#connection-zones">Connection Zones</a></h3>
<pre><code class="language-bash"># Assign connection to zone
nft add rule inet my_filter prerouting ct zone 1

# Match by zone
nft add rule inet my_filter forward ct zone 1 accept
</code></pre>
<h3 id="connection-limits"><a class="header" href="#connection-limits">Connection Limits</a></h3>
<pre><code class="language-bash"># Limit concurrent connections per source
nft add rule inet my_filter input tcp dport 22 ct state new \
    meter ssh_conn { ip saddr ct count over 3 } drop

# Limit connections globally
nft add rule inet my_filter input tcp dport 80 ct state new \
    add @connlimit { ip saddr ct count over 10 } drop
</code></pre>
<h2 id="logging-and-monitoring"><a class="header" href="#logging-and-monitoring">Logging and Monitoring</a></h2>
<h3 id="basic-logging"><a class="header" href="#basic-logging">Basic Logging</a></h3>
<pre><code class="language-bash"># Log all dropped packets
nft add rule inet my_filter input counter log drop

# Log with prefix
nft add rule inet my_filter input log prefix "DROPPED: " drop

# Log to specific group (for ulogd)
nft add rule inet my_filter input log group 2 drop

# Log with level
nft add rule inet my_filter input log level warn prefix "SUSPICIOUS: " drop
</code></pre>
<h3 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h3>
<pre><code class="language-bash"># Available levels: emerg, alert, crit, err, warn, notice, info, debug

nft add rule inet my_filter input log level emerg prefix "EMERGENCY: " drop
nft add rule inet my_filter input log level info prefix "INFO: " accept
</code></pre>
<h3 id="selective-logging"><a class="header" href="#selective-logging">Selective Logging</a></h3>
<pre><code class="language-bash"># Log only SSH attempts
nft add rule inet my_filter input tcp dport 22 ct state new log prefix "SSH: "

# Log only rejected packets
nft add rule inet my_filter input tcp dport 23 log prefix "TELNET REJECT: " reject

# Log with rate limiting (avoid log flooding)
nft add rule inet my_filter input limit rate 5/minute log prefix "DROPPED: " drop
</code></pre>
<h3 id="packet-counters"><a class="header" href="#packet-counters">Packet Counters</a></h3>
<pre><code class="language-bash"># Add counter to rule
nft add rule inet my_filter input tcp dport 80 counter accept

# Named counter
nft add counter inet my_filter http_counter

nft add rule inet my_filter input tcp dport 80 counter name http_counter accept

# View counters
nft list counter inet my_filter http_counter

# Reset counter
nft reset counter inet my_filter http_counter
</code></pre>
<h3 id="traffic-statistics"><a class="header" href="#traffic-statistics">Traffic Statistics</a></h3>
<pre><code class="language-bash"># Add counters to chains
nft add chain inet my_filter input { \
    type filter hook input priority 0 \; \
    policy drop \; \
    counter \; \
}

# Per-rule statistics
nft add rule inet my_filter input tcp dport 22 counter name ssh_count accept
nft add rule inet my_filter input tcp dport 80 counter name http_count accept
nft add rule inet my_filter input tcp dport 443 counter name https_count accept

# View all counters
nft list counters inet my_filter
</code></pre>
<h3 id="packet-tracing"><a class="header" href="#packet-tracing">Packet Tracing</a></h3>
<pre><code class="language-bash"># Enable tracing for specific packets
nft add rule inet my_filter prerouting tcp dport 80 meta nftrace set 1

# Monitor trace events (in another terminal)
nft monitor trace

# Alternative: use nftrace
modprobe nf_tables_trace
nft add rule inet my_filter input ip saddr 192.168.1.100 meta nftrace set 1

# View in kernel log
dmesg | grep -i trace
</code></pre>
<h3 id="live-monitoring"><a class="header" href="#live-monitoring">Live Monitoring</a></h3>
<pre><code class="language-bash"># Monitor ruleset changes
nft monitor

# Monitor specific table
nft monitor tables

# Monitor trace events
nft monitor trace

# Monitor with JSON output
nft -j monitor
</code></pre>
<h2 id="security-patterns"><a class="header" href="#security-patterns">Security Patterns</a></h2>
<h3 id="drop-invalid-packets"><a class="header" href="#drop-invalid-packets">Drop Invalid Packets</a></h3>
<pre><code class="language-bash"># Drop packets with invalid connection state
nft add rule inet my_filter input ct state invalid log prefix "INVALID: " drop

# Drop NULL packets (no flags set)
nft add rule inet my_filter input tcp flags == 0 log prefix "NULL: " drop

# Drop XMAS packets (all flags set)
nft add rule inet my_filter input tcp flags \&amp; \(fin\|syn\|rst\|psh\|ack\|urg\) == \(fin\|syn\|rst\|psh\|ack\|urg\) drop

# Drop FIN without ACK
nft add rule inet my_filter input tcp flags \&amp; \(fin\|ack\) == fin drop

# Drop SYN+FIN
nft add rule inet my_filter input tcp flags \&amp; \(syn\|fin\) == \(syn\|fin\) drop
</code></pre>
<h3 id="syn-flood-protection-1"><a class="header" href="#syn-flood-protection-1">SYN Flood Protection</a></h3>
<pre><code class="language-bash"># Method 1: Rate limiting
nft add rule inet my_filter input tcp flags syn tcp flags \&amp; \(fin\|syn\|rst\|ack\) == syn \
    meter syn_meter { ip saddr timeout 10s limit rate 25/second burst 50 packets } accept
nft add rule inet my_filter input tcp flags syn log prefix "SYN FLOOD: " drop

# Method 2: SYN cookies (kernel parameter)
sysctl -w net.ipv4.tcp_syncookies=1

# Method 3: SYNPROXY (requires kernel 3.13+)
nft add rule inet my_filter input tcp dport 80 tcp flags syn notrack

nft add table inet synproxy_table
nft add chain inet synproxy_table prerouting { \
    type filter hook prerouting priority -300 \; \
}

nft add rule inet synproxy_table prerouting tcp dport 80 tcp flags syn \
    synproxy mss 1460 wscale 7 timestamp sack-perm
</code></pre>
<h3 id="brute-force-protection-ssh"><a class="header" href="#brute-force-protection-ssh">Brute Force Protection (SSH)</a></h3>
<pre><code class="language-bash"># Create dynamic blocklist
nft add set inet my_filter ssh_blocklist { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 1h \; \
}

# Block IPs in blocklist
nft add rule inet my_filter input ip saddr @ssh_blocklist drop

# Add to blocklist after 5 attempts in 1 minute
nft add rule inet my_filter input tcp dport 22 ct state new \
    meter ssh_meter { ip saddr timeout 1m limit rate over 5/minute } \
    add @ssh_blocklist { ip saddr timeout 1h } drop

# Allow SSH with rate limit
nft add rule inet my_filter input tcp dport 22 ct state new \
    limit rate 3/minute accept
</code></pre>
<h3 id="port-scan-detection"><a class="header" href="#port-scan-detection">Port Scan Detection</a></h3>
<pre><code class="language-bash"># Detect port scans (many SYN to different ports)
nft add set inet my_filter port_scanners { \
    type ipv4_addr \; \
    flags dynamic,timeout \; \
    timeout 1h \; \
}

# Block known scanners
nft add rule inet my_filter input ip saddr @port_scanners drop

# Detect scanning behavior
nft add rule inet my_filter input tcp flags syn ct state new \
    meter scan_meter { ip saddr timeout 10s limit rate over 20/second } \
    add @port_scanners { ip saddr timeout 1h } \
    log prefix "PORT SCAN: " drop
</code></pre>
<h3 id="anti-spoofing"><a class="header" href="#anti-spoofing">Anti-Spoofing</a></h3>
<pre><code class="language-bash"># Drop packets from private IPs on WAN interface
nft add rule inet my_filter input iifname "eth0" ip saddr { \
    10.0.0.0/8, \
    172.16.0.0/12, \
    192.168.0.0/16, \
    127.0.0.0/8, \
    169.254.0.0/16, \
    224.0.0.0/4, \
    240.0.0.0/4 \
} log prefix "SPOOFED: " drop

# Drop packets with source address matching our network
nft add rule inet my_filter input iifname "eth0" ip saddr 203.0.113.0/24 drop

# Reverse path filtering (use kernel parameter)
sysctl -w net.ipv4.conf.all.rp_filter=1
</code></pre>
<h3 id="geoip-blocking"><a class="header" href="#geoip-blocking">GeoIP Blocking</a></h3>
<p>Requires ipset with GeoIP database:</p>
<pre><code class="language-bash"># Create sets for countries (requires external GeoIP lists)
# Example: blocking traffic from specific countries

# Method 1: Using ipset (legacy)
# ipset create country-cn hash:net
# ipset add country-cn 1.0.1.0/24  # China IP blocks
# iptables -A INPUT -m set --match-set country-cn src -j DROP

# Method 2: Manual nftables sets
nft add set inet my_filter blocked_countries { \
    type ipv4_addr \; \
    flags interval \; \
}

# Add IP ranges for specific countries (example)
nft add element inet my_filter blocked_countries { \
    1.0.1.0/24, \
    1.0.2.0/23 \
}

nft add rule inet my_filter input ip saddr @blocked_countries drop
</code></pre>
<h3 id="ddos-protection"><a class="header" href="#ddos-protection">DDoS Protection</a></h3>
<pre><code class="language-bash"># Connection tracking table size (kernel parameter)
sysctl -w net.netfilter.nf_conntrack_max=1000000

# Drop flood of new connections
nft add rule inet my_filter input ct state new \
    meter ddos_meter { ip saddr timeout 10s limit rate over 100/second } \
    log prefix "DDoS: " drop

# Limit ICMP
nft add rule inet my_filter input icmp type echo-request \
    limit rate 5/second accept
nft add rule inet my_filter input icmp type echo-request drop

# UDP flood protection
nft add rule inet my_filter input meta l4proto udp \
    meter udp_meter { ip saddr timeout 10s limit rate over 50/second } drop

# Limit fragments
nft add rule inet my_filter input ip frag-off \&amp; 0x1fff != 0 \
    limit rate 10/second accept
nft add rule inet my_filter input ip frag-off \&amp; 0x1fff != 0 drop
</code></pre>
<h3 id="bogon-filtering"><a class="header" href="#bogon-filtering">Bogon Filtering</a></h3>
<pre><code class="language-bash"># Create bogon set (IP addresses that should not appear on Internet)
nft add set inet my_filter bogons { \
    type ipv4_addr \; \
    flags interval \; \
}

# Add bogon ranges
nft add element inet my_filter bogons { \
    0.0.0.0/8, \
    10.0.0.0/8, \
    100.64.0.0/10, \
    127.0.0.0/8, \
    169.254.0.0/16, \
    172.16.0.0/12, \
    192.0.0.0/24, \
    192.0.2.0/24, \
    192.168.0.0/16, \
    198.18.0.0/15, \
    198.51.100.0/24, \
    203.0.113.0/24, \
    224.0.0.0/4, \
    240.0.0.0/4 \
}

# Drop bogons on WAN
nft add rule inet my_filter input iifname "eth0" ip saddr @bogons drop
nft add rule inet my_filter input iifname "eth0" ip daddr @bogons drop
</code></pre>
<h2 id="complete-firewall-examples"><a class="header" href="#complete-firewall-examples">Complete Firewall Examples</a></h2>
<h3 id="example-1-basic-server-firewall"><a class="header" href="#example-1-basic-server-firewall">Example 1: Basic Server Firewall</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

# Flush existing rules
flush ruleset

# Create filter table
table inet filter {
    # Input chain
    chain input {
        type filter hook input priority 0; policy drop;

        # Allow loopback
        iifname "lo" accept

        # Allow established/related
        ct state established,related accept

        # Drop invalid
        ct state invalid drop

        # Allow ICMP
        ip protocol icmp accept
        ip6 nexthdr ipv6-icmp accept

        # Allow SSH (with rate limit)
        tcp dport 22 ct state new limit rate 3/minute accept

        # Allow HTTP/HTTPS
        tcp dport { 80, 443 } ct state new accept

        # Log dropped packets
        limit rate 5/minute log prefix "DROPPED: "
    }

    # Forward chain
    chain forward {
        type filter hook forward priority 0; policy drop;
    }

    # Output chain
    chain output {
        type filter hook output priority 0; policy accept;
    }
}
</code></pre>
<h3 id="example-2-web-server-with-rate-limiting"><a class="header" href="#example-2-web-server-with-rate-limiting">Example 2: Web Server with Rate Limiting</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

flush ruleset

table inet filter {
    # SSH brute force protection
    set ssh_blocklist {
        type ipv4_addr
        flags dynamic,timeout
        timeout 1h
    }

    # HTTP rate limiting
    set http_ratelimit {
        type ipv4_addr
        size 65535
        flags dynamic
    }

    chain input {
        type filter hook input priority 0; policy drop;

        # Loopback
        iifname "lo" accept

        # Established/related
        ct state established,related accept
        ct state invalid drop

        # ICMP
        ip protocol icmp limit rate 5/second accept
        ip6 nexthdr ipv6-icmp accept

        # SSH protection
        ip saddr @ssh_blocklist drop
        tcp dport 22 ct state new \
            meter ssh_meter { ip saddr timeout 1m limit rate over 5/minute } \
            add @ssh_blocklist { ip saddr timeout 1h } drop
        tcp dport 22 ct state new limit rate 3/minute accept

        # HTTP/HTTPS with rate limiting
        tcp dport { 80, 443 } ct state new \
            meter http_meter { ip saddr timeout 10s limit rate 50/second } accept
        tcp dport { 80, 443 } log prefix "HTTP RATE LIMIT: " drop

        # Log other drops
        limit rate 5/minute log prefix "DROPPED: "
    }

    chain forward {
        type filter hook forward priority 0; policy drop;
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}
</code></pre>
<h3 id="example-3-routergateway-with-nat"><a class="header" href="#example-3-routergateway-with-nat">Example 3: Router/Gateway with NAT</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

flush ruleset

table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;

        iifname "lo" accept
        ct state established,related accept
        ct state invalid drop

        # Allow management from LAN
        iifname "eth1" tcp dport { 22, 80, 443 } ct state new accept

        # ICMP
        ip protocol icmp limit rate 5/second accept
        ip6 nexthdr ipv6-icmp accept
    }

    chain forward {
        type filter hook forward priority 0; policy drop;

        # Established/related
        ct state established,related accept
        ct state invalid drop

        # LAN to WAN
        iifname "eth1" oifname "eth0" accept

        # Port forwarding (will be handled by NAT)
        iifname "eth0" oifname "eth1" tcp dport { 80, 443 } ct state new accept

        # Log dropped forwards
        limit rate 5/minute log prefix "FWD DROP: "
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}

table inet nat {
    chain prerouting {
        type nat hook prerouting priority -100;

        # Port forwarding to internal web server
        iifname "eth0" tcp dport 80 dnat to 192.168.1.10
        iifname "eth0" tcp dport 443 dnat to 192.168.1.10
    }

    chain postrouting {
        type nat hook postrouting priority 100;

        # Masquerade LAN to WAN
        oifname "eth0" masquerade
    }
}
</code></pre>
<h3 id="example-4-multi-zone-firewall-landmzwan"><a class="header" href="#example-4-multi-zone-firewall-landmzwan">Example 4: Multi-Zone Firewall (LAN/DMZ/WAN)</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

flush ruleset

# Define variables
define LAN = eth1
define DMZ = eth2
define WAN = eth0
define DMZ_NET = 192.168.100.0/24
define LAN_NET = 192.168.1.0/24

table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;

        iifname "lo" accept
        ct state established,related accept
        ct state invalid drop

        # Management from LAN only
        iifname $LAN tcp dport { 22, 443 } accept

        # ICMP
        ip protocol icmp limit rate 5/second accept
    }

    chain forward {
        type filter hook forward priority 0; policy drop;

        ct state established,related accept
        ct state invalid drop

        # LAN to anywhere
        iifname $LAN oifname { $DMZ, $WAN } accept

        # DMZ to WAN only (not to LAN)
        iifname $DMZ oifname $WAN accept

        # WAN to DMZ (limited services)
        iifname $WAN oifname $DMZ ip daddr $DMZ_NET tcp dport { 80, 443 } accept

        # Explicit deny WAN to LAN
        iifname $WAN oifname $LAN log prefix "WAN-&gt;LAN BLOCKED: " drop

        limit rate 5/minute log prefix "FWD DROP: "
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}

table inet nat {
    chain prerouting {
        type nat hook prerouting priority -100;

        # DNAT to DMZ web server
        iifname $WAN tcp dport { 80, 443 } dnat to 192.168.100.10
    }

    chain postrouting {
        type nat hook postrouting priority 100;

        # SNAT for LAN
        iifname $LAN oifname $WAN snat to 203.0.113.1

        # SNAT for DMZ
        iifname $DMZ oifname $WAN snat to 203.0.113.2
    }
}
</code></pre>
<h3 id="example-5-ipv4ipv6-dual-stack-firewall"><a class="header" href="#example-5-ipv4ipv6-dual-stack-firewall">Example 5: IPv4/IPv6 Dual-Stack Firewall</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

flush ruleset

table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;

        # Loopback
        iifname "lo" accept

        # Established/related
        ct state established,related accept
        ct state invalid drop

        # ICMP (IPv4)
        ip protocol icmp accept

        # ICMPv6 (essential for IPv6)
        icmpv6 type {
            destination-unreachable,
            packet-too-big,
            time-exceeded,
            parameter-problem,
            echo-request,
            echo-reply,
            nd-neighbor-solicit,
            nd-neighbor-advert,
            nd-router-advert,
            nd-router-solicit
        } accept

        # SSH (both IPv4 and IPv6)
        tcp dport 22 ct state new limit rate 3/minute accept

        # HTTP/HTTPS
        tcp dport { 80, 443 } ct state new accept

        # DHCPv6 client
        ip6 daddr fe80::/64 udp dport 546 accept

        # Log drops
        limit rate 5/minute log prefix "DROPPED: "
    }

    chain forward {
        type filter hook forward priority 0; policy drop;
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}
</code></pre>
<h3 id="example-6-container-host-firewall-docker"><a class="header" href="#example-6-container-host-firewall-docker">Example 6: Container Host Firewall (Docker)</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

flush ruleset

table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;

        iifname "lo" accept
        ct state established,related accept
        ct state invalid drop

        # Allow from docker network
        iifname "docker0" accept

        # SSH
        tcp dport 22 ct state new limit rate 3/minute accept

        # Container exposed ports
        tcp dport { 80, 443, 8080 } ct state new accept

        ip protocol icmp limit rate 5/second accept
    }

    chain forward {
        type filter hook forward priority 0; policy drop;

        ct state established,related accept
        ct state invalid drop

        # Docker containers to internet
        iifname "docker0" oifname "eth0" accept

        # Internet to docker containers (specific ports)
        iifname "eth0" oifname "docker0" tcp dport { 80, 443 } ct state new accept
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}

table inet nat {
    chain prerouting {
        type nat hook prerouting priority -100;

        # Port forwarding to containers
        tcp dport 8080 dnat to 172.17.0.2:80
    }

    chain postrouting {
        type nat hook postrouting priority 100;

        # Docker NAT
        oifname "eth0" ip saddr 172.17.0.0/16 masquerade
    }
}
</code></pre>
<h2 id="migration-from-iptables"><a class="header" href="#migration-from-iptables">Migration from iptables</a></h2>
<h3 id="translation-tools"><a class="header" href="#translation-tools">Translation Tools</a></h3>
<pre><code class="language-bash"># Translate single iptables command
iptables-translate -A INPUT -p tcp --dport 80 -j ACCEPT
# Output: nft add rule ip filter INPUT tcp dport 80 counter accept

# Translate iptables-save output
iptables-save &gt; iptables.rules
iptables-restore-translate -f iptables.rules &gt; nftables.conf

# For IPv6
ip6tables-save &gt; ip6tables.rules
ip6tables-restore-translate -f ip6tables.rules &gt;&gt; nftables.conf
</code></pre>
<h3 id="common-pattern-conversions"><a class="header" href="#common-pattern-conversions">Common Pattern Conversions</a></h3>
<h4 id="basic-rule-translation"><a class="header" href="#basic-rule-translation">Basic Rule Translation</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# nftables
nft add rule inet filter input tcp dport 22 accept
</code></pre>
<h4 id="multiple-ports"><a class="header" href="#multiple-ports">Multiple Ports</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT

# nftables
nft add rule inet filter input tcp dport { 80, 443 } accept
</code></pre>
<h4 id="port-range"><a class="header" href="#port-range">Port Range</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -p tcp --dport 1024:65535 -j ACCEPT

# nftables
nft add rule inet filter input tcp dport 1024-65535 accept
</code></pre>
<h4 id="connection-state"><a class="header" href="#connection-state">Connection State</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# nftables
nft add rule inet filter input ct state established,related accept
</code></pre>
<h4 id="ip-address"><a class="header" href="#ip-address">IP Address</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT

# nftables
nft add rule inet filter input ip saddr 192.168.1.0/24 accept
</code></pre>
<h4 id="interface"><a class="header" href="#interface">Interface</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -i eth0 -j ACCEPT

# nftables
nft add rule inet filter input iifname "eth0" accept
</code></pre>
<h4 id="snatmasquerade"><a class="header" href="#snatmasquerade">SNAT/Masquerade</a></h4>
<pre><code class="language-bash"># iptables
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# nftables
nft add rule inet nat postrouting oifname "eth0" masquerade
</code></pre>
<h4 id="dnatport-forwarding"><a class="header" href="#dnatport-forwarding">DNAT/Port Forwarding</a></h4>
<pre><code class="language-bash"># iptables
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:80

# nftables
nft add rule inet nat prerouting iifname "eth0" tcp dport 80 dnat to 192.168.1.10:80
</code></pre>
<h4 id="rate-limiting-1"><a class="header" href="#rate-limiting-1">Rate Limiting</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/sec -j ACCEPT

# nftables
nft add rule inet filter input icmp type echo-request limit rate 5/second accept
</code></pre>
<h4 id="log-target"><a class="header" href="#log-target">LOG Target</a></h4>
<pre><code class="language-bash"># iptables
iptables -A INPUT -j LOG --log-prefix "DROPPED: " --log-level 4

# nftables
nft add rule inet filter input log prefix \"DROPPED: \" level warn
</code></pre>
<h4 id="recent-module-connection-tracking"><a class="header" href="#recent-module-connection-tracking">Recent Module (Connection Tracking)</a></h4>
<pre><code class="language-bash"># iptables (SSH brute force protection)
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 -j DROP

# nftables
nft add rule inet filter input tcp dport 22 ct state new \
    meter ssh_meter { ip saddr timeout 1m limit rate over 3/minute } drop
</code></pre>
<h4 id="ipset"><a class="header" href="#ipset">ipset</a></h4>
<pre><code class="language-bash"># iptables with ipset
ipset create myset hash:ip
ipset add myset 192.168.1.1
iptables -A INPUT -m set --match-set myset src -j ACCEPT

# nftables
nft add set inet filter myset { type ipv4_addr \; }
nft add element inet filter myset { 192.168.1.1 }
nft add rule inet filter input ip saddr @myset accept
</code></pre>
<h3 id="side-by-side-examples"><a class="header" href="#side-by-side-examples">Side-by-Side Examples</a></h3>
<h4 id="example-1-basic-firewall"><a class="header" href="#example-1-basic-firewall">Example 1: Basic Firewall</a></h4>
<pre><code class="language-bash"># iptables
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT
iptables -A INPUT -i lo -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# nftables
nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0 \; policy drop \; }
nft add chain inet filter forward { type filter hook forward priority 0 \; policy drop \; }
nft add chain inet filter output { type filter hook output priority 0 \; policy accept \; }
nft add rule inet filter input iifname "lo" accept
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input tcp dport 22 accept
nft add rule inet filter input tcp dport 80 accept
</code></pre>
<h4 id="example-2-nat-router"><a class="header" href="#example-2-nat-router">Example 2: NAT Router</a></h4>
<pre><code class="language-bash"># iptables
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT
iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

# nftables
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
nft add table inet nat
nft add chain inet nat postrouting { type nat hook postrouting priority 100 \; }
nft add rule inet nat postrouting oifname "eth0" masquerade
nft add table inet filter
nft add chain inet filter forward { type filter hook forward priority 0 \; }
nft add rule inet filter forward iifname "eth1" oifname "eth0" accept
nft add rule inet filter forward ct state established,related accept
</code></pre>
<h3 id="migration-strategies"><a class="header" href="#migration-strategies">Migration Strategies</a></h3>
<h4 id="1-big-bang-migration"><a class="header" href="#1-big-bang-migration">1. Big Bang Migration</a></h4>
<pre><code class="language-bash"># Stop iptables
systemctl stop iptables
systemctl disable iptables

# Convert rules
iptables-save &gt; /tmp/iptables.rules
iptables-restore-translate -f /tmp/iptables.rules &gt; /etc/nftables.conf

# Review and edit /etc/nftables.conf
# Combine ip and ip6 tables into inet tables

# Load nftables
nft -f /etc/nftables.conf

# Enable service
systemctl enable nftables
systemctl start nftables
</code></pre>
<h4 id="2-gradual-migration"><a class="header" href="#2-gradual-migration">2. Gradual Migration</a></h4>
<pre><code class="language-bash"># Keep iptables running for critical services
# Add nftables rules for new services

# Example: Keep iptables for SSH, add nftables for HTTP
# iptables handles SSH (port 22)
# nftables handles HTTP (port 80)

# Eventually migrate all rules to nftables
</code></pre>
<h3 id="coexistence-considerations"><a class="header" href="#coexistence-considerations">Coexistence Considerations</a></h3>
<ul>
<li>iptables and nftables can coexist but may cause confusion</li>
<li>Both use the same Netfilter hooks</li>
<li>Rules are evaluated in priority order (nftables priorities vs iptables chains)</li>
<li>Recommended: use one framework only</li>
<li>Check which framework is active:</li>
</ul>
<pre><code class="language-bash"># Check iptables
iptables -L -n

# Check nftables
nft list ruleset

# Remove iptables rules
iptables -F
ip6tables -F
iptables -X
ip6tables -X
</code></pre>
<h2 id="scripting-and-automation"><a class="header" href="#scripting-and-automation">Scripting and Automation</a></h2>
<h3 id="nft-scripting-language"><a class="header" href="#nft-scripting-language">nft Scripting Language</a></h3>
<pre><code class="language-bash">#!/usr/sbin/nft -f

# Comments start with #

# Flush existing ruleset
flush ruleset

# Define variables
define WAN = eth0
define LAN = eth1
define SSH_PORT = 22
define WEB_PORTS = { 80, 443 }

# Tables and chains
table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;

        # Use variables
        iifname $LAN accept
        tcp dport $SSH_PORT accept
        tcp dport $WEB_PORTS accept
    }
}
</code></pre>
<h3 id="include-files"><a class="header" href="#include-files">Include Files</a></h3>
<pre><code class="language-bash"># Main file: /etc/nftables.conf
#!/usr/sbin/nft -f

flush ruleset

# Include definitions
include "/etc/nftables.d/defines.nft"

# Include tables
include "/etc/nftables.d/filter.nft"
include "/etc/nftables.d/nat.nft"
</code></pre>
<pre><code class="language-bash"># File: /etc/nftables.d/defines.nft
define WAN = eth0
define LAN = eth1
define DMZ = eth2
</code></pre>
<pre><code class="language-bash"># File: /etc/nftables.d/filter.nft
table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;
        # rules...
    }
}
</code></pre>
<h3 id="atomic-ruleset-replacement"><a class="header" href="#atomic-ruleset-replacement">Atomic Ruleset Replacement</a></h3>
<pre><code class="language-bash">#!/bin/bash

# Generate new ruleset
cat &gt; /tmp/nftables.conf &lt;&lt;EOF
flush ruleset
table inet filter {
    chain input {
        type filter hook input priority 0; policy accept;
        # New rules...
    }
}
EOF

# Test syntax
if nft -c -f /tmp/nftables.conf; then
    echo "Syntax OK"
    # Apply atomically
    nft -f /tmp/nftables.conf
    echo "Rules applied"
else
    echo "Syntax error!"
    exit 1
fi
</code></pre>
<h3 id="backup-and-restore-scripts"><a class="header" href="#backup-and-restore-scripts">Backup and Restore Scripts</a></h3>
<pre><code class="language-bash">#!/bin/bash
# backup-nftables.sh

BACKUP_DIR="/var/backups/nftables"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# Backup current ruleset
nft list ruleset &gt; "$BACKUP_DIR/nftables_$DATE.conf"

# Keep only last 10 backups
ls -t "$BACKUP_DIR"/nftables_*.conf | tail -n +11 | xargs -r rm

echo "Backup saved: $BACKUP_DIR/nftables_$DATE.conf"
</code></pre>
<pre><code class="language-bash">#!/bin/bash
# restore-nftables.sh

BACKUP_FILE="$1"

if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: $0 &lt;backup_file&gt;"
    exit 1
fi

if [ ! -f "$BACKUP_FILE" ]; then
    echo "File not found: $BACKUP_FILE"
    exit 1
fi

# Test syntax
if nft -c -f "$BACKUP_FILE"; then
    echo "Restoring from: $BACKUP_FILE"
    nft -f "$BACKUP_FILE"
    echo "Rules restored"
else
    echo "Invalid ruleset file"
    exit 1
fi
</code></pre>
<h3 id="systemd-integration"><a class="header" href="#systemd-integration">systemd Integration</a></h3>
<pre><code class="language-bash"># /etc/systemd/system/nftables-custom.service
[Unit]
Description=Custom nftables firewall
After=network-pre.target
Before=network.target
Wants=network-pre.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/sbin/nft -f /etc/nftables/custom.conf
ExecReload=/usr/sbin/nft -f /etc/nftables/custom.conf
ExecStop=/usr/sbin/nft flush ruleset
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
</code></pre>
<h3 id="dynamic-rule-management-script"><a class="header" href="#dynamic-rule-management-script">Dynamic Rule Management Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# manage-blocklist.sh

BLOCKLIST_SET="blocklist"
TABLE="inet filter"

case "$1" in
    add)
        nft add element $TABLE $BLOCKLIST_SET { $2 }
        echo "Added $2 to blocklist"
        ;;
    del)
        nft delete element $TABLE $BLOCKLIST_SET { $2 }
        echo "Removed $2 from blocklist"
        ;;
    list)
        nft list set $TABLE $BLOCKLIST_SET
        ;;
    flush)
        nft flush set $TABLE $BLOCKLIST_SET
        echo "Blocklist cleared"
        ;;
    *)
        echo "Usage: $0 {add|del|list|flush} [IP]"
        exit 1
        ;;
esac
</code></pre>
<h2 id="debugging-and-troubleshooting"><a class="header" href="#debugging-and-troubleshooting">Debugging and Troubleshooting</a></h2>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<h4 id="error-no-such-file-or-directory"><a class="header" href="#error-no-such-file-or-directory">Error: “No such file or directory”</a></h4>
<pre><code class="language-bash"># Issue: nf_tables module not loaded
# Solution:
modprobe nf_tables
</code></pre>
<h4 id="error-operation-not-supported"><a class="header" href="#error-operation-not-supported">Error: “Operation not supported”</a></h4>
<pre><code class="language-bash"># Issue: Kernel too old or feature not compiled
# Check kernel version:
uname -r  # Need 3.13+

# Check if nftables is compiled:
grep NFT /boot/config-$(uname -r)
</code></pre>
<h4 id="error-could-not-process-rule-no-such-file-or-directory"><a class="header" href="#error-could-not-process-rule-no-such-file-or-directory">Error: “Could not process rule: No such file or directory”</a></h4>
<pre><code class="language-bash"># Issue: Set or chain doesn't exist
# List existing objects:
nft list tables
nft list sets
nft list chains

# Create missing objects first
</code></pre>
<h4 id="syntax-errors"><a class="header" href="#syntax-errors">Syntax Errors</a></h4>
<pre><code class="language-bash"># Test configuration without applying:
nft -c -f /etc/nftables.conf

# Common syntax issues:
# - Missing semicolons after chain properties
# - Wrong quotes (use double quotes for strings)
# - Incorrect operator (use '==' not '=')
</code></pre>
<h3 id="rule-testing"><a class="header" href="#rule-testing">Rule Testing</a></h3>
<pre><code class="language-bash"># Method 1: Test in separate table
nft add table inet test
nft add chain inet test input { type filter hook input priority 0 \; }
nft add rule inet test input tcp dport 80 accept

# Test, then delete
nft delete table inet test

# Method 2: Check syntax only
nft -c add rule inet filter input tcp dport 80 accept

# Method 3: Use counters to verify matching
nft add rule inet filter input tcp dport 80 counter accept
# Generate traffic, then check:
nft list chain inet filter input
</code></pre>
<h3 id="packet-tracing-1"><a class="header" href="#packet-tracing-1">Packet Tracing</a></h3>
<pre><code class="language-bash"># Enable tracing for specific traffic
nft add rule inet filter prerouting ip saddr 192.168.1.100 meta nftrace set 1

# Monitor traces
nft monitor trace

# Example output shows packet path through chains

# Disable tracing
nft delete rule inet filter prerouting handle &lt;N&gt;
</code></pre>
<h3 id="listing-rules-with-handles"><a class="header" href="#listing-rules-with-handles">Listing Rules with Handles</a></h3>
<pre><code class="language-bash"># Show handles (needed for deletion)
nft --handle list ruleset

# List specific table with handles
nft --handle list table inet filter

# Delete rule by handle
nft delete rule inet filter input handle 5
</code></pre>
<h3 id="counters-and-statistics"><a class="header" href="#counters-and-statistics">Counters and Statistics</a></h3>
<pre><code class="language-bash"># List rules with packet/byte counters
nft list table inet filter

# Reset counters
nft reset rules inet filter

# Reset specific counter
nft reset counter inet filter my_counter
</code></pre>
<h3 id="connection-tracking-1"><a class="header" href="#connection-tracking-1">Connection Tracking</a></h3>
<pre><code class="language-bash"># View current connections
conntrack -L

# Count connections
conntrack -C

# Delete specific connection
conntrack -D -s 192.168.1.100

# Monitor new connections
conntrack -E
</code></pre>
<h3 id="kernel-messages"><a class="header" href="#kernel-messages">Kernel Messages</a></h3>
<pre><code class="language-bash"># Check kernel log for nftables messages
dmesg | grep nf_tables

# Monitor live
journalctl -f -k | grep nft

# Check for errors
dmesg | grep -i error | grep nf
</code></pre>
<h3 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h3>
<pre><code class="language-bash"># Check connection tracking table size
cat /proc/sys/net/netfilter/nf_conntrack_count
cat /proc/sys/net/netfilter/nf_conntrack_max

# Adjust if needed
sysctl -w net.netfilter.nf_conntrack_max=1000000

# Monitor CPU usage
top -p $(pgrep nft)

# Check memory usage
cat /proc/net/stat/nf_conntrack
</code></pre>
<h3 id="debug-logging"><a class="header" href="#debug-logging">Debug Logging</a></h3>
<pre><code class="language-bash"># Enable nftables debug in kernel (requires debug build)
echo 'module nf_tables +p' &gt; /sys/kernel/debug/dynamic_debug/control

# View debug output
dmesg -w | grep nf_tables
</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="rule-ordering"><a class="header" href="#rule-ordering">Rule Ordering</a></h3>
<pre><code class="language-bash"># GOOD: Most common rules first
nft add rule inet filter input ct state established,related accept  # Most traffic
nft add rule inet filter input tcp dport 80 accept                  # Common
nft add rule inet filter input tcp dport 22 accept                  # Less common

# BAD: Rare rules first
nft add rule inet filter input tcp dport 23 drop                    # Rarely matched
nft add rule inet filter input ct state established,related accept  # Most traffic
</code></pre>
<h3 id="using-sets-vs-multiple-rules"><a class="header" href="#using-sets-vs-multiple-rules">Using Sets vs Multiple Rules</a></h3>
<pre><code class="language-bash"># INEFFICIENT: Multiple rules
nft add rule inet filter input tcp dport 80 accept
nft add rule inet filter input tcp dport 443 accept
nft add rule inet filter input tcp dport 8080 accept
nft add rule inet filter input tcp dport 8443 accept

# EFFICIENT: Single rule with set
nft add rule inet filter input tcp dport { 80, 443, 8080, 8443 } accept

# Even better: Named set (optimized data structure)
nft add set inet filter web_ports { type inet_service \; }
nft add element inet filter web_ports { 80, 443, 8080, 8443 }
nft add rule inet filter input tcp dport @web_ports accept
</code></pre>
<h3 id="verdict-maps-for-performance"><a class="header" href="#verdict-maps-for-performance">Verdict Maps for Performance</a></h3>
<pre><code class="language-bash"># Instead of multiple rules with jumps:
# SLOW:
nft add rule inet filter input tcp dport 80 jump http_chain
nft add rule inet filter input tcp dport 443 jump https_chain
nft add rule inet filter input tcp dport 22 jump ssh_chain

# FAST: Use verdict map
nft add map inet filter service_map { type inet_service : verdict \; }
nft add element inet filter service_map { \
    80 : jump http_chain, \
    443 : jump https_chain, \
    22 : jump ssh_chain \
}
nft add rule inet filter input tcp dport vmap @service_map
</code></pre>
<h3 id="early-dropping"><a class="header" href="#early-dropping">Early Dropping</a></h3>
<pre><code class="language-bash"># Drop invalid packets early (before expensive checks)
nft add chain inet filter input { type filter hook input priority -200 \; }
nft add rule inet filter input ct state invalid drop

# Main filter chain
nft add chain inet filter input_main { type filter hook input priority 0 \; }
# ... other rules
</code></pre>
<h3 id="connection-tracking-optimization"><a class="header" href="#connection-tracking-optimization">Connection Tracking Optimization</a></h3>
<pre><code class="language-bash"># Increase connection tracking table size for high traffic
sysctl -w net.netfilter.nf_conntrack_max=1000000

# Reduce timeout for specific protocols
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established=3600

# Disable tracking for specific traffic (stateless)
nft add rule inet raw prerouting tcp dport 80 notrack
nft add rule inet raw output tcp sport 80 notrack
</code></pre>
<h3 id="hardware-offload"><a class="header" href="#hardware-offload">Hardware Offload</a></h3>
<pre><code class="language-bash"># For NICs with flow offload support (kernel 4.16+)
# Create flowtable for offloading
nft add flowtable inet filter f {
    hook ingress priority 0;
    devices = { eth0, eth1 };
}

# Offload established connections
nft add rule inet filter forward \
    ct state established flow add @f
</code></pre>
<h3 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h3>
<pre><code class="language-bash"># Limit set size to prevent memory exhaustion
nft add set inet filter limited_set { \
    type ipv4_addr \; \
    size 10000 \; \
    flags dynamic,timeout \; \
}

# Monitor memory usage
cat /proc/slabinfo | grep nf_conntrack
</code></pre>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<pre><code class="language-bash"># Benchmark rule lookup performance
# Generate traffic and measure:

# Before optimization
time nft list ruleset &gt; /dev/null

# Add rules
# ... add thousands of rules

# After
time nft list ruleset &gt; /dev/null

# Use iperf3 for throughput testing
# Server:
iperf3 -s

# Client:
iperf3 -c &lt;server_ip&gt; -t 30 -P 10
</code></pre>
<h2 id="integration-with-other-tools"><a class="header" href="#integration-with-other-tools">Integration with Other Tools</a></h2>
<h3 id="firewalld-backend"><a class="header" href="#firewalld-backend">firewalld Backend</a></h3>
<p>firewalld can use nftables as backend:</p>
<pre><code class="language-bash"># /etc/firewalld/firewalld.conf
FirewallBackend=nftables

# Restart firewalld
systemctl restart firewalld

# Check backend
firewall-cmd --get-backend

# firewalld creates its own nftables tables
nft list tables
</code></pre>
<h3 id="docker-integration"><a class="header" href="#docker-integration">Docker Integration</a></h3>
<p>Docker uses iptables by default, but can coexist:</p>
<pre><code class="language-bash"># Docker creates rules in iptables
# Your host firewall uses nftables

# Example: Allow Docker while using nftables for host
# nftables for host protection
nft add rule inet filter input iifname "docker0" accept
nft add rule inet filter forward iifname "docker0" accept

# Let Docker manage its own iptables rules
# They operate in different priority ranges
</code></pre>
<h3 id="fail2ban-with-nftables"><a class="header" href="#fail2ban-with-nftables">fail2ban with nftables</a></h3>
<p>Configure fail2ban to use nftables:</p>
<pre><code class="language-bash"># /etc/fail2ban/jail.local
[DEFAULT]
banaction = nftables-multiport
banaction_allports = nftables-allports

[sshd]
enabled = true
port = ssh
logpath = /var/log/auth.log
maxretry = 5
bantime = 3600
</code></pre>
<p>Create nftables action:</p>
<pre><code class="language-bash"># /etc/fail2ban/action.d/nftables-multiport.conf
[Definition]
actionstart = nft add table inet fail2ban
              nft add chain inet fail2ban input { type filter hook input priority -1 \; }

actionban = nft add rule inet fail2ban input ip saddr &lt;ip&gt; drop

actionunban = nft delete rule inet fail2ban input ip saddr &lt;ip&gt; drop
</code></pre>
<h3 id="libvirt-integration"><a class="header" href="#libvirt-integration">libvirt Integration</a></h3>
<p>libvirt can use nftables for VM networking:</p>
<pre><code class="language-bash"># /etc/libvirt/network.conf
firewall_backend = "nftables"

# Restart libvirt
systemctl restart libvirtd

# libvirt creates its own tables
nft list table inet libvirt
</code></pre>
<h3 id="networkmanager-dispatcher"><a class="header" href="#networkmanager-dispatcher">NetworkManager Dispatcher</a></h3>
<p>Run nftables scripts on network events:</p>
<pre><code class="language-bash"># /etc/NetworkManager/dispatcher.d/10-nftables
#!/bin/bash

INTERFACE=$1
ACTION=$2

case "$ACTION" in
    up)
        # Interface came up
        nft add rule inet filter input iifname "$INTERFACE" accept
        ;;
    down)
        # Interface went down
        nft delete rule inet filter input iifname "$INTERFACE" accept 2&gt;/dev/null
        ;;
esac
</code></pre>
<h3 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h3>
<p>Example nftables rules for Kubernetes nodes:</p>
<pre><code class="language-bash">#!/usr/sbin/nft -f

flush ruleset

table inet filter {
    chain input {
        type filter hook input priority 0; policy drop;

        iifname "lo" accept
        ct state established,related accept

        # Kubernetes API server
        tcp dport 6443 accept

        # Kubelet API
        tcp dport 10250 accept

        # NodePort services
        tcp dport 30000-32767 accept

        # CNI plugin (Calico, Flannel, etc.)
        # Adjust based on your CNI
        iifname "cni0" accept
        iifname "flannel.1" accept
    }

    chain forward {
        type filter hook forward priority 0; policy accept;

        # Allow pod-to-pod communication
        iifname "cni0" oifname "cni0" accept
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h3>
<ol>
<li><strong>Default Deny Policy</strong></li>
</ol>
<pre><code class="language-bash"># Always use drop as default policy for input/forward
nft add chain inet filter input { type filter hook input priority 0 \; policy drop \; }
nft add chain inet filter forward { type filter hook forward priority 0 \; policy drop \; }
</code></pre>
<ol start="2">
<li><strong>Drop Invalid Packets Early</strong></li>
</ol>
<pre><code class="language-bash">nft add rule inet filter input ct state invalid drop
</code></pre>
<ol start="3">
<li><strong>Rate Limit Everything</strong></li>
</ol>
<pre><code class="language-bash"># Especially management services
nft add rule inet filter input tcp dport 22 ct state new limit rate 3/minute accept
</code></pre>
<ol start="4">
<li><strong>Use Connection Tracking</strong></li>
</ol>
<pre><code class="language-bash"># Stateful filtering is more secure
nft add rule inet filter input ct state established,related accept
</code></pre>
<ol start="5">
<li><strong>Log Suspicious Activity</strong></li>
</ol>
<pre><code class="language-bash"># But rate limit logs to prevent flooding
nft add rule inet filter input limit rate 5/minute log prefix "SUSPICIOUS: " drop
</code></pre>
<h3 id="rule-organization"><a class="header" href="#rule-organization">Rule Organization</a></h3>
<ol>
<li><strong>Use Includes for Modularity</strong></li>
</ol>
<pre><code class="language-bash"># /etc/nftables.conf
include "/etc/nftables.d/*.nft"
</code></pre>
<ol start="2">
<li><strong>Group Related Rules in Chains</strong></li>
</ol>
<pre><code class="language-bash">chain ssh_rules {
    # All SSH-related rules
}
chain web_rules {
    # All web-related rules
}
</code></pre>
<ol start="3">
<li><strong>Use Named Sets for Maintainability</strong></li>
</ol>
<pre><code class="language-bash">nft add set inet filter allowed_ips { type ipv4_addr \; }
# Easier to update than editing rules
</code></pre>
<h3 id="documentation-practices"><a class="header" href="#documentation-practices">Documentation Practices</a></h3>
<ol>
<li><strong>Comment Your Rules</strong></li>
</ol>
<pre><code class="language-bash"># In nft script files:
# Allow SSH from management network
nft add rule inet filter input ip saddr 10.0.0.0/8 tcp dport 22 accept
</code></pre>
<ol start="2">
<li><strong>Keep Change Log</strong></li>
</ol>
<pre><code class="language-bash"># /etc/nftables.d/CHANGELOG
# 2025-01-15: Added rate limiting for SSH
# 2025-01-14: Opened port 8080 for new service
</code></pre>
<ol start="3">
<li><strong>Document Network Topology</strong></li>
</ol>
<pre><code class="language-bash"># Define and document interfaces
define WAN = eth0  # Internet connection
define LAN = eth1  # Internal network 192.168.1.0/24
define DMZ = eth2  # DMZ network 192.168.100.0/24
</code></pre>
<h3 id="testing-practices"><a class="header" href="#testing-practices">Testing Practices</a></h3>
<ol>
<li><strong>Always Test Syntax Before Applying</strong></li>
</ol>
<pre><code class="language-bash">nft -c -f /etc/nftables.conf
</code></pre>
<ol start="2">
<li><strong>Test New Rules in Isolation</strong></li>
</ol>
<pre><code class="language-bash"># Create test table
nft add table inet test
# Test rules
# Delete when done
nft delete table inet test
</code></pre>
<ol start="3">
<li><strong>Keep a Rollback Plan</strong></li>
</ol>
<pre><code class="language-bash"># Backup before changes
nft list ruleset &gt; /tmp/nftables.backup

# Auto-rollback script
nft -f /etc/nftables.conf &amp;&amp; sleep 60 &amp;&amp; nft -f /tmp/nftables.backup &amp;
# If connection is lost, rules rollback after 60 seconds
</code></pre>
<ol start="4">
<li><strong>Use Counters for Verification</strong></li>
</ol>
<pre><code class="language-bash"># Add counters to verify rules are matching
nft add rule inet filter input tcp dport 80 counter accept
# Check counter values
nft list chain inet filter input
</code></pre>
<h3 id="backup-strategies"><a class="header" href="#backup-strategies">Backup Strategies</a></h3>
<ol>
<li><strong>Automated Backups</strong></li>
</ol>
<pre><code class="language-bash"># Daily cron job
0 2 * * * nft list ruleset &gt; /var/backups/nftables/$(date +\%Y\%m\%d).conf
</code></pre>
<ol start="2">
<li><strong>Version Control</strong></li>
</ol>
<pre><code class="language-bash">cd /etc/nftables.d
git init
git add *.nft
git commit -m "Initial firewall configuration"
</code></pre>
<ol start="3">
<li><strong>Configuration Management</strong></li>
</ol>
<pre><code class="language-bash"># Use Ansible, Puppet, or Chef to manage nftables
# Example Ansible task:
# - name: Deploy nftables configuration
#   template:
#     src: nftables.conf.j2
#     dest: /etc/nftables.conf
#   notify: reload nftables
</code></pre>
<h3 id="monitoring-practices"><a class="header" href="#monitoring-practices">Monitoring Practices</a></h3>
<ol>
<li><strong>Monitor Rule Counters</strong></li>
</ol>
<pre><code class="language-bash"># Script to check counters
watch -n 5 'nft list ruleset | grep counter'
</code></pre>
<ol start="2">
<li><strong>Log Analysis</strong></li>
</ol>
<pre><code class="language-bash"># Analyze dropped packets
journalctl -k | grep "DROPPED:"

# Count by source IP
journalctl -k | grep "DROPPED:" | awk '{print $NF}' | sort | uniq -c | sort -rn
</code></pre>
<ol start="3">
<li><strong>Alert on Anomalies</strong></li>
</ol>
<pre><code class="language-bash"># Monitor for brute force
journalctl -f -k | grep "SSH BLOCK" | \
while read line; do
    echo "Alert: SSH brute force detected" | mail -s "Security Alert" admin@example.com
done
</code></pre>
<h3 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h3>
<pre><code class="language-bash"># Connection tracking usage
watch -n 1 'cat /proc/sys/net/netfilter/nf_conntrack_count'

# Memory usage
watch -n 5 'cat /proc/slabinfo | grep nf_conntrack'

# Network throughput
iftop -i eth0
</code></pre>
<h2 id="references-and-resources"><a class="header" href="#references-and-resources">References and Resources</a></h2>
<h3 id="official-documentation"><a class="header" href="#official-documentation">Official Documentation</a></h3>
<ul>
<li><strong>nftables Wiki</strong>: https://wiki.nftables.org/</li>
<li><strong>Netfilter Project</strong>: https://www.netfilter.org/</li>
<li><strong>Kernel Documentation</strong>: https://www.kernel.org/doc/Documentation/networking/nftables.txt</li>
</ul>
<h3 id="man-pages"><a class="header" href="#man-pages">Man Pages</a></h3>
<pre><code class="language-bash">man nft
man libnftables
man libnftables-json
</code></pre>
<h3 id="rfcs"><a class="header" href="#rfcs">RFCs</a></h3>
<ul>
<li>RFC 3947: Negotiation of NAT-Traversal in the IKE</li>
<li>RFC 4787: NAT Behavioral Requirements for UDP</li>
<li>RFC 5382: NAT Behavioral Requirements for TCP</li>
<li>RFC 7857: Updates to Network Address Translation (NAT) Behavioral Requirements</li>
</ul>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><strong>Arch Linux Wiki</strong>: https://wiki.archlinux.org/title/Nftables</li>
<li><strong>Debian Wiki</strong>: https://wiki.debian.org/nftables</li>
<li><strong>Red Hat Documentation</strong>: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/getting-started-with-nftables_configuring-and-managing-networking</li>
</ul>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li><code>nft</code> - nftables administration tool</li>
<li><code>nftables</code> - systemd service</li>
<li><code>iptables-translate</code> - Convert iptables rules to nftables</li>
<li><code>iptables-restore-translate</code> - Convert iptables-save output to nftables</li>
</ul>
<h3 id="comparison-resources"><a class="header" href="#comparison-resources">Comparison Resources</a></h3>
<ul>
<li><strong>nftables vs iptables</strong>: https://wiki.nftables.org/wiki-nftables/index.php/Moving_from_iptables_to_nftables</li>
<li><strong>iptables-translate</strong>: Built-in tool for migration</li>
</ul>
<h2 id="eli10-explain-like-im-10"><a class="header" href="#eli10-explain-like-im-10">ELI10 (Explain Like I’m 10)</a></h2>
<h3 id="what-is-nftables"><a class="header" href="#what-is-nftables">What is nftables?</a></h3>
<p>Imagine your computer is a castle, and nftables is the guard at the gate. The guard decides who can come in and who has to stay out based on rules you give them.</p>
<h3 id="how-does-it-work"><a class="header" href="#how-does-it-work">How Does It Work?</a></h3>
<p><strong>Tables</strong>: Think of these as different guardhouses. One for the main gate (filter), one for disguises (NAT), etc.</p>
<p><strong>Chains</strong>: These are lists of questions the guard asks. “Are you a friend?” “Do you have the password?” “Are you from the village?”</p>
<p><strong>Rules</strong>: These are specific instructions. “If someone is wearing a red hat, let them in.” “If someone doesn’t know the password, send them away.”</p>
<h3 id="why-is-nftables-better-than-iptables"><a class="header" href="#why-is-nftables-better-than-iptables">Why is nftables Better Than iptables?</a></h3>
<p><strong>iptables</strong> is like having different guards who don’t talk to each other:</p>
<ul>
<li>One guard for people (IPv4)</li>
<li>Another guard for elves (IPv6)</li>
<li>Another guard for carriages (bridges)</li>
</ul>
<p><strong>nftables</strong> is like having one smart guard who handles everything and speaks multiple languages!</p>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<pre><code class="language-bash"># Create a guardhouse (table)
nft add table inet my_castle

# Create a question list for people coming in (chain)
nft add chain inet my_castle entrance { \
    type filter hook input priority 0 \; \
    policy drop \; \
}

# Let friends in (rule)
nft add rule inet my_castle entrance ip saddr 192.168.1.0/24 accept

# Let people with password in (rule)
nft add rule inet my_castle entrance tcp dport 22 accept
</code></pre>
<h3 id="sets-and-maps"><a class="header" href="#sets-and-maps">Sets and Maps</a></h3>
<p><strong>Sets</strong> are like VIP lists:</p>
<pre><code class="language-bash"># Create VIP list
nft add set inet my_castle vip_list { type ipv4_addr \; }

# Add people to list
nft add element inet my_castle vip_list { 192.168.1.1, 192.168.1.2 }

# VIPs can enter
nft add rule inet my_castle entrance ip saddr @vip_list accept
</code></pre>
<p><strong>Maps</strong> are like giving different directions based on who you are:</p>
<pre><code class="language-bash"># If you're going to room 80, go to building A
# If you're going to room 443, go to building B
nft add map inet my_castle directions { type inet_service : ipv4_addr \; }
nft add element inet my_castle directions { 80 : 192.168.1.10, 443 : 192.168.1.11 }
</code></pre>
<h3 id="nat-network-address-translation-1"><a class="header" href="#nat-network-address-translation-1">NAT (Network Address Translation)</a></h3>
<p>NAT is like having a disguise room. When people from inside the castle go outside, they all wear the same uniform so outsiders can’t tell them apart. When outsiders want to visit someone inside, the guard knows who they really want to see and directs them correctly.</p>
<p><strong>Masquerading</strong> (SNAT): Everyone leaving wears the same disguise</p>
<pre><code class="language-bash">nft add rule inet nat postrouting oifname "eth0" masquerade
</code></pre>
<p><strong>Port Forwarding</strong> (DNAT): Visitors asking for room 80 get sent to person 192.168.1.10</p>
<pre><code class="language-bash">nft add rule inet nat prerouting tcp dport 80 dnat to 192.168.1.10
</code></pre>
<h3 id="connection-tracking-2"><a class="header" href="#connection-tracking-2">Connection Tracking</a></h3>
<p>This is like the guard remembering conversations:</p>
<ul>
<li>“Oh, you’re the person I was talking to earlier, come in!” (established)</li>
<li>“You’re bringing the package for someone I let in earlier, okay!” (related)</li>
<li>“I’ve never seen you before, state your business!” (new)</li>
</ul>
<h3 id="rate-limiting-2"><a class="header" href="#rate-limiting-2">Rate Limiting</a></h3>
<p>This prevents one person from knocking on the door too many times:</p>
<pre><code class="language-bash"># Only allow 5 knocks per second
nft add rule inet my_castle entrance limit rate 5/second accept
</code></pre>
<p>If someone knocks more than that, the guard gets suspicious and might block them!</p>
<h3 id="remember"><a class="header" href="#remember">Remember</a></h3>
<ul>
<li><strong>Tables</strong> = Guardhouses</li>
<li><strong>Chains</strong> = Lists of questions</li>
<li><strong>Rules</strong> = Specific instructions</li>
<li><strong>Sets</strong> = Lists of allowed/blocked things</li>
<li><strong>Maps</strong> = Direction guides</li>
<li><strong>NAT</strong> = Disguise room</li>
<li><strong>Connection Tracking</strong> = Guard’s memory</li>
</ul>
<p>nftables is just a very organized way of telling your computer who to trust and who to keep out!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/iptables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../linux/systemd.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/iptables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../linux/systemd.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
