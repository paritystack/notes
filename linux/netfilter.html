<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Netfilter - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="netfilter"><a class="header" href="#netfilter">Netfilter</a></h1>
<p>Netfilter is a framework provided by the Linux kernel for packet filtering, network address translation (NAT), and other packet mangling. It allows system administrators to define rules for how packets should be handled by the kernel. Netfilter is the foundation upon which tools like iptables and nftables are built.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#tables-and-chains">Tables and Chains</a></li>
<li><a href="#packet-flow">Packet Flow</a></li>
<li><a href="#basic-operations">Basic Operations</a></li>
<li><a href="#filtering-patterns">Filtering Patterns</a></li>
<li><a href="#nat-patterns">NAT Patterns</a></li>
<li><a href="#advanced-filtering">Advanced Filtering</a></li>
<li><a href="#connection-tracking">Connection Tracking</a></li>
<li><a href="#chain-management">Chain Management</a></li>
<li><a href="#common-use-cases">Common Use Cases</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#performance-tuning">Performance Tuning</a></li>
<li><a href="#modern-alternatives">Modern Alternatives</a></li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="netfilter-vs-iptablesnftables"><a class="header" href="#netfilter-vs-iptablesnftables">Netfilter vs iptables/nftables</a></h3>
<ul>
<li><strong>Netfilter</strong>: The kernel-space framework providing hooks in the network stack</li>
<li><strong>iptables</strong>: User-space utility to configure IPv4 packet filtering rules (legacy)</li>
<li><strong>ip6tables</strong>: User-space utility for IPv6 packet filtering</li>
<li><strong>nftables</strong>: Modern replacement for iptables, offering better performance and syntax</li>
</ul>
<h3 id="netfilter-hooks"><a class="header" href="#netfilter-hooks">Netfilter Hooks</a></h3>
<p>Netfilter provides five hook points in the kernel network stack where packets can be intercepted:</p>
<ol>
<li>
<p><strong>NF_IP_PRE_ROUTING (PREROUTING)</strong>: Triggered before routing decision</p>
<ul>
<li>First hook after packet reception</li>
<li>Used for DNAT, traffic redirection</li>
</ul>
</li>
<li>
<p><strong>NF_IP_LOCAL_IN (INPUT)</strong>: For packets destined to local system</p>
<ul>
<li>After routing decision, before local delivery</li>
<li>Used for incoming firewall rules</li>
</ul>
</li>
<li>
<p><strong>NF_IP_FORWARD (FORWARD)</strong>: For packets being routed through the system</p>
<ul>
<li>For packets not destined for local system</li>
<li>Used in routers and gateways</li>
</ul>
</li>
<li>
<p><strong>NF_IP_LOCAL_OUT (OUTPUT)</strong>: For locally generated packets</p>
<ul>
<li>Before routing decision for local packets</li>
<li>Used for outgoing firewall rules</li>
</ul>
</li>
<li>
<p><strong>NF_IP_POST_ROUTING (POSTROUTING)</strong>: After routing decision</p>
<ul>
<li>Last hook before packet transmission</li>
<li>Used for SNAT and masquerading</li>
</ul>
</li>
</ol>
<h2 id="tables-and-chains"><a class="header" href="#tables-and-chains">Tables and Chains</a></h2>
<p>Netfilter organizes rules into tables, each serving a specific purpose. Each table contains chains that correspond to netfilter hooks.</p>
<h3 id="filter-table"><a class="header" href="#filter-table">Filter Table</a></h3>
<p>The default table for packet filtering.</p>
<p><strong>Chains</strong>: INPUT, FORWARD, OUTPUT</p>
<p><strong>Purpose</strong>: Decide whether to allow or deny packets</p>
<pre><code class="language-bash"># View filter table
iptables -t filter -L -n -v
# or simply (filter is default)
iptables -L -n -v
</code></pre>
<h3 id="nat-table"><a class="header" href="#nat-table">NAT Table</a></h3>
<p>Used for Network Address Translation.</p>
<p><strong>Chains</strong>: PREROUTING, OUTPUT, POSTROUTING</p>
<p><strong>Purpose</strong>: Modify source or destination addresses</p>
<pre><code class="language-bash"># View NAT table
iptables -t nat -L -n -v
</code></pre>
<p><strong>Note</strong>: NAT table does not have INPUT or FORWARD chains because NAT occurs before routing (PREROUTING) or after routing (POSTROUTING).</p>
<h3 id="mangle-table"><a class="header" href="#mangle-table">Mangle Table</a></h3>
<p>Used for specialized packet alteration.</p>
<p><strong>Chains</strong>: PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING (all 5)</p>
<p><strong>Purpose</strong>: Modify IP headers (TTL, TOS, MARK)</p>
<pre><code class="language-bash"># View mangle table
iptables -t mangle -L -n -v
</code></pre>
<h3 id="raw-table"><a class="header" href="#raw-table">Raw Table</a></h3>
<p>Used for configuration exemptions from connection tracking.</p>
<p><strong>Chains</strong>: PREROUTING, OUTPUT</p>
<p><strong>Purpose</strong>: Mark packets to bypass connection tracking (performance optimization)</p>
<pre><code class="language-bash"># View raw table
iptables -t raw -L -n -v
</code></pre>
<h3 id="security-table"><a class="header" href="#security-table">Security Table</a></h3>
<p>Used for Mandatory Access Control (MAC) networking rules.</p>
<p><strong>Chains</strong>: INPUT, OUTPUT, FORWARD</p>
<p><strong>Purpose</strong>: SELinux packet labeling</p>
<pre><code class="language-bash"># View security table
iptables -t security -L -n -v
</code></pre>
<h2 id="packet-flow"><a class="header" href="#packet-flow">Packet Flow</a></h2>
<p>Understanding packet flow through netfilter is crucial for effective rule creation:</p>
<pre><code>                               XXXXXXXXXXXXXXXXXX
                             XXX     Network    XXX
                               XXXXXXXXXXXXXXXXXX
                                       +
                                       |
                                       v
 +-------------+              +------------------+
 |table: filter| &lt;---+        | table: raw       |
 |chain: INPUT |     |        | chain: PREROUTING|
 +-----+-------+     |        +--------+---------+
       |             |                 |
       v             |                 v
 [local process]     |        +------------------+
       |             |        | table: mangle    |
       |             |        | chain: PREROUTING|
       +-------------+        +--------+---------+
       |                               |
       v                               v
+--------------+              +------------------+
|table: filter |              | table: nat       |
|chain: OUTPUT |              | chain: PREROUTING|
+------+-------+              +--------+---------+
       |                               |
       v                               v
+---------------+            +--------------------+
|table: raw     |            | routing decision   |
|chain: OUTPUT  |            +--------+-----------+
+------+--------+                     |
       |                              |
       v                              +---------+---------+
+---------------+                     |                   |
|table: mangle  |                     v                   v
|chain: OUTPUT  |            +------------------+   +-------------+
+------+--------+            | table: filter    |   | table:filter|
       |                     | chain: FORWARD   |   | chain: INPUT|
       v                     +--------+---------+   +------+------+
+---------------+                     |                    |
|table: nat     |                     |                    v
|chain: OUTPUT  |                     |             [local process]
+------+--------+                     |
       |                              v
       v                     +-------------------+
+---------------+            | table: mangle     |
|table: mangle  |            | chain: FORWARD    |
|chain:POSTROUTE|            +--------+----------+
+------+--------+                     |
       |                              v
       v                     +-------------------+
+---------------+            | table: nat        |
|table: nat     |            | chain: POSTROUTING|
+------+--------+            +--------+----------+
       |                              |
       v                              v
       +------------------------------+
                     |
                     v
            +------------------+
            | table: mangle    |
            | chain:POSTROUTING|
            +--------+---------+
                     |
                     v
              XXXXXXXXXXXXXXXXXX
            XXX    Network     XXX
              XXXXXXXXXXXXXXXXXX
</code></pre>
<p><strong>Key Flow Points</strong>:</p>
<ul>
<li>Incoming packets: Raw PREROUTING → Mangle PREROUTING → NAT PREROUTING → Routing Decision</li>
<li>To local process: Filter INPUT → Local Process</li>
<li>From local process: Raw OUTPUT → Mangle OUTPUT → NAT OUTPUT → Filter OUTPUT → Routing</li>
<li>Forwarded: Filter FORWARD → Mangle FORWARD</li>
<li>All outgoing: NAT POSTROUTING → Mangle POSTROUTING → Network</li>
</ul>
<h2 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h2>
<h3 id="viewing-rules"><a class="header" href="#viewing-rules">Viewing Rules</a></h3>
<pre><code class="language-bash"># List all rules in filter table
iptables -L

# List with line numbers
iptables -L --line-numbers

# List with numeric output (no DNS resolution)
iptables -L -n

# List with verbose output (packet/byte counters)
iptables -L -v

# List specific chain
iptables -L INPUT

# List specific table
iptables -t nat -L

# Combine options for best output
iptables -t filter -L -n -v --line-numbers
</code></pre>
<h3 id="adding-rules"><a class="header" href="#adding-rules">Adding Rules</a></h3>
<pre><code class="language-bash"># Append rule to end of chain (-A)
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Insert rule at specific position (-I)
iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT

# Insert at beginning (default position 1)
iptables -I INPUT -p tcp --dport 443 -j ACCEPT
</code></pre>
<h3 id="deleting-rules"><a class="header" href="#deleting-rules">Deleting Rules</a></h3>
<pre><code class="language-bash"># Delete by specification
iptables -D INPUT -p tcp --dport 80 -j ACCEPT

# Delete by line number
iptables -D INPUT 3

# Flush all rules in chain
iptables -F INPUT

# Flush all rules in table
iptables -F

# Flush all rules in all tables
iptables -F
iptables -t nat -F
iptables -t mangle -F
iptables -t raw -F
</code></pre>
<h3 id="modifying-rules"><a class="header" href="#modifying-rules">Modifying Rules</a></h3>
<pre><code class="language-bash"># Replace rule at specific line
iptables -R INPUT 2 -p tcp --dport 8080 -j ACCEPT

# Change default policy
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT
</code></pre>
<h3 id="saving-and-restoring-rules"><a class="header" href="#saving-and-restoring-rules">Saving and Restoring Rules</a></h3>
<pre><code class="language-bash"># Save current rules (Debian/Ubuntu)
iptables-save &gt; /etc/iptables/rules.v4
ip6tables-save &gt; /etc/iptables/rules.v6

# Save current rules (RedHat/CentOS)
service iptables save

# Restore rules
iptables-restore &lt; /etc/iptables/rules.v4

# Restore with testing (flush on error)
iptables-restore --test &lt; /etc/iptables/rules.v4
</code></pre>
<h3 id="resetting-firewall"><a class="header" href="#resetting-firewall">Resetting Firewall</a></h3>
<pre><code class="language-bash"># Reset everything to defaults
iptables -F                    # Flush all rules
iptables -X                    # Delete all custom chains
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -P INPUT ACCEPT       # Set default policies
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
</code></pre>
<h2 id="filtering-patterns"><a class="header" href="#filtering-patterns">Filtering Patterns</a></h2>
<h3 id="port-based-filtering"><a class="header" href="#port-based-filtering">Port-Based Filtering</a></h3>
<pre><code class="language-bash"># Allow specific TCP port
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Allow specific UDP port
iptables -A INPUT -p udp --dport 53 -j ACCEPT

# Allow port range
iptables -A INPUT -p tcp --dport 6000:6010 -j ACCEPT

# Allow multiple ports (requires multiport module)
iptables -A INPUT -p tcp -m multiport --dports 80,443,8080 -j ACCEPT

# Block specific port
iptables -A INPUT -p tcp --dport 23 -j DROP

# Allow source port
iptables -A INPUT -p tcp --sport 1024:65535 -j ACCEPT
</code></pre>
<h3 id="protocol-based-filtering"><a class="header" href="#protocol-based-filtering">Protocol-Based Filtering</a></h3>
<pre><code class="language-bash"># Allow all TCP
iptables -A INPUT -p tcp -j ACCEPT

# Allow all UDP
iptables -A INPUT -p udp -j ACCEPT

# Allow ICMP (ping)
iptables -A INPUT -p icmp -j ACCEPT

# Allow specific ICMP types
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT

# Block ICMP
iptables -A INPUT -p icmp -j DROP

# Allow GRE (VPN protocol)
iptables -A INPUT -p gre -j ACCEPT

# Allow ESP (IPsec)
iptables -A INPUT -p esp -j ACCEPT
</code></pre>
<h3 id="ip-address-filtering"><a class="header" href="#ip-address-filtering">IP Address Filtering</a></h3>
<pre><code class="language-bash"># Allow from specific IP
iptables -A INPUT -s 192.168.1.100 -j ACCEPT

# Allow from subnet
iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT

# Block specific IP
iptables -A INPUT -s 10.0.0.50 -j DROP

# Block subnet
iptables -A INPUT -s 172.16.0.0/16 -j DROP

# Allow to specific destination
iptables -A OUTPUT -d 8.8.8.8 -j ACCEPT

# Multiple source IPs (iprange module)
iptables -A INPUT -m iprange --src-range 192.168.1.100-192.168.1.200 -j ACCEPT

# Invert match (all except)
iptables -A INPUT ! -s 192.168.1.0/24 -j DROP
</code></pre>
<h3 id="interface-based-filtering"><a class="header" href="#interface-based-filtering">Interface-Based Filtering</a></h3>
<pre><code class="language-bash"># Allow from specific interface
iptables -A INPUT -i eth0 -j ACCEPT

# Block from interface
iptables -A INPUT -i eth1 -j DROP

# Allow forwarding between interfaces
iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT

# Allow from specific interface to specific destination
iptables -A INPUT -i eth0 -d 192.168.1.1 -j ACCEPT

# Wildcard interfaces
iptables -A INPUT -i eth+ -j ACCEPT  # eth0, eth1, eth2, etc.
iptables -A INPUT -i wlan+ -j ACCEPT  # wlan0, wlan1, etc.
</code></pre>
<h3 id="state-based-filtering-stateful-firewall"><a class="header" href="#state-based-filtering-stateful-firewall">State-Based Filtering (Stateful Firewall)</a></h3>
<p>Connection tracking allows stateful inspection:</p>
<pre><code class="language-bash"># Allow established and related connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Alternative using state module (deprecated, use conntrack)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow new connections from specific IP
iptables -A INPUT -s 192.168.1.0/24 -m conntrack --ctstate NEW -j ACCEPT

# Drop invalid packets
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# Allow only established connections
iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT
</code></pre>
<p><strong>Connection States</strong>:</p>
<ul>
<li><strong>NEW</strong>: First packet of a new connection</li>
<li><strong>ESTABLISHED</strong>: Part of an established connection</li>
<li><strong>RELATED</strong>: Related to an established connection (e.g., FTP data channel, ICMP errors)</li>
<li><strong>INVALID</strong>: Packet doesn't belong to any known connection</li>
<li><strong>UNTRACKED</strong>: Packet marked in raw table to bypass tracking</li>
</ul>
<h3 id="mac-address-filtering"><a class="header" href="#mac-address-filtering">MAC Address Filtering</a></h3>
<pre><code class="language-bash"># Allow specific MAC address
iptables -A INPUT -m mac --mac-source 00:11:22:33:44:55 -j ACCEPT

# Block MAC address
iptables -A INPUT -m mac --mac-source AA:BB:CC:DD:EE:FF -j DROP

# Allow MAC and IP combination
iptables -A INPUT -s 192.168.1.100 -m mac --mac-source 00:11:22:33:44:55 -j ACCEPT
</code></pre>
<h2 id="nat-patterns"><a class="header" href="#nat-patterns">NAT Patterns</a></h2>
<h3 id="source-nat-snat"><a class="header" href="#source-nat-snat">Source NAT (SNAT)</a></h3>
<p>Replace source IP address of outgoing packets.</p>
<pre><code class="language-bash"># SNAT to specific IP
iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 203.0.113.1

# SNAT with port range
iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 203.0.113.1:1024-65535

# SNAT to IP range (load balancing)
iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 203.0.113.1-203.0.113.10

# SNAT for specific source network
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to-source 203.0.113.1
</code></pre>
<h3 id="masquerading"><a class="header" href="#masquerading">Masquerading</a></h3>
<p>Dynamic SNAT for connections with dynamic IP (like DHCP).</p>
<pre><code class="language-bash"># Basic masquerading
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# Masquerade specific subnet
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE

# Masquerade with port range
iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE --to-ports 1024-65535

# Enable IP forwarding (required for NAT/masquerading)
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
# Permanent: edit /etc/sysctl.conf
# net.ipv4.ip_forward = 1
</code></pre>
<h3 id="destination-nat-dnat"><a class="header" href="#destination-nat-dnat">Destination NAT (DNAT)</a></h3>
<p>Redirect traffic to different destination (port forwarding).</p>
<pre><code class="language-bash"># Forward port 80 to internal server
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100

# Forward port 8080 to port 80 on internal server
iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80

# Forward from specific interface
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j DNAT --to-destination 192.168.1.100:443

# Load balance across multiple servers
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode random --probability 0.5 -j DNAT --to-destination 192.168.1.100
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.101
</code></pre>
<h3 id="port-forwarding-complete-example"><a class="header" href="#port-forwarding-complete-example">Port Forwarding (Complete Example)</a></h3>
<pre><code class="language-bash"># External port 2222 → Internal server port 22
# DNAT (redirect incoming)
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 2222 -j DNAT --to-destination 192.168.1.100:22

# FORWARD rule (allow through firewall)
iptables -A FORWARD -p tcp -d 192.168.1.100 --dport 22 -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT

# SNAT/MASQUERADE (if needed for return traffic)
iptables -t nat -A POSTROUTING -o eth1 -d 192.168.1.100 -j MASQUERADE
</code></pre>
<h3 id="redirect-local-port-redirection"><a class="header" href="#redirect-local-port-redirection">Redirect (Local Port Redirection)</a></h3>
<pre><code class="language-bash"># Redirect local port 80 to 8080
iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port 8080

# Redirect incoming to local port (transparent proxy)
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 3128

# Redirect from specific IP
iptables -t nat -A PREROUTING -s 192.168.1.0/24 -p tcp --dport 80 -j REDIRECT --to-port 8080
</code></pre>
<h3 id="11-nat-bidirectional-nat"><a class="header" href="#11-nat-bidirectional-nat">1:1 NAT (Bidirectional NAT)</a></h3>
<pre><code class="language-bash"># Map external IP to internal IP (both directions)
# Incoming
iptables -t nat -A PREROUTING -d 203.0.113.1 -j DNAT --to-destination 192.168.1.100
# Outgoing
iptables -t nat -A POSTROUTING -s 192.168.1.100 -j SNAT --to-source 203.0.113.1
</code></pre>
<h2 id="advanced-filtering"><a class="header" href="#advanced-filtering">Advanced Filtering</a></h2>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<p>Protect against DoS attacks and limit connection rates.</p>
<pre><code class="language-bash"># Limit SSH connections (3 per minute)
iptables -A INPUT -p tcp --dport 22 -m limit --limit 3/min --limit-burst 5 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP

# Limit ICMP (ping) requests
iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/s --limit-burst 3 -j ACCEPT
iptables -A INPUT -p icmp --icmp-type echo-request -j DROP

# Limit HTTP connections
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT

# Per-IP rate limiting (requires recent module)
iptables -A INPUT -p tcp --dport 80 -m recent --name HTTP --set
iptables -A INPUT -p tcp --dport 80 -m recent --name HTTP --update --seconds 60 --hitcount 20 -j DROP
</code></pre>
<h3 id="connection-limiting"><a class="header" href="#connection-limiting">Connection Limiting</a></h3>
<pre><code class="language-bash"># Limit concurrent connections per IP (max 10)
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j REJECT

# Limit with specific message
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j REJECT --reject-with tcp-reset

# Limit per subnet mask
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 5 --connlimit-mask 24 -j REJECT

# Limit SSH connections per IP
iptables -A INPUT -p tcp --dport 22 -m connlimit --connlimit-above 3 -j DROP
</code></pre>
<h3 id="recent-module-dynamic-blacklisting"><a class="header" href="#recent-module-dynamic-blacklisting">Recent Module (Dynamic Blacklisting)</a></h3>
<p>Track and block IPs based on recent activity.</p>
<pre><code class="language-bash"># SSH brute force protection
# Mark new SSH connections
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set --name SSH

# Block if more than 3 attempts in 60 seconds
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name SSH -j DROP

# Port scan protection
iptables -A INPUT -m recent --name portscan --rcheck --seconds 86400 -j DROP
iptables -A INPUT -m recent --name portscan --remove
iptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
iptables -A INPUT -p tcp --tcp-flags ALL ALL -m recent --set --name portscan -j DROP

# Show recent list
cat /proc/net/xt_recent/SSH
</code></pre>
<h3 id="string-matching"><a class="header" href="#string-matching">String Matching</a></h3>
<p>Filter packets based on content.</p>
<pre><code class="language-bash"># Block HTTP requests containing specific string
iptables -A INPUT -p tcp --dport 80 -m string --string "GET /admin" --algo bm -j DROP

# Block specific user agent
iptables -A INPUT -p tcp --dport 80 -m string --string "User-Agent: BadBot" --algo bm -j DROP

# Case insensitive match
iptables -A INPUT -p tcp --dport 80 -m string --string "wordpress" --algo bm --icase -j LOG --log-prefix "WordPress access: "

# Block outgoing traffic containing password
iptables -A OUTPUT -p tcp -m string --string "password=" --algo kmp -j REJECT
</code></pre>
<p><strong>Algorithms</strong>:</p>
<ul>
<li><code>bm</code>: Boyer-Moore (faster for longer strings)</li>
<li><code>kmp</code>: Knuth-Pratt-Morris (better for multiple pattern matching)</li>
</ul>
<h3 id="time-based-rules"><a class="header" href="#time-based-rules">Time-Based Rules</a></h3>
<pre><code class="language-bash"># Allow SSH only during business hours
iptables -A INPUT -p tcp --dport 22 -m time --timestart 09:00 --timestop 17:00 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP

# Allow on specific days (Mon-Fri)
iptables -A INPUT -p tcp --dport 22 -m time --weekdays Mon,Tue,Wed,Thu,Fri -j ACCEPT

# Block during specific time range
iptables -A INPUT -p tcp --dport 80 -m time --timestart 02:00 --timestop 04:00 -j DROP

# Combine time and days
iptables -A FORWARD -m time --weekdays Mon,Tue,Wed,Thu,Fri --timestart 08:00 --timestop 18:00 -j ACCEPT
</code></pre>
<h3 id="geoip-filtering"><a class="header" href="#geoip-filtering">GeoIP Filtering</a></h3>
<p>Block or allow traffic from specific countries (requires xt_geoip module).</p>
<pre><code class="language-bash"># Block traffic from specific country
iptables -A INPUT -m geoip --src-cc CN,RU -j DROP

# Allow only from specific countries
iptables -A INPUT -m geoip --src-cc US,CA,GB -j ACCEPT
iptables -A INPUT -j DROP

# Block to specific country
iptables -A OUTPUT -m geoip --dst-cc KP -j REJECT
</code></pre>
<h3 id="owner-matching-output-chain"><a class="header" href="#owner-matching-output-chain">Owner Matching (OUTPUT Chain)</a></h3>
<p>Filter based on process owner.</p>
<pre><code class="language-bash"># Allow only root to make connections
iptables -A OUTPUT -m owner --uid-owner 0 -j ACCEPT
iptables -A OUTPUT -j DROP

# Block specific user from internet
iptables -A OUTPUT -m owner --uid-owner 1001 -j REJECT

# Allow specific group
iptables -A OUTPUT -m owner --gid-owner 1000 -j ACCEPT

# Block by process
iptables -A OUTPUT -m owner --uid-owner www-data -d 192.168.1.0/24 -j DROP
</code></pre>
<h3 id="ttl-manipulation"><a class="header" href="#ttl-manipulation">TTL Manipulation</a></h3>
<pre><code class="language-bash"># Set TTL for outgoing packets
iptables -t mangle -A POSTROUTING -j TTL --ttl-set 64

# Increment TTL
iptables -t mangle -A POSTROUTING -j TTL --ttl-inc 1

# Decrement TTL
iptables -t mangle -A PREROUTING -j TTL --ttl-dec 1

# Match TTL value
iptables -A INPUT -m ttl --ttl-eq 64 -j ACCEPT
iptables -A INPUT -m ttl --ttl-gt 128 -j DROP
</code></pre>
<h3 id="packet-marking"><a class="header" href="#packet-marking">Packet Marking</a></h3>
<p>Mark packets for advanced routing or QoS.</p>
<pre><code class="language-bash"># Mark packets in mangle table
iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 1
iptables -t mangle -A PREROUTING -p tcp --dport 80 -j MARK --set-mark 2

# Match marked packets
iptables -A FORWARD -m mark --mark 1 -j ACCEPT

# Use with connmark (mark entire connection)
iptables -t mangle -A PREROUTING -j CONNMARK --restore-mark
iptables -t mangle -A PREROUTING -m mark --mark 0 -p tcp --dport 80 -j MARK --set-mark 2
iptables -t mangle -A PREROUTING -j CONNMARK --save-mark
</code></pre>
<h2 id="connection-tracking"><a class="header" href="#connection-tracking">Connection Tracking</a></h2>
<p>Connection tracking (conntrack) is a fundamental feature that enables stateful packet filtering.</p>
<h3 id="understanding-conntrack"><a class="header" href="#understanding-conntrack">Understanding Conntrack</a></h3>
<pre><code class="language-bash"># View current connections
conntrack -L

# View specific protocol
conntrack -L -p tcp

# View connections by IP
conntrack -L -s 192.168.1.100
conntrack -L -d 192.168.1.100

# Count connections
conntrack -L -o extended | wc -l

# View connection statistics
cat /proc/net/nf_conntrack

# View conntrack limits
sysctl net.netfilter.nf_conntrack_max
sysctl net.netfilter.nf_conntrack_count
</code></pre>
<h3 id="connection-states"><a class="header" href="#connection-states">Connection States</a></h3>
<pre><code>NEW → ESTABLISHED → (optional) RELATED → FIN_WAIT/CLOSE_WAIT → TIME_WAIT → CLOSED
</code></pre>
<h3 id="conntrack-tuning"><a class="header" href="#conntrack-tuning">Conntrack Tuning</a></h3>
<pre><code class="language-bash"># Increase connection tracking table size
sysctl -w net.netfilter.nf_conntrack_max=262144

# Timeout settings (seconds)
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established=7200
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_time_wait=120
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_close_wait=60
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_fin_wait=120

# UDP timeouts
sysctl -w net.netfilter.nf_conntrack_udp_timeout=30
sysctl -w net.netfilter.nf_conntrack_udp_timeout_stream=180

# Make permanent in /etc/sysctl.conf
cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF
net.netfilter.nf_conntrack_max = 262144
net.netfilter.nf_conntrack_tcp_timeout_established = 7200
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120
EOF
</code></pre>
<h3 id="disable-connection-tracking-performance"><a class="header" href="#disable-connection-tracking-performance">Disable Connection Tracking (Performance)</a></h3>
<p>For high-traffic servers, disable conntrack for specific traffic:</p>
<pre><code class="language-bash"># Disable tracking for HTTP traffic
iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK
iptables -t raw -A OUTPUT -p tcp --sport 80 -j NOTRACK

# Must also allow untracked traffic
iptables -A INPUT -p tcp --dport 80 -m conntrack --ctstate UNTRACKED -j ACCEPT
iptables -A OUTPUT -p tcp --sport 80 -m conntrack --ctstate UNTRACKED -j ACCEPT
</code></pre>
<h3 id="conntrack-helpers"><a class="header" href="#conntrack-helpers">Conntrack Helpers</a></h3>
<p>Handle protocols with dynamic ports (FTP, SIP, etc.):</p>
<pre><code class="language-bash"># List available helpers
cat /proc/net/nf_conntrack_helper

# Load FTP helper
modprobe nf_conntrack_ftp
modprobe nf_nat_ftp

# Load SIP helper
modprobe nf_conntrack_sip
modprobe nf_nat_sip

# Configure in iptables
iptables -A INPUT -p tcp --dport 21 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
</code></pre>
<h2 id="chain-management"><a class="header" href="#chain-management">Chain Management</a></h2>
<h3 id="creating-custom-chains"><a class="header" href="#creating-custom-chains">Creating Custom Chains</a></h3>
<p>Custom chains improve organization and performance.</p>
<pre><code class="language-bash"># Create custom chain
iptables -N CUSTOM_INPUT

# Add rules to custom chain
iptables -A CUSTOM_INPUT -p tcp --dport 80 -j ACCEPT
iptables -A CUSTOM_INPUT -p tcp --dport 443 -j ACCEPT
iptables -A CUSTOM_INPUT -j DROP

# Jump to custom chain from main chain
iptables -A INPUT -j CUSTOM_INPUT

# List custom chain
iptables -L CUSTOM_INPUT -n -v
</code></pre>
<h3 id="common-custom-chain-patterns"><a class="header" href="#common-custom-chain-patterns">Common Custom Chain Patterns</a></h3>
<pre><code class="language-bash"># Create logging chain
iptables -N LOG_DROP
iptables -A LOG_DROP -j LOG --log-prefix "IPTables-Dropped: " --log-level 4
iptables -A LOG_DROP -j DROP

# Use logging chain
iptables -A INPUT -p tcp --dport 23 -j LOG_DROP

# Create SSH protection chain
iptables -N SSH_PROTECT
iptables -A SSH_PROTECT -m recent --name SSH --set
iptables -A SSH_PROTECT -m recent --name SSH --update --seconds 60 --hitcount 4 -j LOG_DROP
iptables -A SSH_PROTECT -j ACCEPT

# Use SSH protection
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j SSH_PROTECT

# Create web service chain
iptables -N WEB_SERVICES
iptables -A WEB_SERVICES -p tcp --dport 80 -j ACCEPT
iptables -A WEB_SERVICES -p tcp --dport 443 -j ACCEPT
iptables -A WEB_SERVICES -p tcp --dport 8080 -j ACCEPT
iptables -A WEB_SERVICES -j RETURN

# Jump to web services
iptables -A INPUT -j WEB_SERVICES
</code></pre>
<h3 id="deleting-custom-chains"><a class="header" href="#deleting-custom-chains">Deleting Custom Chains</a></h3>
<pre><code class="language-bash"># Must flush chain first
iptables -F CUSTOM_INPUT

# Then delete it
iptables -X CUSTOM_INPUT

# Delete all custom chains (careful!)
iptables -X
</code></pre>
<h3 id="default-policies"><a class="header" href="#default-policies">Default Policies</a></h3>
<pre><code class="language-bash"># Set restrictive default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# View current policies
iptables -L | grep policy

# Temporary accept-all (dangerous!)
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
</code></pre>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="basic-firewall-setup"><a class="header" href="#basic-firewall-setup">Basic Firewall Setup</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Basic server firewall

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# Set default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Allow established connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Drop invalid packets
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# Allow SSH (rate limited)
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set --name SSH
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name SSH -j DROP
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Allow HTTP/HTTPS
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Allow ping (limited)
iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/s --limit-burst 3 -j ACCEPT

# Log dropped packets
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables-INPUT-dropped: " --log-level 4

# Save rules
iptables-save &gt; /etc/iptables/rules.v4
</code></pre>
<h3 id="web-server-protection"><a class="header" href="#web-server-protection">Web Server Protection</a></h3>
<pre><code class="language-bash"># Create web protection chain
iptables -N WEB_PROTECT

# SYN flood protection
iptables -A WEB_PROTECT -p tcp --syn -m limit --limit 2/s --limit-burst 30 -j ACCEPT
iptables -A WEB_PROTECT -p tcp --syn -j DROP

# Connection limiting per IP
iptables -A WEB_PROTECT -p tcp --dport 80 -m connlimit --connlimit-above 20 -j REJECT --reject-with tcp-reset
iptables -A WEB_PROTECT -p tcp --dport 443 -m connlimit --connlimit-above 20 -j REJECT --reject-with tcp-reset

# Block common attack patterns
iptables -A WEB_PROTECT -p tcp --dport 80 -m string --string "../../" --algo bm -j DROP
iptables -A WEB_PROTECT -p tcp --dport 80 -m string --string "SELECT * FROM" --algo bm -j DROP

# Rate limit new connections
iptables -A WEB_PROTECT -p tcp --dport 80 -m conntrack --ctstate NEW -m recent --set --name HTTP
iptables -A WEB_PROTECT -p tcp --dport 80 -m recent --update --seconds 60 --hitcount 50 --name HTTP -j DROP

# Accept legitimate traffic
iptables -A WEB_PROTECT -j ACCEPT

# Apply to INPUT
iptables -A INPUT -p tcp -m multiport --dports 80,443 -j WEB_PROTECT
</code></pre>
<h3 id="ssh-brute-force-protection"><a class="header" href="#ssh-brute-force-protection">SSH Brute Force Protection</a></h3>
<pre><code class="language-bash"># Method 1: Using recent module
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set --name SSH
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name SSH -j LOG --log-prefix "SSH-brute-force: "
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 --name SSH -j DROP
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Method 2: Using limit module
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m limit --limit 3/min --limit-burst 3 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j DROP
</code></pre>
<h3 id="home-routergateway-nat"><a class="header" href="#home-routergateway-nat">Home Router/Gateway NAT</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Home router configuration

# Enable IP forwarding
echo 1 &gt; /proc/sys/net/ipv4/ip_forward

# Set default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT

# Allow established connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Allow from LAN
iptables -A INPUT -i eth1 -s 192.168.1.0/24 -j ACCEPT

# Allow forwarding from LAN to WAN
iptables -A FORWARD -i eth1 -o eth0 -s 192.168.1.0/24 -j ACCEPT

# NAT for LAN
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.1.0/24 -j MASQUERADE

# Port forwarding example (web server on 192.168.1.100)
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100:80
iptables -A FORWARD -p tcp -d 192.168.1.100 --dport 80 -j ACCEPT

# Allow DNS for router itself
iptables -A INPUT -p udp --dport 53 -j ACCEPT

# Allow DHCP for router itself
iptables -A INPUT -p udp --dport 67:68 -j ACCEPT

# Save rules
iptables-save &gt; /etc/iptables/rules.v4
</code></pre>
<h3 id="docker-network-integration"><a class="header" href="#docker-network-integration">Docker Network Integration</a></h3>
<pre><code class="language-bash"># Allow docker containers to internet
iptables -A FORWARD -i docker0 -o eth0 -j ACCEPT
iptables -A FORWARD -i eth0 -o docker0 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

# Expose container port
# Container 172.17.0.2:8080 → Host port 80
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 172.17.0.2:8080
iptables -A FORWARD -p tcp -d 172.17.0.2 --dport 8080 -j ACCEPT

# Isolate docker network from other networks
iptables -I FORWARD -i docker0 ! -o docker0 -j DROP
iptables -I FORWARD -i docker0 -o docker0 -j ACCEPT
</code></pre>
<h3 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h3>
<pre><code class="language-bash"># Simple round-robin load balancing
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode nth --every 3 --packet 0 -j DNAT --to-destination 192.168.1.10:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode nth --every 2 --packet 0 -j DNAT --to-destination 192.168.1.11:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.12:80

# Random load balancing
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode random --probability 0.33 -j DNAT --to-destination 192.168.1.10:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode random --probability 0.5 -j DNAT --to-destination 192.168.1.11:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.12:80
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li>
<p><strong>Default Deny Policy</strong></p>
<pre><code class="language-bash"># Start with restrictive defaults
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT  # or DROP for maximum security
</code></pre>
</li>
<li>
<p><strong>Allow Loopback</strong></p>
<pre><code class="language-bash"># Always allow loopback interface
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
</code></pre>
</li>
<li>
<p><strong>Drop Invalid Packets</strong></p>
<pre><code class="language-bash">iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
</code></pre>
</li>
<li>
<p><strong>Rate Limiting Critical Services</strong></p>
<pre><code class="language-bash"># Always rate limit SSH
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set
iptables -A INPUT -p tcp --dport 22 -m recent --update --seconds 60 --hitcount 4 -j DROP
</code></pre>
</li>
<li>
<p><strong>Log Suspicious Activity</strong></p>
<pre><code class="language-bash"># Log before dropping
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables-denied: "
</code></pre>
</li>
</ol>
<h3 id="rule-ordering"><a class="header" href="#rule-ordering">Rule Ordering</a></h3>
<p><strong>Critical</strong>: Rules are processed top-to-bottom. First match wins!</p>
<pre><code class="language-bash"># WRONG ORDER (SSH rule never reached)
iptables -A INPUT -j DROP
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# CORRECT ORDER
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -j DROP

# Best practice: specific rules first, general rules last
iptables -A INPUT -i lo -j ACCEPT                              # 1. Loopback
iptables -A INPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT # 2. Established
iptables -A INPUT -p tcp --dport 22 -j ACCEPT                  # 3. Specific services
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -j LOG --log-prefix "dropped: "              # 4. Log
iptables -A INPUT -j DROP                                      # 5. Default deny
</code></pre>
<h3 id="testing-safely"><a class="header" href="#testing-safely">Testing Safely</a></h3>
<pre><code class="language-bash"># Method 1: Auto-reset with at command
at now + 5 minutes &lt;&lt;&lt; 'iptables -F; iptables -P INPUT ACCEPT; iptables -P OUTPUT ACCEPT; iptables -P FORWARD ACCEPT'
# Now test your rules; if you get locked out, rules reset in 5 minutes

# Method 2: Test script
#!/bin/bash
iptables-restore &lt; /etc/iptables/test-rules.v4
echo "Rules applied. You have 60 seconds to test. Press Ctrl+C to keep, or wait to rollback."
sleep 60
iptables-restore &lt; /etc/iptables/rules.v4
echo "Rolled back to previous rules"

# Method 3: iptables-apply (Debian/Ubuntu)
iptables-apply /etc/iptables/test-rules.v4
# Prompts for confirmation; auto-rollback if no response
</code></pre>
<h3 id="backup-and-restore"><a class="header" href="#backup-and-restore">Backup and Restore</a></h3>
<pre><code class="language-bash"># Backup current rules
iptables-save &gt; /root/iptables-backup-$(date +%Y%m%d-%H%M%S).rules

# Restore from backup
iptables-restore &lt; /root/iptables-backup-20250114-120000.rules

# Automated backup before changes
#!/bin/bash
BACKUP_DIR="/root/iptables-backups"
mkdir -p $BACKUP_DIR
iptables-save &gt; $BACKUP_DIR/rules-$(date +%Y%m%d-%H%M%S).v4
# Keep only last 10 backups
ls -t $BACKUP_DIR/rules-*.v4 | tail -n +11 | xargs -r rm
</code></pre>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ol>
<li>
<p><strong>Put most common rules first</strong></p>
<pre><code class="language-bash"># High-traffic rules at top
iptables -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
</code></pre>
</li>
<li>
<p><strong>Use custom chains for organization</strong></p>
<pre><code class="language-bash"># Jump to specific chain early
iptables -A INPUT -p tcp --dport 80 -j WEB_CHAIN
</code></pre>
</li>
<li>
<p><strong>Minimize rule count</strong></p>
<pre><code class="language-bash"># Use multiport instead of multiple rules
# INEFFICIENT
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT
iptables -A INPUT -p tcp --dport 8080 -j ACCEPT

# EFFICIENT
iptables -A INPUT -p tcp -m multiport --dports 80,443,8080 -j ACCEPT
</code></pre>
</li>
<li>
<p><strong>Use NOTRACK for high-volume traffic</strong></p>
<pre><code class="language-bash">iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK
</code></pre>
</li>
</ol>
<h3 id="persistence-across-reboots"><a class="header" href="#persistence-across-reboots">Persistence Across Reboots</a></h3>
<p><strong>Debian/Ubuntu:</strong></p>
<pre><code class="language-bash"># Install persistence package
apt-get install iptables-persistent

# Save rules
netfilter-persistent save

# Manual save
iptables-save &gt; /etc/iptables/rules.v4
ip6tables-save &gt; /etc/iptables/rules.v6
</code></pre>
<p><strong>RedHat/CentOS:</strong></p>
<pre><code class="language-bash"># Save rules
service iptables save
# Saves to /etc/sysconfig/iptables

# Enable on boot
systemctl enable iptables
</code></pre>
<p><strong>Generic (systemd service):</strong></p>
<pre><code class="language-bash"># Create restore script
cat &gt; /etc/iptables/restore.sh &lt;&lt; 'EOF'
#!/bin/bash
iptables-restore &lt; /etc/iptables/rules.v4
ip6tables-restore &lt; /etc/iptables/rules.v6
EOF
chmod +x /etc/iptables/restore.sh

# Create systemd service
cat &gt; /etc/systemd/system/iptables-restore.service &lt;&lt; 'EOF'
[Unit]
Description=Restore iptables rules
Before=network-pre.target
Wants=network-pre.target

[Service]
Type=oneshot
ExecStart=/etc/iptables/restore.sh

[Install]
WantedBy=multi-user.target
EOF

systemctl enable iptables-restore.service
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="debugging-rules"><a class="header" href="#debugging-rules">Debugging Rules</a></h3>
<pre><code class="language-bash"># Enable verbose logging for specific rule
iptables -A INPUT -p tcp --dport 80 -j LOG --log-prefix "HTTP-DEBUG: " --log-level 7

# Watch logs in real-time
tail -f /var/log/kern.log | grep iptables
# or
dmesg -w | grep iptables

# Trace packet path
# Add TRACE target in raw table
iptables -t raw -A PREROUTING -p tcp --dport 80 -j TRACE
iptables -t raw -A OUTPUT -p tcp --sport 80 -j TRACE

# View trace (requires iptables logging)
tail -f /var/log/kern.log | grep TRACE

# Don't forget to remove TRACE when done!
iptables -t raw -D PREROUTING -p tcp --dport 80 -j TRACE
</code></pre>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Issue 1: Rules not persisting after reboot</strong></p>
<pre><code class="language-bash"># Solution: Save and configure persistence
iptables-save &gt; /etc/iptables/rules.v4
apt-get install iptables-persistent  # Debian/Ubuntu
</code></pre>
<p><strong>Issue 2: Locked out after applying rules</strong></p>
<pre><code class="language-bash"># Prevention: Always allow established connections first
iptables -I INPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Recovery: Access via console or KVM, then:
iptables -F
iptables -P INPUT ACCEPT
</code></pre>
<p><strong>Issue 3: NAT not working</strong></p>
<pre><code class="language-bash"># Check IP forwarding
cat /proc/sys/net/ipv4/ip_forward  # Should be 1
echo 1 &gt; /proc/sys/net/ipv4/ip_forward

# Verify NAT rules
iptables -t nat -L -n -v

# Check routing
ip route show
</code></pre>
<p><strong>Issue 4: Connection tracking table full</strong></p>
<pre><code class="language-bash"># Check current usage
cat /proc/sys/net/netfilter/nf_conntrack_count
cat /proc/sys/net/netfilter/nf_conntrack_max

# Increase limit
sysctl -w net.netfilter.nf_conntrack_max=262144

# Or use NOTRACK for high-volume traffic
iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK
</code></pre>
<p><strong>Issue 5: Performance degradation</strong></p>
<pre><code class="language-bash"># Check rule count
iptables -L -n | wc -l

# Analyze rule hit counters
iptables -L -n -v --line-numbers

# Optimize: Move frequently matched rules to top
# Use ipset for large IP lists instead of many rules
</code></pre>
<h3 id="diagnostic-commands"><a class="header" href="#diagnostic-commands">Diagnostic Commands</a></h3>
<pre><code class="language-bash"># Show all rules with packet counters
iptables -L -n -v --line-numbers

# Show all rules in all tables
for table in filter nat mangle raw security; do
    echo "=== Table: $table ==="
    iptables -t $table -L -n -v --line-numbers
done

# Check if module is loaded
lsmod | grep iptable
lsmod | grep nf_conntrack

# View connection tracking
conntrack -L
conntrack -L | wc -l  # Count connections

# View NAT translations
conntrack -L -p tcp --dport 80

# Performance stats
iptables -L -n -v -x  # Extended counters
</code></pre>
<h3 id="testing-rules"><a class="header" href="#testing-rules">Testing Rules</a></h3>
<pre><code class="language-bash"># Test with specific packet
# Install hping3
apt-get install hping3

# Send SYN packet
hping3 -S -p 80 192.168.1.1

# Send UDP packet
hping3 --udp -p 53 8.8.8.8

# Test with netcat
nc -v -w 2 192.168.1.1 80

# Test with nmap
nmap -p 22,80,443 192.168.1.1
</code></pre>
<h2 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h2>
<h3 id="connection-tracking-optimization"><a class="header" href="#connection-tracking-optimization">Connection Tracking Optimization</a></h3>
<pre><code class="language-bash"># Increase connection tracking table
sysctl -w net.netfilter.nf_conntrack_max=524288
sysctl -w net.netfilter.nf_conntrack_buckets=131072

# Reduce timeouts for high-traffic servers
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established=600
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_time_wait=30
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_close_wait=30
sysctl -w net.netfilter.nf_conntrack_tcp_timeout_fin_wait=30

# Disable tracking for specific high-volume traffic
iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK
iptables -t raw -A OUTPUT -p tcp --sport 80 -j NOTRACK
iptables -A INPUT -p tcp --dport 80 -m state --state UNTRACKED -j ACCEPT
iptables -A OUTPUT -p tcp --sport 80 -m state --state UNTRACKED -j ACCEPT
</code></pre>
<h3 id="hash-limits"><a class="header" href="#hash-limits">Hash Limits</a></h3>
<p>For rate limiting at scale:</p>
<pre><code class="language-bash"># Use hashlimit instead of limit for per-IP limiting
iptables -A INPUT -p tcp --dport 80 \
    -m hashlimit --hashlimit-name http \
    --hashlimit-above 50/sec --hashlimit-burst 100 \
    --hashlimit-mode srcip -j DROP

# Per subnet limiting
iptables -A INPUT -p tcp --dport 22 \
    -m hashlimit --hashlimit-name ssh \
    --hashlimit-above 3/min \
    --hashlimit-mode srcip --hashlimit-srcmask 24 -j DROP
</code></pre>
<h3 id="ipset-integration"><a class="header" href="#ipset-integration">ipset Integration</a></h3>
<p>Use ipset for managing large IP lists efficiently:</p>
<pre><code class="language-bash"># Install ipset
apt-get install ipset

# Create IP set
ipset create blacklist hash:ip hashsize 4096

# Add IPs to set
ipset add blacklist 192.168.1.100
ipset add blacklist 10.0.0.0/8

# Use in iptables (single rule for entire set!)
iptables -A INPUT -m set --match-set blacklist src -j DROP

# Manage set
ipset list blacklist
ipset del blacklist 192.168.1.100
ipset flush blacklist
ipset destroy blacklist

# Save/restore sets
ipset save &gt; /etc/ipset.conf
ipset restore &lt; /etc/ipset.conf
</code></pre>
<h3 id="packet-processing-optimization"><a class="header" href="#packet-processing-optimization">Packet Processing Optimization</a></h3>
<pre><code class="language-bash"># Drop invalid packets early (raw table)
iptables -t raw -A PREROUTING -m conntrack --ctstate INVALID -j DROP

# Early accept for established connections
iptables -I INPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Use conntrack instead of state module
# SLOWER
iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
# FASTER
iptables -A INPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT
</code></pre>
<h3 id="monitoring-performance"><a class="header" href="#monitoring-performance">Monitoring Performance</a></h3>
<pre><code class="language-bash"># Check packet processing rate
watch -n 1 'iptables -L -n -v -x'

# Identify slow rules
time iptables -L -n &gt; /dev/null

# Profile rule matching
for i in $(seq 1 $(iptables -L INPUT --line-numbers | tail -n +3 | wc -l)); do
    echo -n "Rule $i: "
    iptables -L INPUT $i -n -v | grep -v '^Chain' | grep -v '^target'
done
</code></pre>
<h2 id="modern-alternatives"><a class="header" href="#modern-alternatives">Modern Alternatives</a></h2>
<h3 id="nftables"><a class="header" href="#nftables">nftables</a></h3>
<p>nftables is the modern replacement for iptables, offering:</p>
<ul>
<li>Better performance</li>
<li>Simplified syntax</li>
<li>Atomic rule updates</li>
<li>No separate tools for IPv4/IPv6</li>
</ul>
<p><strong>Basic nftables example:</strong></p>
<pre><code class="language-bash"># Install
apt-get install nftables

# Basic firewall
nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0 \; policy drop \; }
nft add chain inet filter forward { type filter hook forward priority 0 \; policy drop \; }
nft add chain inet filter output { type filter hook output priority 0 \; policy accept \; }

# Add rules
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input iif lo accept
nft add rule inet filter input tcp dport 22 accept
nft add rule inet filter input tcp dport { 80, 443 } accept

# List rules
nft list ruleset

# Save rules
nft list ruleset &gt; /etc/nftables.conf
</code></pre>
<p><strong>Translation from iptables:</strong></p>
<pre><code class="language-bash"># iptables to nftables
iptables-translate -A INPUT -p tcp --dport 80 -j ACCEPT
# Output: nft add rule ip filter INPUT tcp dport 80 counter accept

# Translate entire ruleset
iptables-save | iptables-restore-translate
ip6tables-save | ip6tables-restore-translate
</code></pre>
<h3 id="ebpfxdp"><a class="header" href="#ebpfxdp">eBPF/XDP</a></h3>
<p>Extended Berkeley Packet Filter (eBPF) and eXpress Data Path (XDP) provide ultra-high performance packet filtering:</p>
<ul>
<li>Runs in kernel context</li>
<li>Processes packets before network stack</li>
<li>Can achieve 10Gbps+ filtering rates</li>
</ul>
<p><strong>Example use case:</strong> DDoS mitigation at wire speed</p>
<pre><code class="language-bash"># Requires modern kernel (4.8+) and tools
# Example with Cilium for Kubernetes
kubectl apply -f cilium.yaml

# Or standalone with bpfilter
# Coming in future kernels as iptables replacement
</code></pre>
<h3 id="comparison"><a class="header" href="#comparison">Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>iptables</th><th>nftables</th><th>eBPF/XDP</th></tr></thead><tbody>
<tr><td>Performance</td><td>Good</td><td>Better</td><td>Excellent</td></tr>
<tr><td>Syntax</td><td>Complex</td><td>Simpler</td><td>Programmatic</td></tr>
<tr><td>IPv4/IPv6</td><td>Separate</td><td>Unified</td><td>Unified</td></tr>
<tr><td>Atomic updates</td><td>No</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Learning curve</td><td>Moderate</td><td>Moderate</td><td>Steep</td></tr>
<tr><td>Maturity</td><td>Very mature</td><td>Mature</td><td>Emerging</td></tr>
<tr><td>Use case</td><td>General firewall</td><td>General firewall</td><td>High-performance</td></tr>
</tbody></table>
</div>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="transparent-proxy"><a class="header" href="#transparent-proxy">Transparent Proxy</a></h3>
<p>Redirect traffic to proxy without client configuration:</p>
<pre><code class="language-bash"># Redirect HTTP to Squid proxy (port 3128)
iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 80 -j REDIRECT --to-port 3128

# Prevent loop (don't redirect proxy's own traffic)
iptables -t nat -A OUTPUT -m owner --uid-owner proxy -j RETURN
iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port 3128
</code></pre>
<h3 id="policy-routing-with-fwmark"><a class="header" href="#policy-routing-with-fwmark">Policy Routing with fwmark</a></h3>
<pre><code class="language-bash"># Mark packets
iptables -t mangle -A PREROUTING -s 192.168.1.0/24 -j MARK --set-mark 1
iptables -t mangle -A PREROUTING -s 192.168.2.0/24 -j MARK --set-mark 2

# Add routing tables in /etc/iproute2/rt_tables
echo "1 ISP1" &gt;&gt; /etc/iproute2/rt_tables
echo "2 ISP2" &gt;&gt; /etc/iproute2/rt_tables

# Add routes
ip route add default via 10.0.1.1 table ISP1
ip route add default via 10.0.2.1 table ISP2

# Policy routing rules
ip rule add fwmark 1 table ISP1
ip rule add fwmark 2 table ISP2
</code></pre>
<h3 id="bridge-filtering"><a class="header" href="#bridge-filtering">Bridge Filtering</a></h3>
<p>Filter traffic between bridged interfaces:</p>
<pre><code class="language-bash"># Enable bridge netfilter
modprobe br_netfilter
echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables

# Filter bridged traffic
iptables -A FORWARD -m physdev --physdev-in eth0 --physdev-out eth1 -j ACCEPT
</code></pre>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Netfilter is a powerful and flexible framework for packet filtering and manipulation in Linux. Understanding its architecture, tables, chains, and hooks is essential for effective network management and security. While iptables has been the traditional interface, modern alternatives like nftables and eBPF offer improved performance and capabilities for specific use cases.</p>
<p><strong>Key Takeaways</strong>:</p>
<ul>
<li>Always use stateful filtering (<code>-m conntrack --ctstate ESTABLISHED,RELATED</code>)</li>
<li>Follow default-deny principle for security</li>
<li>Order rules from specific to general</li>
<li>Test rules safely with auto-rollback mechanisms</li>
<li>Monitor and optimize for performance</li>
<li>Keep rules organized with custom chains</li>
<li>Regular backups before changes</li>
<li>Consider nftables for new deployments</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://www.netfilter.org/">Netfilter Project</a></li>
<li><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">iptables Tutorial</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/networking/netfilter/">Linux Kernel Documentation - Netfilter</a></li>
<li><a href="https://wiki.nftables.org/">nftables Wiki</a></li>
<li><a href="https://conntrack-tools.netfilter.org/">Netfilter Connection Tracking</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/commands.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../linux/tc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/commands.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../linux/tc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
