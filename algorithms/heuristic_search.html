<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Heuristic Search - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-ae735e64.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-4d483330.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="heuristic-search-algorithms"><a class="header" href="#heuristic-search-algorithms">Heuristic Search Algorithms</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Heuristic search algorithms use domain knowledge and estimation functions to guide the search process, making them more efficient than blind search methods (BFS, DFS) for large state spaces. These algorithms are essential in AI, pathfinding, optimization, and machine learning applications where exhaustive search is impractical.</p>
<p><strong>Key Concepts:</strong></p>
<ul>
<li><strong>Heuristic Function</strong> $h(n)$: Estimates cost from node $n$ to goal</li>
<li><strong>Cost Function</strong> $g(n)$: Actual cost from start to node $n$</li>
<li><strong>Evaluation Function</strong> $f(n)$: Combines $g(n)$ and $h(n)$ to prioritize nodes</li>
<li><strong>Admissibility</strong>: A heuristic is admissible if it never overestimates the true cost</li>
<li><strong>Consistency</strong>: A heuristic is consistent if $h(n) \leq c(n,n’) + h(n’)$ for all neighbors</li>
</ul>
<h2 id="beam-search"><a class="header" href="#beam-search">Beam Search</a></h2>
<p><strong>Time</strong>: $O(b \cdot w \cdot d)$ | <strong>Space</strong>: $O(w \cdot d)$ | <strong>Use Case</strong>: NLP, sequence generation, constrained optimization</p>
<p>Where $b$ is branching factor, $w$ is beam width, $d$ is solution depth.</p>
<p>Beam search is a heuristic search algorithm that explores a graph by expanding the most promising nodes in a limited set (the “beam”). It’s a greedy algorithm that maintains only the top-k most promising candidates at each level, trading completeness for memory efficiency.</p>
<h3 id="core-implementation"><a class="header" href="#core-implementation">Core Implementation</a></h3>
<pre><code class="language-python">from typing import List, Callable, Tuple, Any
import heapq

def beam_search(
    initial_state,
    goal_test: Callable,
    get_neighbors: Callable,
    heuristic: Callable,
    beam_width: int = 3,
    max_depth: int = 100
) -&gt; List:
    """
    Beam search algorithm with configurable beam width.

    Args:
        initial_state: Starting state
        goal_test: Function that returns True if state is goal
        get_neighbors: Function that returns list of (next_state, cost) tuples
        heuristic: Function that estimates cost to goal from a state
        beam_width: Number of candidates to keep at each level
        max_depth: Maximum search depth

    Returns:
        List of states representing the path to goal, or empty list if not found
    """
    # Each candidate is (score, path)
    beam = [(heuristic(initial_state), [initial_state])]

    for depth in range(max_depth):
        # Check if any candidate reached goal
        for score, path in beam:
            if goal_test(path[-1]):
                return path

        # Generate all successors from current beam
        candidates = []
        for score, path in beam:
            current_state = path[-1]

            # Expand current state
            for next_state, cost in get_neighbors(current_state):
                if next_state not in path:  # Avoid cycles
                    new_path = path + [next_state]
                    # Score is the heuristic value (greedy)
                    new_score = heuristic(next_state)
                    candidates.append((new_score, new_path))

        # If no candidates, search failed
        if not candidates:
            return []

        # Keep only top beam_width candidates
        # Use negative score for min-heap to get best scores
        beam = heapq.nsmallest(beam_width, candidates, key=lambda x: x[0])

    # Return best path found if goal not reached
    return min(beam, key=lambda x: x[0])[1] if beam else []


# Example: Finding path in a grid
def grid_beam_search(grid, start, goal, beam_width=5):
    """Beam search for pathfinding in a 2D grid."""

    def goal_test(state):
        return state == goal

    def get_neighbors(state):
        x, y = state
        neighbors = []
        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
            nx, ny = x + dx, y + dy
            if (0 &lt;= nx &lt; len(grid) and
                0 &lt;= ny &lt; len(grid[0]) and
                grid[nx][ny] != '#'):  # Not a wall
                neighbors.append(((nx, ny), 1))  # cost = 1
        return neighbors

    def heuristic(state):
        # Manhattan distance
        return abs(state[0] - goal[0]) + abs(state[1] - goal[1])

    return beam_search(start, goal_test, get_neighbors, heuristic, beam_width)
</code></pre>
<h3 id="beam-search-with-cost-function"><a class="header" href="#beam-search-with-cost-function">Beam Search with Cost Function</a></h3>
<pre><code class="language-python">def beam_search_with_cost(
    initial_state,
    goal_test: Callable,
    get_neighbors: Callable,
    heuristic: Callable,
    beam_width: int = 3,
    max_depth: int = 100
) -&gt; Tuple[List, float]:
    """
    Beam search that tracks both path and cumulative cost.
    Evaluation function: f(n) = g(n) + h(n)
    """
    # Each candidate is (f_score, g_cost, path)
    beam = [(heuristic(initial_state), 0, [initial_state])]

    for depth in range(max_depth):
        for f_score, g_cost, path in beam:
            if goal_test(path[-1]):
                return path, g_cost

        candidates = []
        for f_score, g_cost, path in beam:
            current_state = path[-1]

            for next_state, step_cost in get_neighbors(current_state):
                if next_state not in path:
                    new_path = path + [next_state]
                    new_g_cost = g_cost + step_cost
                    new_h_cost = heuristic(next_state)
                    new_f_score = new_g_cost + new_h_cost
                    candidates.append((new_f_score, new_g_cost, new_path))

        if not candidates:
            break

        beam = heapq.nsmallest(beam_width, candidates, key=lambda x: x[0])

    if beam:
        best = min(beam, key=lambda x: x[0])
        return best[2], best[1]
    return [], float('inf')
</code></pre>
<h3 id="variations"><a class="header" href="#variations">Variations</a></h3>
<h4 id="1-diverse-beam-search"><a class="header" href="#1-diverse-beam-search">1. Diverse Beam Search</a></h4>
<p>Encourages diversity among beam candidates to avoid local optima:</p>
<pre><code class="language-python">def diverse_beam_search(
    initial_state,
    goal_test: Callable,
    get_neighbors: Callable,
    heuristic: Callable,
    beam_width: int = 3,
    num_groups: int = 2,
    diversity_penalty: float = 0.5,
    max_depth: int = 100
) -&gt; List:
    """
    Diverse beam search splits candidates into groups and penalizes
    similarity within groups to encourage exploration.
    """
    group_size = beam_width // num_groups
    beam = [(heuristic(initial_state), [initial_state], 0)]  # (score, path, group)

    for depth in range(max_depth):
        for score, path, group in beam:
            if goal_test(path[-1]):
                return path

        # Generate candidates for each group
        all_candidates = [[] for _ in range(num_groups)]

        for score, path, group in beam:
            current_state = path[-1]

            for next_state, cost in get_neighbors(current_state):
                if next_state not in path:
                    new_path = path + [next_state]
                    base_score = heuristic(next_state)

                    # Add diversity penalty based on similarity to other groups
                    diversity_score = 0
                    for other_group in range(num_groups):
                        if other_group != group:
                            # Simple diversity: penalize if states are similar
                            # (implementation depends on state representation)
                            similarity = compute_similarity(next_state,
                                [p[-1] for _, p, g in beam if g == other_group])
                            diversity_score += similarity * diversity_penalty

                    final_score = base_score + diversity_score
                    all_candidates[group].append((final_score, new_path, group))

        # Select top candidates from each group
        beam = []
        for group_candidates in all_candidates:
            if group_candidates:
                beam.extend(heapq.nsmallest(group_size, group_candidates,
                                           key=lambda x: x[0]))

        if not beam:
            return []

    return min(beam, key=lambda x: x[0])[1] if beam else []

def compute_similarity(state, other_states):
    """Compute similarity score (application-specific)."""
    if not other_states:
        return 0
    # Example: For sequence generation, could be token overlap
    # For pathfinding, could be distance
    return len(other_states) * 0.1  # Placeholder
</code></pre>
<h4 id="2-stochastic-beam-search"><a class="header" href="#2-stochastic-beam-search">2. Stochastic Beam Search</a></h4>
<p>Adds randomness to candidate selection for better exploration:</p>
<pre><code class="language-python">import random

def stochastic_beam_search(
    initial_state,
    goal_test: Callable,
    get_neighbors: Callable,
    heuristic: Callable,
    beam_width: int = 3,
    temperature: float = 1.0,
    max_depth: int = 100
) -&gt; List:
    """
    Stochastic beam search samples candidates probabilistically
    based on their scores rather than always taking the top-k.

    temperature: Controls randomness (lower = more greedy)
    """
    beam = [(heuristic(initial_state), [initial_state])]

    for depth in range(max_depth):
        for score, path in beam:
            if goal_test(path[-1]):
                return path

        candidates = []
        for score, path in beam:
            current_state = path[-1]

            for next_state, cost in get_neighbors(current_state):
                if next_state not in path:
                    new_path = path + [next_state]
                    new_score = heuristic(next_state)
                    candidates.append((new_score, new_path))

        if not candidates:
            return []

        # Convert scores to probabilities using softmax
        scores = [score for score, _ in candidates]
        # Apply temperature and compute probabilities
        exp_scores = [math.exp(-score / temperature) for score in scores]
        total = sum(exp_scores)
        probabilities = [exp_score / total for exp_score in exp_scores]

        # Sample beam_width candidates
        selected_indices = random.choices(
            range(len(candidates)),
            weights=probabilities,
            k=min(beam_width, len(candidates))
        )
        beam = [candidates[i] for i in selected_indices]

    return min(beam, key=lambda x: x[0])[1] if beam else []
</code></pre>
<h4 id="3-beam-search-with-pruning"><a class="header" href="#3-beam-search-with-pruning">3. Beam Search with Pruning</a></h4>
<p>Prunes unpromising candidates based on threshold:</p>
<pre><code class="language-python">def beam_search_with_pruning(
    initial_state,
    goal_test: Callable,
    get_neighbors: Callable,
    heuristic: Callable,
    beam_width: int = 3,
    pruning_threshold: float = 2.0,
    max_depth: int = 100
) -&gt; List:
    """
    Beam search with pruning removes candidates that are significantly
    worse than the best candidate.

    pruning_threshold: Candidates with score &gt; best_score * threshold are pruned
    """
    beam = [(heuristic(initial_state), [initial_state])]

    for depth in range(max_depth):
        for score, path in beam:
            if goal_test(path[-1]):
                return path

        candidates = []
        for score, path in beam:
            current_state = path[-1]

            for next_state, cost in get_neighbors(current_state):
                if next_state not in path:
                    new_path = path + [next_state]
                    new_score = heuristic(next_state)
                    candidates.append((new_score, new_path))

        if not candidates:
            return []

        # Find best score
        best_score = min(score for score, _ in candidates)

        # Prune candidates worse than threshold
        pruned = [(score, path) for score, path in candidates
                  if score &lt;= best_score * pruning_threshold]

        # Keep top beam_width from pruned candidates
        beam = heapq.nsmallest(beam_width, pruned, key=lambda x: x[0])

    return min(beam, key=lambda x: x[0])[1] if beam else []
</code></pre>
<h3 id="practical-applications"><a class="header" href="#practical-applications">Practical Applications</a></h3>
<h4 id="sequence-generation-nlp"><a class="header" href="#sequence-generation-nlp">Sequence Generation (NLP)</a></h4>
<pre><code class="language-python">def beam_search_sequence_generation(
    model,
    start_token: str,
    end_token: str,
    vocab: List[str],
    beam_width: int = 5,
    max_length: int = 50
) -&gt; List[str]:
    """
    Beam search for sequence generation in NLP.
    Commonly used in machine translation, text generation, etc.
    """
    # Each candidate: (log_prob, sequence)
    beam = [(0.0, [start_token])]

    for _ in range(max_length):
        candidates = []

        for log_prob, sequence in beam:
            # If sequence ended, keep it as is
            if sequence[-1] == end_token:
                candidates.append((log_prob, sequence))
                continue

            # Get probability distribution for next token
            probs = model.predict_next(sequence)  # Returns dict {token: prob}

            # Expand with each possible next token
            for token, prob in probs.items():
                new_sequence = sequence + [token]
                # Use log probabilities to avoid numerical underflow
                new_log_prob = log_prob + math.log(prob + 1e-10)
                candidates.append((new_log_prob, new_sequence))

        # Keep top beam_width candidates
        beam = heapq.nlargest(beam_width, candidates, key=lambda x: x[0])

        # Check if all beams ended
        if all(seq[-1] == end_token for _, seq in beam):
            break

    # Return best sequence
    return max(beam, key=lambda x: x[0])[1]


# Example usage with simple n-gram model
class SimpleNGramModel:
    def __init__(self):
        # Simplified model for demonstration
        self.vocab = ["the", "cat", "sat", "on", "mat", "&lt;END&gt;"]

    def predict_next(self, sequence):
        """Returns probability distribution over next tokens."""
        last_word = sequence[-1]
        # Simplified probabilities based on last word
        if last_word == "the":
            return {"cat": 0.7, "mat": 0.2, "sat": 0.1}
        elif last_word == "cat":
            return {"sat": 0.8, "on": 0.2}
        elif last_word == "sat":
            return {"on": 0.9, "&lt;END&gt;": 0.1}
        elif last_word == "on":
            return {"the": 0.7, "mat": 0.3}
        elif last_word == "mat":
            return {"&lt;END&gt;": 1.0}
        return {"&lt;END&gt;": 1.0}

# Usage
model = SimpleNGramModel()
result = beam_search_sequence_generation(
    model,
    start_token="&lt;START&gt;",
    end_token="&lt;END&gt;",
    vocab=model.vocab,
    beam_width=3
)
</code></pre>
<p><strong>When to use</strong>:</p>
<ul>
<li>Large search spaces where complete search is impossible</li>
<li>NLP tasks: machine translation, text generation, speech recognition</li>
<li>When memory is constrained (vs. keeping all possibilities)</li>
<li>Problems where good approximate solutions are acceptable</li>
<li>Sequence generation with probabilistic models</li>
</ul>
<p><strong>Pros</strong>:</p>
<ul>
<li>Memory efficient compared to breadth-first search</li>
<li>Often finds good solutions quickly</li>
<li>Configurable trade-off between speed and quality (beam width)</li>
<li>Works well with neural networks and probabilistic models</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Not complete (may miss optimal solution)</li>
<li>Not optimal (no guarantee of best solution)</li>
<li>Sensitive to beam width parameter</li>
<li>Can get stuck in local optima</li>
<li>May suffer from lack of diversity</li>
</ul>
<h3 id="beam-width-selection-guidelines"><a class="header" href="#beam-width-selection-guidelines">Beam Width Selection Guidelines</a></h3>
<pre><code class="language-python">def adaptive_beam_width(depth: int, base_width: int = 3, max_width: int = 10) -&gt; int:
    """
    Dynamically adjust beam width based on search depth.
    Increase width at deeper levels to improve exploration.
    """
    return min(base_width + depth // 10, max_width)

# Empirical guidelines:
# - Small problems (&lt; 100 states): beam_width = 2-5
# - Medium problems: beam_width = 5-20
# - Large problems (NLP): beam_width = 10-100
# - Trade-off: Larger width = better quality but slower
</code></pre>
<h2 id="a-search"><a class="header" href="#a-search">A* Search</a></h2>
<p><strong>Time</strong>: $O(b^d)$ worst case | <strong>Space</strong>: $O(b^d)$ | <strong>Use Case</strong>: Pathfinding, puzzle solving</p>
<p>A* is an informed search algorithm that finds the optimal path using both actual cost $g(n)$ and heuristic estimate $h(n)$. With an admissible heuristic, A* is guaranteed to find the optimal solution.</p>
<h3 id="core-implementation-1"><a class="header" href="#core-implementation-1">Core Implementation</a></h3>
<pre><code class="language-python">import heapq
from typing import Dict, List, Tuple, Callable

def a_star_search(
    start,
    goal,
    get_neighbors: Callable,
    heuristic: Callable,
    cost_function: Callable = lambda x, y: 1
) -&gt; Tuple[List, float]:
    """
    A* search algorithm.

    Args:
        start: Starting state
        goal: Goal state
        get_neighbors: Function returning neighbors of a state
        heuristic: Admissible heuristic function h(state)
        cost_function: Cost between two adjacent states

    Returns:
        Tuple of (path, total_cost)
    """
    # Priority queue: (f_score, state, path, g_score)
    frontier = [(heuristic(start), start, [start], 0)]
    explored = set()

    # Best g_score for each state
    g_scores = {start: 0}

    while frontier:
        f_score, current, path, g_score = heapq.heappop(frontier)

        if current == goal:
            return path, g_score

        if current in explored:
            continue

        explored.add(current)

        for neighbor in get_neighbors(current):
            if neighbor in explored:
                continue

            # Calculate tentative g_score
            tentative_g = g_score + cost_function(current, neighbor)

            # Skip if we've found a better path to neighbor
            if neighbor in g_scores and tentative_g &gt;= g_scores[neighbor]:
                continue

            # This is the best path to neighbor so far
            g_scores[neighbor] = tentative_g
            h_score = heuristic(neighbor)
            f_score = tentative_g + h_score

            new_path = path + [neighbor]
            heapq.heappush(frontier, (f_score, neighbor, new_path, tentative_g))

    return [], float('inf')  # No path found


# Example: Grid pathfinding with obstacles
def grid_a_star(grid: List[List[int]], start: Tuple, goal: Tuple):
    """A* for grid pathfinding."""

    def get_neighbors(pos):
        x, y = pos
        neighbors = []
        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
            nx, ny = x + dx, y + dy
            if (0 &lt;= nx &lt; len(grid) and
                0 &lt;= ny &lt; len(grid[0]) and
                grid[nx][ny] == 0):  # 0 = walkable
                neighbors.append((nx, ny))
        return neighbors

    def heuristic(pos):
        # Manhattan distance
        return abs(pos[0] - goal[0]) + abs(pos[1] - goal[1])

    return a_star_search(start, goal, get_neighbors, heuristic)
</code></pre>
<h3 id="common-heuristics"><a class="header" href="#common-heuristics">Common Heuristics</a></h3>
<pre><code class="language-python"># Manhattan distance (4-directional movement)
def manhattan_distance(pos1, pos2):
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

# Euclidean distance (any direction)
def euclidean_distance(pos1, pos2):
    return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

# Chebyshev distance (8-directional movement)
def chebyshev_distance(pos1, pos2):
    return max(abs(pos1[0] - pos2[0]), abs(pos1[1] - pos2[1]))

# Diagonal distance (8-directional with different costs)
def diagonal_distance(pos1, pos2, D=1, D2=1.414):
    dx = abs(pos1[0] - pos2[0])
    dy = abs(pos1[1] - pos2[1])
    return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)
</code></pre>
<p><strong>When to use</strong>:</p>
<ul>
<li>Need optimal path with performance better than Dijkstra</li>
<li>Have good admissible heuristic</li>
<li>Complete search is required</li>
<li>Memory is available</li>
</ul>
<p><strong>Pros</strong>:</p>
<ul>
<li>Optimal (with admissible heuristic)</li>
<li>Complete</li>
<li>Faster than Dijkstra with good heuristic</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>High memory usage</li>
<li>Requires admissible heuristic for optimality</li>
<li>Can be slow for large state spaces</li>
</ul>
<h2 id="greedy-best-first-search"><a class="header" href="#greedy-best-first-search">Greedy Best-First Search</a></h2>
<p><strong>Time</strong>: $O(b^m)$ | <strong>Space</strong>: $O(b^m)$ | <strong>Use Case</strong>: Fast approximate solutions</p>
<p>Greedy best-first search expands nodes with the best heuristic value, ignoring path cost. It’s fast but not optimal or complete.</p>
<pre><code class="language-python">def greedy_best_first_search(
    start,
    goal,
    get_neighbors: Callable,
    heuristic: Callable
) -&gt; List:
    """
    Greedy best-first search using only heuristic function.
    Fast but not guaranteed to find optimal solution.
    """
    # Priority queue: (h_score, state, path)
    frontier = [(heuristic(start), start, [start])]
    explored = set()

    while frontier:
        h_score, current, path = heapq.heappop(frontier)

        if current == goal:
            return path

        if current in explored:
            continue

        explored.add(current)

        for neighbor in get_neighbors(current):
            if neighbor not in explored:
                new_path = path + [neighbor]
                heapq.heappush(frontier,
                              (heuristic(neighbor), neighbor, new_path))

    return []  # No path found
</code></pre>
<p><strong>When to use</strong>: Speed matters more than optimality, good heuristic available</p>
<p><strong>Pros</strong>: Fast, simple, low memory
<strong>Cons</strong>: Not optimal, not complete, can get stuck</p>
<h2 id="ida-iterative-deepening-a"><a class="header" href="#ida-iterative-deepening-a">IDA* (Iterative Deepening A*)</a></h2>
<p><strong>Time</strong>: $O(b^d)$ | <strong>Space</strong>: $O(d)$ | <strong>Use Case</strong>: Memory-constrained optimal search</p>
<p>IDA* combines benefits of A* (optimality) with iterative deepening (low memory).</p>
<pre><code class="language-python">def ida_star_search(
    start,
    goal,
    get_neighbors: Callable,
    heuristic: Callable,
    cost_function: Callable = lambda x, y: 1
) -&gt; Tuple[List, float]:
    """
    Iterative Deepening A* - memory-efficient optimal search.
    """

    def search(path, g_cost, threshold):
        """Recursive DFS with f-cost threshold."""
        current = path[-1]
        f_cost = g_cost + heuristic(current)

        if f_cost &gt; threshold:
            return f_cost, []

        if current == goal:
            return 0, path

        min_threshold = float('inf')

        for neighbor in get_neighbors(current):
            if neighbor not in path:  # Avoid cycles
                new_cost = g_cost + cost_function(current, neighbor)
                new_path = path + [neighbor]

                result_threshold, result_path = search(new_path, new_cost, threshold)

                if result_path:  # Found goal
                    return result_threshold, result_path

                min_threshold = min(min_threshold, result_threshold)

        return min_threshold, []

    # Start with heuristic value as threshold
    threshold = heuristic(start)

    while threshold &lt; float('inf'):
        threshold, path = search([start], 0, threshold)
        if path:
            # Calculate total cost
            total_cost = 0
            for i in range(len(path) - 1):
                total_cost += cost_function(path[i], path[i+1])
            return path, total_cost

    return [], float('inf')
</code></pre>
<p><strong>When to use</strong>: Need optimal solution with limited memory</p>
<p><strong>Pros</strong>: Optimal, complete, low memory
<strong>Cons</strong>: Can revisit states, slower than A*</p>
<h2 id="hill-climbing"><a class="header" href="#hill-climbing">Hill Climbing</a></h2>
<p><strong>Time</strong>: $O(n \cdot m)$ where $n$ = iterations, $m$ = neighbors | <strong>Space</strong>: $O(1)$ | <strong>Use Case</strong>: Local optimization</p>
<p>Hill climbing is a local search algorithm that continually moves toward increasing value (or decreasing cost).</p>
<pre><code class="language-python">def hill_climbing(
    initial_state,
    get_neighbors: Callable,
    evaluate: Callable,  # Higher is better
    max_iterations: int = 1000
):
    """
    Simple hill climbing - moves to best neighbor.
    Can get stuck in local maxima.
    """
    current = initial_state
    current_value = evaluate(current)

    for _ in range(max_iterations):
        neighbors = get_neighbors(current)

        if not neighbors:
            break

        # Find best neighbor
        best_neighbor = max(neighbors, key=evaluate)
        best_value = evaluate(best_neighbor)

        # If no improvement, stop (local maximum reached)
        if best_value &lt;= current_value:
            break

        current = best_neighbor
        current_value = best_value

    return current, current_value


def stochastic_hill_climbing(
    initial_state,
    get_neighbors: Callable,
    evaluate: Callable,
    max_iterations: int = 1000
):
    """
    Stochastic hill climbing - randomly selects uphill move.
    Can escape some local maxima.
    """
    current = initial_state
    current_value = evaluate(current)

    for _ in range(max_iterations):
        neighbors = get_neighbors(current)

        # Filter neighbors that improve the solution
        better_neighbors = [n for n in neighbors if evaluate(n) &gt; current_value]

        if not better_neighbors:
            break

        # Randomly select an improving neighbor
        current = random.choice(better_neighbors)
        current_value = evaluate(current)

    return current, current_value


def random_restart_hill_climbing(
    generate_random_state: Callable,
    get_neighbors: Callable,
    evaluate: Callable,
    num_restarts: int = 10,
    max_iterations: int = 1000
):
    """
    Hill climbing with random restarts to escape local maxima.
    """
    best_state = None
    best_value = float('-inf')

    for _ in range(num_restarts):
        initial = generate_random_state()
        state, value = hill_climbing(initial, get_neighbors, evaluate, max_iterations)

        if value &gt; best_value:
            best_state = state
            best_value = value

    return best_state, best_value
</code></pre>
<p><strong>When to use</strong>: Local optimization, continuous search spaces, quick approximate solutions</p>
<p><strong>Pros</strong>: Simple, fast, low memory
<strong>Cons</strong>: Gets stuck in local maxima, not complete, not optimal</p>
<h2 id="simulated-annealing"><a class="header" href="#simulated-annealing">Simulated Annealing</a></h2>
<p><strong>Time</strong>: $O(n \cdot m)$ | <strong>Space</strong>: $O(1)$ | <strong>Use Case</strong>: Global optimization with acceptance of worse moves</p>
<p>Simulated annealing allows occasional moves to worse states to escape local optima, with probability decreasing over time.</p>
<pre><code class="language-python">import math
import random

def simulated_annealing(
    initial_state,
    get_neighbor: Callable,  # Generate one random neighbor
    evaluate: Callable,  # Lower is better (cost function)
    initial_temp: float = 100.0,
    cooling_rate: float = 0.95,
    min_temp: float = 0.01,
    max_iterations: int = 10000
):
    """
    Simulated annealing for optimization.
    Accepts worse solutions with probability that decreases over time.

    Args:
        initial_temp: Starting temperature
        cooling_rate: Temperature multiplier each iteration (0 &lt; rate &lt; 1)
        min_temp: Stop when temperature reaches this value
    """
    current = initial_state
    current_cost = evaluate(current)
    best = current
    best_cost = current_cost

    temp = initial_temp
    iteration = 0

    while temp &gt; min_temp and iteration &lt; max_iterations:
        # Generate random neighbor
        neighbor = get_neighbor(current)
        neighbor_cost = evaluate(neighbor)

        # Calculate cost difference
        delta = neighbor_cost - current_cost

        # Accept if better, or with probability based on temperature
        if delta &lt; 0 or random.random() &lt; math.exp(-delta / temp):
            current = neighbor
            current_cost = neighbor_cost

            # Update best solution found
            if current_cost &lt; best_cost:
                best = current
                best_cost = current_cost

        # Cool down
        temp *= cooling_rate
        iteration += 1

    return best, best_cost


# Example: Traveling Salesman Problem
def tsp_simulated_annealing(cities, distances):
    """
    Solve TSP using simulated annealing.
    cities: List of city indices
    distances: 2D matrix of distances
    """
    def evaluate(route):
        """Calculate total distance of route."""
        total = 0
        for i in range(len(route)):
            total += distances[route[i]][route[(i+1) % len(route)]]
        return total

    def get_neighbor(route):
        """Generate neighbor by swapping two cities."""
        neighbor = route[:]
        i, j = random.sample(range(len(route)), 2)
        neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
        return neighbor

    initial_route = list(range(len(cities)))
    random.shuffle(initial_route)

    return simulated_annealing(
        initial_route,
        get_neighbor,
        evaluate,
        initial_temp=1000.0,
        cooling_rate=0.995,
        min_temp=1.0
    )
</code></pre>
<p><strong>When to use</strong>: Combinatorial optimization, avoiding local optima, when near-optimal solutions are acceptable</p>
<p><strong>Pros</strong>: Can escape local optima, probabilistically complete, simple to implement
<strong>Cons</strong>: Sensitive to parameters, no guarantee of optimality, slower than greedy methods</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Algorithm</th><th>Time</th><th>Space</th><th>Optimal</th><th>Complete</th><th>Memory Use</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td>Beam Search</td><td>$O(w \cdot b \cdot d)$</td><td>$O(w \cdot d)$</td><td>❌</td><td>❌</td><td>Low</td><td>NLP, constrained search</td></tr>
<tr><td>A*</td><td>$O(b^d)$</td><td>$O(b^d)$</td><td>✅*</td><td>✅*</td><td>High</td><td>Optimal pathfinding</td></tr>
<tr><td>Greedy Best-First</td><td>$O(b^m)$</td><td>$O(b^m)$</td><td>❌</td><td>❌</td><td>Medium</td><td>Fast approximate paths</td></tr>
<tr><td>IDA*</td><td>$O(b^d)$</td><td>$O(d)$</td><td>✅*</td><td>✅*</td><td>Very Low</td><td>Memory-constrained optimal</td></tr>
<tr><td>Hill Climbing</td><td>$O(n \cdot m)$</td><td>$O(1)$</td><td>❌</td><td>❌</td><td>Minimal</td><td>Local optimization</td></tr>
<tr><td>Simulated Annealing</td><td>$O(n \cdot m)$</td><td>$O(1)$</td><td>❌</td><td>~✅</td><td>Minimal</td><td>Global optimization</td></tr>
</tbody>
</table>
</div>
<p>* With admissible heuristic and finite branching factor</p>
<p><strong>Legend:</strong></p>
<ul>
<li>$w$ = beam width, $b$ = branching factor, $d$ = depth, $m$ = maximum depth, $n$ = iterations</li>
</ul>
<h2 id="decision-tree"><a class="header" href="#decision-tree">Decision Tree</a></h2>
<pre><code>What's your primary constraint?
├─ Memory → Is optimal solution required?
│   ├─ Yes → IDA*
│   └─ No → Beam Search or Hill Climbing
├─ Time (need fast solution) → Is optimality important?
│   ├─ Yes → A* with good heuristic
│   └─ No → Greedy Best-First or Beam Search
├─ Solution Quality → Need guaranteed optimal?
│   ├─ Yes → A* (if memory allows) or IDA*
│   └─ No → Do you have discrete states or continuous?
│       ├─ Discrete → Beam Search
│       └─ Continuous → Simulated Annealing or Hill Climbing
└─ Problem Type?
    ├─ Sequence Generation (NLP) → Beam Search
    ├─ Pathfinding → A* or IDA*
    ├─ Combinatorial Optimization → Simulated Annealing
    └─ Local Optimization → Hill Climbing
</code></pre>
<h2 id="common-patterns-and-applications"><a class="header" href="#common-patterns-and-applications">Common Patterns and Applications</a></h2>
<h3 id="pattern-early-stopping"><a class="header" href="#pattern-early-stopping">Pattern: Early Stopping</a></h3>
<pre><code class="language-python">def beam_search_with_early_stopping(
    initial_state,
    goal_test: Callable,
    get_neighbors: Callable,
    heuristic: Callable,
    beam_width: int = 3,
    patience: int = 5,  # Stop if no improvement for N iterations
    max_depth: int = 100
) -&gt; List:
    """Beam search with early stopping when no improvement."""
    beam = [(heuristic(initial_state), [initial_state])]
    best_score = float('inf')
    no_improvement_count = 0

    for depth in range(max_depth):
        for score, path in beam:
            if goal_test(path[-1]):
                return path

        current_best = min(score for score, _ in beam)

        if current_best &lt; best_score:
            best_score = current_best
            no_improvement_count = 0
        else:
            no_improvement_count += 1
            if no_improvement_count &gt;= patience:
                # No improvement, return best found
                return min(beam, key=lambda x: x[0])[1]

        # Standard beam search expansion...
        candidates = []
        for score, path in beam:
            for next_state, _ in get_neighbors(path[-1]):
                if next_state not in path:
                    new_path = path + [next_state]
                    candidates.append((heuristic(next_state), new_path))

        if not candidates:
            break

        beam = heapq.nsmallest(beam_width, candidates, key=lambda x: x[0])

    return min(beam, key=lambda x: x[0])[1] if beam else []
</code></pre>
<h3 id="real-world-applications"><a class="header" href="#real-world-applications">Real-World Applications</a></h3>
<p><strong>1. Neural Machine Translation</strong></p>
<pre><code class="language-python"># Beam search for translating sentences
def translate_with_beam_search(source_sentence, model, beam_width=5):
    """
    Translate using beam search over decoder outputs.
    model: Neural translation model
    """
    # Encode source
    encoder_output = model.encode(source_sentence)

    # Beam search through decoder
    beam = [(0.0, ["&lt;START&gt;"])]

    for step in range(model.max_length):
        candidates = []

        for log_prob, sequence in beam:
            if sequence[-1] == "&lt;END&gt;":
                candidates.append((log_prob, sequence))
                continue

            # Get next word probabilities from decoder
            decoder_output = model.decode(sequence, encoder_output)

            for word, prob in decoder_output.items():
                new_seq = sequence + [word]
                new_log_prob = log_prob + math.log(prob + 1e-10)
                candidates.append((new_log_prob, new_seq))

        beam = heapq.nlargest(beam_width, candidates, key=lambda x: x[0])

        if all(seq[-1] == "&lt;END&gt;" for _, seq in beam):
            break

    return max(beam, key=lambda x: x[0])[1]
</code></pre>
<p><strong>2. Game AI - Pathfinding</strong></p>
<pre><code class="language-python"># A* for game character navigation
def game_pathfinding(game_map, character_pos, target_pos, character_abilities):
    """
    Find path considering character abilities (jumping, swimming, etc.)
    """
    def get_neighbors(pos):
        neighbors = []
        x, y = pos

        # Normal movement
        for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:
            new_pos = (x+dx, y+dy)
            if is_walkable(game_map, new_pos, character_abilities):
                neighbors.append(new_pos)

        # Special moves (jumping over obstacles, etc.)
        if character_abilities.can_jump:
            for dx, dy in [(0,2), (2,0), (0,-2), (-2,0)]:
                new_pos = (x+dx, y+dy)
                if is_valid_jump(game_map, pos, new_pos):
                    neighbors.append(new_pos)

        return neighbors

    def heuristic(pos):
        return manhattan_distance(pos, target_pos)

    path, cost = a_star_search(character_pos, target_pos, get_neighbors, heuristic)
    return path
</code></pre>
<p><strong>3. Resource Allocation</strong></p>
<pre><code class="language-python"># Simulated annealing for resource allocation
def optimize_resource_allocation(resources, demands, constraints):
    """
    Optimize allocation of limited resources to maximize satisfaction.
    """
    def evaluate(allocation):
        """Calculate satisfaction score (higher is better)."""
        satisfaction = 0
        for i, alloc in enumerate(allocation):
            satisfaction += utility_function(demands[i], alloc)

        # Penalize constraint violations
        if sum(allocation) &gt; resources:
            satisfaction -= 1000 * (sum(allocation) - resources)

        return -satisfaction  # Negate for minimization

    def get_neighbor(allocation):
        """Randomly adjust allocation."""
        neighbor = allocation[:]
        i, j = random.sample(range(len(allocation)), 2)
        transfer = random.uniform(0, neighbor[i])
        neighbor[i] -= transfer
        neighbor[j] += transfer
        return neighbor

    # Initial uniform allocation
    initial = [resources / len(demands)] * len(demands)

    best_allocation, _ = simulated_annealing(
        initial, get_neighbor, evaluate,
        initial_temp=100, cooling_rate=0.99
    )

    return best_allocation
</code></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Beam Search</strong>: Memory-efficient but incomplete - ideal for NLP and constrained search spaces</li>
<li><strong>A</strong>*: Optimal and complete with good heuristic - best for pathfinding when memory allows</li>
<li><strong>IDA</strong>*: Optimal with minimal memory - use when memory is critically constrained</li>
<li><strong>Greedy Best-First</strong>: Fastest but least reliable - quick approximate solutions only</li>
<li><strong>Hill Climbing</strong>: Simple local search - good for continuous optimization</li>
<li><strong>Simulated Annealing</strong>: Better global search - escapes local optima with probability</li>
</ol>
<p><strong>Critical Parameters:</strong></p>
<ul>
<li><strong>Beam Width</strong>: Larger = better quality but slower and more memory</li>
<li><strong>Heuristic Quality</strong>: Better heuristic = faster search and better results</li>
<li><strong>Temperature Schedule</strong>: Controls exploration vs. exploitation in simulated annealing</li>
</ul>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li><strong>Heuristic Design</strong>: Ensure heuristic is admissible for A*/IDA* optimality</li>
<li><strong>Beam Width Tuning</strong>: Start with width = 3-5, increase if quality insufficient</li>
<li><strong>Diversity</strong>: Use diverse beam search when beam candidates are too similar</li>
<li><strong>Early Stopping</strong>: Monitor improvement and stop when convergence detected</li>
<li><strong>Hybrid Approaches</strong>: Combine methods (e.g., beam search with A* heuristic)</li>
<li><strong>State Caching</strong>: Cache computed states to avoid redundant evaluations</li>
<li><strong>Pruning</strong>: Remove clearly suboptimal candidates early</li>
</ol>
<pre><code class="language-python"># Example: Combining beam search with A* evaluation
def hybrid_beam_a_star(initial, goal, neighbors, heuristic, beam_width=5):
    """Use A* evaluation (g + h) in beam search."""
    beam = [(heuristic(initial), 0, [initial])]

    for depth in range(100):
        candidates = []
        for f_score, g_score, path in beam:
            if path[-1] == goal:
                return path

            for next_state, cost in neighbors(path[-1]):
                if next_state not in path:
                    new_g = g_score + cost
                    new_h = heuristic(next_state)
                    new_f = new_g + new_h
                    candidates.append((new_f, new_g, path + [next_state]))

        if not candidates:
            break

        beam = heapq.nsmallest(beam_width, candidates, key=lambda x: x[0])

    return []
</code></pre>
<h2 id="eli10"><a class="header" href="#eli10">ELI10</a></h2>
<p>Imagine you’re trying to find the best path through a maze:</p>
<ul>
<li>
<p><strong>Beam Search</strong>: You can only remember your 3 favorite paths. At each step, you try extending each path and keep only the 3 best new paths. Fast but might miss the perfect path!</p>
</li>
<li>
<p><strong>A* Search</strong>: You remember all paths and always extend the one that seems best (considering both how far you’ve gone and how far is left). Finds the perfect path but remembers everything!</p>
</li>
<li>
<p><strong>Greedy Best-First</strong>: Always go toward the goal, ignoring how far you’ve walked. Fast but can walk into dead ends!</p>
</li>
<li>
<p><strong>Hill Climbing</strong>: Always walk uphill. Great if you’re on the right mountain, but you might be climbing a small hill while the big mountain is next door!</p>
</li>
<li>
<p><strong>Simulated Annealing</strong>: Like hill climbing, but sometimes you randomly walk downhill to explore. You do this less over time until you only walk uphill. Finds bigger mountains!</p>
</li>
</ul>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<ul>
<li><a href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html">A* Pathfinding for Beginners</a></li>
<li><a href="https://towardsdatascience.com/foundations-of-nlp-explained-visually-beam-search-how-it-works-1586b9849a24">Beam Search Explained</a></li>
<li><a href="https://stanford-cs221.github.io/autumn2019/modules/">Heuristic Search - Stanford CS221</a></li>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Red Blob Games - Pathfinding</a></li>
<li><a href="https://towardsdatascience.com/optimization-techniques-simulated-annealing-d6a4785a1de7">Simulated Annealing Tutorial</a></li>
<li><a href="https://leetcode.com/tag/heuristic/">LeetCode Heuristic Search Problems</a></li>
</ul>
<h3 id="related-algorithm-files"><a class="header" href="#related-algorithm-files">Related Algorithm Files</a></h3>
<ul>
<li>See <code>graph_algorithms.md</code> for BFS, DFS, Dijkstra</li>
<li>See <code>dynamic_programming.md</code> for optimal substructure problems</li>
<li>See <code>greedy_algorithms.md</code> for greedy strategies</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../algorithms/union_find.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../security/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../algorithms/union_find.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../security/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
