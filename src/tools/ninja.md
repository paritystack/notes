# Ninja

Ninja is a small, fast build system designed for speed. It differs from other build systems by being designed to have its input files generated by higher-level build systems, and is optimized for build performance.

## Overview

Ninja was created to replace Make in the Chromium project. Unlike Make, Ninja is designed to be simple and fast, sacrificing features for speed. It's typically used as a backend for meta-build systems like CMake, Meson, and GN.

**Key Concepts:**
- **build.ninja**: The build manifest file
- **Rule**: Defines how to transform inputs to outputs
- **Build Statement**: Applies a rule to specific files
- **Edge**: A build statement in the dependency graph
- **Pool**: Limits parallel execution of specific rules
- **Generator**: Special rules that update build.ninja itself

**Why Ninja:**
- **Speed**: Minimal overhead, optimized for fast builds
- **Simplicity**: Simple syntax, designed for machine generation
- **Parallel**: Efficient parallel execution by default
- **Incremental**: Smart dependency tracking for minimal rebuilds

## Installation

```bash
# Ubuntu/Debian
sudo apt-get install ninja-build

# macOS
brew install ninja

# From source
git clone https://github.com/ninja-build/ninja.git
cd ninja
./configure.py --bootstrap
sudo cp ninja /usr/local/bin/

# Verify installation
ninja --version
```

## Basic Usage

### Running Ninja

```bash
# Build all targets (default)
ninja

# Build specific target
ninja myprogram

# Build multiple targets
ninja target1 target2

# Show what would be built
ninja -n
ninja --dry-run

# Verbose output (show commands)
ninja -v

# Show all targets
ninja -t targets

# Show all rules
ninja -t rules
```

### Common Options

```bash
# Parallel builds (default: CPU cores)
ninja -j 8

# Keep going on errors
ninja -k 0
ninja -k 10  # Stop after 10 errors

# Clean build outputs
ninja -t clean

# Clean specific target
ninja -t clean target_name

# Show dependency graph
ninja -t graph | dot -Tpng -o graph.png

# Show commands for target
ninja -t commands target_name

# Explain why target needs rebuild
ninja -d explain -v target_name
```

## build.ninja Syntax

### Basic Structure

```ninja
# Comments start with #

# Variable definition
cc = gcc
cflags = -Wall -O2

# Rule definition
rule compile
  command = $cc $cflags -c $in -o $out
  description = Compiling $in

# Build statement
build main.o: compile main.c

# Default target
default main.o
```

### Variables

```ninja
# Simple variable
builddir = build
cc = gcc
cflags = -Wall

# Variable expansion
cflags = $cflags -O2

# Variables in rules use $ prefix
rule compile
  command = $cc $cflags -c $in -o $out

# Build-level variables (local scope)
build main.o: compile main.c
  cflags = -g -O0

# Reference variables
cxx = g++
compiler = $cxx
```

### Built-in Variables

```ninja
# Available in rules and build statements:
# $in - List of input files
# $out - Output file
# $in_newline - Inputs separated by newlines
# $out_newline - Outputs separated by newlines

rule link
  command = gcc $in -o $out
  description = Linking $out

# In build statements only:
build program: link main.o utils.o
  # Implicit inputs available
```

### Rules

```ninja
# Basic rule
rule compile
  command = gcc -c $in -o $out

# Rule with description (shown during build)
rule compile
  command = gcc -c $in -o $out
  description = Compiling $out

# Rule with dependency file
rule compile
  command = gcc -MMD -MF $out.d -c $in -o $out
  description = CC $out
  depfile = $out.d
  deps = gcc

# Rule with response file (for long command lines)
rule link
  command = gcc @$out.rsp -o $out
  rspfile = $out.rsp
  rspfile_content = $in
  description = Linking $out

# Rule with pool (limit parallelism)
rule heavy_compile
  command = gcc -c $in -o $out
  pool = heavy_pool
```

### Build Statements

```ninja
# Basic build
build output: rule input

# Multiple inputs
build program: link main.o utils.o helper.o

# Multiple outputs
build main.o main.d: compile main.c

# Implicit inputs (dependencies not on command line)
build program: link main.o | libs/libutils.a
  # libs/libutils.a is implicit dependency

# Order-only dependencies (must exist, but don't trigger rebuild)
build program: link main.o || create_output_dir
  # create_output_dir runs first, but changes don't rebuild

# Implicit outputs (not primary output)
build main.o | main.d: compile main.c
```

### Phony Rules

```ninja
# Phony targets (like Make's .PHONY)
build all: phony program tests

build clean: phony
  command = rm -rf build/*

# Convenient aliases
build test: phony tests/test_runner
build install: phony /usr/local/bin/program
```

### Include and Subninja

```ninja
# Include another build file (same scope)
include config.ninja
include rules.ninja

# Subninja (separate scope)
subninja src/build.ninja
subninja tests/build.ninja
```

## Dependency Types

### Explicit Dependencies

```ninja
# Normal dependencies
build program: link main.o utils.o
  # Changes to main.o or utils.o trigger rebuild

build main.o: compile main.c
  # Changes to main.c trigger rebuild
```

### Implicit Dependencies

```ninja
# Implicit dependencies (after |)
build program: link main.o | static_lib.a
  # static_lib.a must exist but doesn't appear in command
  # Changes still trigger rebuild

# Common use: header dependencies via depfile
rule compile
  command = gcc -MMD -MF $out.d -c $in -o $out
  depfile = $out.d
  deps = gcc

build main.o: compile main.c
  # Header dependencies read from main.o.d
```

### Order-Only Dependencies

```ninja
# Order-only dependencies (after ||)
build program: link main.o || output_directory
  # output_directory must exist before building
  # Changes to output_directory don't trigger rebuild

rule create_dir
  command = mkdir -p $out

build build/obj:
  command = mkdir -p build/obj

build build/obj/main.o: compile main.c || build/obj
```

## C/C++ Project Examples

### Simple C Project

```ninja
# Variables
cc = gcc
cflags = -Wall -Wextra -O2

# Compile rule
rule compile
  command = $cc $cflags -c $in -o $out
  description = Compiling $out

# Link rule
rule link
  command = $cc -o $out $in
  description = Linking $out

# Build objects
build main.o: compile main.c
build utils.o: compile utils.c
build parser.o: compile parser.c

# Link program
build program: link main.o utils.o parser.o

# Default target
default program

# Clean target
rule clean
  command = rm -f *.o program
  description = Cleaning

build clean: phony
```

### C Project with Header Dependencies

```ninja
cc = gcc
cflags = -Wall -Wextra -O2 -Iinclude

# Compile with automatic header dependencies
rule compile
  command = $cc -MMD -MF $out.d $cflags -c $in -o $out
  description = CC $out
  depfile = $out.d
  deps = gcc

rule link
  command = $cc -o $out $in
  description = LINK $out

# Build objects
build obj/main.o: compile src/main.c
build obj/utils.o: compile src/utils.c
build obj/parser.o: compile src/parser.c

# Link program
build bin/program: link obj/main.o obj/utils.o obj/parser.o

default bin/program
```

### C++ Project with Directories

```ninja
cxx = g++
cxxflags = -std=c++17 -Wall -Wextra -O2 -Iinclude
ldflags = -lpthread -lm

builddir = build
srcdir = src
objdir = $builddir/obj
bindir = $builddir/bin

rule compile
  command = $cxx -MMD -MF $out.d $cxxflags -c $in -o $out
  description = CXX $out
  depfile = $out.d
  deps = gcc

rule link
  command = $cxx -o $out $in $ldflags
  description = LINK $out

rule mkdir
  command = mkdir -p $out
  description = MKDIR $out

# Create directories
build $objdir: mkdir
build $bindir: mkdir

# Compile sources
build $objdir/main.o: compile $srcdir/main.cpp || $objdir
build $objdir/utils.o: compile $srcdir/utils.cpp || $objdir
build $objdir/parser.o: compile $srcdir/parser.cpp || $objdir

# Link program
build $bindir/program: link $objdir/main.o $objdir/utils.o $objdir/parser.o || $bindir

default $bindir/program
```

### Multi-target Project

```ninja
cc = gcc
cflags = -Wall -Wextra -O2

rule compile
  command = $cc $cflags -c $in -o $out
  description = CC $out

rule link
  command = $cc -o $out $in $ldflags
  description = LINK $out

# Shared objects
build network.o: compile network.c
build utils.o: compile utils.c

# Server program
build server.o: compile server.c
build server: link server.o network.o utils.o

# Client program
build client.o: compile client.c
build client: link client.o network.o

# Build all
build all: phony server client

default all
```

### Static Library

```ninja
cc = gcc
ar = ar
cflags = -Wall -Wextra -O2

rule compile
  command = $cc $cflags -c $in -o $out
  description = CC $out

rule archive
  command = rm -f $out && $ar rcs $out $in
  description = AR $out

# Library sources
build lib1.o: compile lib1.c
build lib2.o: compile lib2.c
build lib3.o: compile lib3.c

# Create static library
build libmylib.a: archive lib1.o lib2.o lib3.o

default libmylib.a
```

### Shared Library

```ninja
cc = gcc
cflags = -Wall -Wextra -O2 -fPIC
ldflags = -shared

rule compile
  command = $cc $cflags -c $in -o $out
  description = CC $out

rule link_shared
  command = $cc $ldflags -o $out $in
  description = LINK $out

# Library sources
build lib1.o: compile lib1.c
build lib2.o: compile lib2.c
build lib3.o: compile lib3.c

# Create shared library
build libmylib.so: link_shared lib1.o lib2.o lib3.o

default libmylib.so
```

## Build System Integration

### CMake + Ninja

```bash
# Generate Ninja build files with CMake
cmake -G Ninja -B build
cmake --build build

# Or manually
cd build
ninja

# CMakeLists.txt example
cmake_minimum_required(VERSION 3.15)
project(MyProject)

add_executable(myapp main.cpp utils.cpp)
target_include_directories(myapp PRIVATE include)
target_compile_options(myapp PRIVATE -Wall -Wextra)
```

Generated build.ninja excerpt:
```ninja
rule CXX_COMPILER
  command = /usr/bin/c++ $DEFINES $INCLUDES $FLAGS -o $out -c $in
  description = Building CXX object $out

build CMakeFiles/myapp.dir/main.cpp.o: CXX_COMPILER main.cpp
build CMakeFiles/myapp.dir/utils.cpp.o: CXX_COMPILER utils.cpp

build myapp: CXX_EXECUTABLE_LINKER CMakeFiles/myapp.dir/main.cpp.o CMakeFiles/myapp.dir/utils.cpp.o
```

### Meson + Ninja

```bash
# Setup build with Meson
meson setup builddir
meson compile -C builddir

# Or use ninja directly
cd builddir
ninja

# meson.build example
project('myproject', 'cpp',
  version: '1.0.0',
  default_options: ['cpp_std=c++17'])

executable('myapp',
  sources: ['main.cpp', 'utils.cpp'],
  include_directories: include_directories('include'))
```

### GN (Generate Ninja)

```bash
# Generate Ninja files with GN
gn gen out/Release
ninja -C out/Release

# BUILD.gn example
executable("myapp") {
  sources = [
    "main.cc",
    "utils.cc",
  ]
  include_dirs = [ "include" ]
  cflags = [ "-Wall", "-Wextra" ]
}
```

### Manual build.ninja Generator

```python
#!/usr/bin/env python3
"""Generate build.ninja for a C project"""

import os
import glob

def generate_ninja():
    sources = glob.glob("src/*.c")
    objects = [f"obj/{os.path.basename(s).replace('.c', '.o')}" for s in sources]

    with open("build.ninja", "w") as f:
        # Variables
        f.write("cc = gcc\n")
        f.write("cflags = -Wall -Wextra -O2 -Iinclude\n\n")

        # Rules
        f.write("rule compile\n")
        f.write("  command = $cc -MMD -MF $out.d $cflags -c $in -o $out\n")
        f.write("  description = CC $out\n")
        f.write("  depfile = $out.d\n")
        f.write("  deps = gcc\n\n")

        f.write("rule link\n")
        f.write("  command = $cc -o $out $in\n")
        f.write("  description = LINK $out\n\n")

        # Build statements
        for src, obj in zip(sources, objects):
            f.write(f"build {obj}: compile {src}\n")

        f.write(f"\nbuild program: link {' '.join(objects)}\n")
        f.write("\ndefault program\n")

if __name__ == "__main__":
    generate_ninja()
```

## Advanced Features

### Build Pools

```ninja
# Limit parallelism for resource-intensive tasks
pool heavy_pool
  depth = 2

pool link_pool
  depth = 1

rule heavy_compile
  command = gcc -c $in -o $out
  pool = heavy_pool
  description = Heavy compilation $out

rule link
  command = gcc -o $out $in
  pool = link_pool
  description = Linking $out

build large.o: heavy_compile large.c
build program: link main.o utils.o large.o
```

### Console Pool

```ninja
# Special console pool for interactive commands
pool console
  depth = 1

rule test
  command = ./run_tests.sh
  pool = console
  description = Running tests

build test: test program
```

### Response Files

```ninja
# Use response files for long command lines
rule link
  command = gcc @$out.rsp -o $out
  rspfile = $out.rsp
  rspfile_content = $in $libs
  description = Linking $out

build program: link main.o utils.o parser.o foo.o bar.o baz.o
  libs = -lpthread -lm -ldl -lrt
```

### Generator Rules

```ninja
# Rules that regenerate build.ninja
rule configure
  command = ./configure.py
  generator = 1
  description = Regenerating build.ninja

build build.ninja: configure configure.py
```

### Restat

```ninja
# Don't rebuild dependents if output doesn't change
rule codegen
  command = ./generate.sh $in $out
  restat = 1
  description = Generating $out

build generated.c: codegen config.txt
build generated.o: compile generated.c
```

### Multiple Outputs

```ninja
# Rule producing multiple outputs
rule protoc
  command = protoc --cpp_out=. $in
  description = Generating protobuf code

# Both outputs from single invocation
build message.pb.cc message.pb.h: protoc message.proto
```

## Common Patterns

### Debug and Release Builds

```ninja
# build.debug.ninja
builddir = build/debug
cflags = -g -O0 -DDEBUG
include common.ninja

# build.release.ninja
builddir = build/release
cflags = -O2 -DNDEBUG
include common.ninja

# common.ninja
cc = gcc

rule compile
  command = $cc $cflags -c $in -o $out
  description = CC $out

build $builddir/main.o: compile src/main.c
build $builddir/program: link $builddir/main.o
```

Usage:
```bash
ninja -f build.debug.ninja
ninja -f build.release.ninja
```

### Conditional Compilation

```ninja
# Generated by configure script
# configure.py sets has_openmp based on detection

rule compile
  command = $cc $cflags $openmp_flag -c $in -o $out

build main.o: compile main.c
  openmp_flag = $openmp_cflags

# In configure.py:
# if has_openmp:
#     f.write("openmp_cflags = -fopenmp\n")
# else:
#     f.write("openmp_cflags = \n")
```

### Subdirectory Builds

```ninja
# Top-level build.ninja
subninja src/build.ninja
subninja tests/build.ninja
subninja lib/build.ninja

build all: phony src/program tests/test_runner lib/libmylib.a

default all

# src/build.ninja
builddir = ../build/src
rule compile
  command = gcc -c $in -o $out

build $builddir/main.o: compile main.c
build program: link $builddir/main.o
```

### Cross-Compilation

```ninja
# build.arm.ninja
cc = arm-linux-gnueabihf-gcc
cxx = arm-linux-gnueabihf-g++
ar = arm-linux-gnueabihf-ar
cflags = -Wall -O2 -march=armv7-a

rule compile
  command = $cc $cflags -c $in -o $out
  description = CC [ARM] $out

build arm/main.o: compile src/main.c
build arm/program: link arm/main.o
```

### Incremental Code Generation

```ninja
# Generate code only when input changes
rule generate
  command = python3 generate.py $in $out
  restat = 1
  description = Generating $out

rule compile
  command = gcc -c $in -o $out
  description = CC $out

build generated/api.c: generate specs/api.yaml
build generated/api.o: compile generated/api.c
```

## Performance Optimization

### Optimizing Build Speed

```bash
# Use all CPU cores
ninja -j $(nproc)

# Profile build time
ninja -d stats
ninja -d keeprsp  # Keep response files for debugging

# Find bottlenecks
time ninja -n  # Time the planning phase
time ninja -v  # Time with verbose output
```

### Dependency Optimization

```ninja
# Use depfiles for header dependencies
rule compile
  command = $cc -MMD -MF $out.d $cflags -c $in -o $out
  depfile = $out.d
  deps = gcc  # or deps = msvc for MSVC

# This is much faster than listing all headers manually
# build main.o: compile main.c include/utils.h include/parser.h ...  # Slow
build main.o: compile main.c  # Fast with depfile
```

### Response Files

```ninja
# For very large link commands
rule link
  command = $cc @$out.rsp -o $out
  rspfile = $out.rsp
  rspfile_content = $in $ldflags
  description = LINK $out

# Avoids command-line length limits
build program: link $
  obj1.o obj2.o obj3.o ... obj1000.o
  ldflags = -lfoo -lbar -lbaz
```

### Build Pools

```ninja
# Limit concurrent linking (memory intensive)
pool link_pool
  depth = 2

# Limit concurrent heavy compilation
pool heavy_pool
  depth = 4

rule link
  command = gcc -o $out $in
  pool = link_pool

rule heavy_compile
  command = gcc -O3 -c $in -o $out
  pool = heavy_pool
```

## Best Practices

### File Organization

```ninja
# Recommended structure:
# build.ninja           - Main file (often generated)
# rules.ninja           - Rule definitions
# config.ninja          - Variables and configuration
# src/build.ninja       - Subdirectory builds
# configure.py          - Generator script

# Main build.ninja
include config.ninja
include rules.ninja
subninja src/build.ninja
subninja tests/build.ninja

default all
```

### Using Build Generators

```ninja
# DON'T write build.ninja manually for large projects
# DO use a generator (Python, shell script, etc.)

# Generator benefits:
# - Automatic source discovery
# - Consistent patterns
# - Easy to maintain
# - Platform-specific handling

# Example: configure.py
#!/usr/bin/env python3
import glob
import sys

sources = glob.glob("src/**/*.c", recursive=True)
# Generate build.ninja from sources
```

### Variable Naming

```ninja
# Use clear, consistent variable names
cc = gcc
cxx = g++
ar = ar
cflags = -Wall -Wextra -O2
cxxflags = -Wall -Wextra -std=c++17 -O2
ldflags = -lpthread -lm
includes = -Iinclude -Isrc

# Not: c = gcc, f = -Wall, l = -lpthread
```

### Dependency Management

```ninja
# ALWAYS use depfiles for header dependencies
rule compile
  command = $cc -MMD -MF $out.d $cflags -c $in -o $out
  depfile = $out.d
  deps = gcc

# DON'T manually list headers
# build main.o: compile main.c utils.h parser.h  # Hard to maintain

# DO use depfiles
build main.o: compile main.c  # Dependencies auto-discovered
```

### Clean Builds

```ninja
# Use builddir to organize outputs
builddir = build

build $builddir/obj/main.o: compile src/main.c
build $builddir/bin/program: link $builddir/obj/main.o

# Clean with: rm -rf build/
# Or: ninja -t clean
```

### Error Handling

```ninja
# Keep rules simple and focused
rule compile
  command = $cc $cflags -c $in -o $out
  description = CC $out

# Not: command = mkdir -p obj && $cc $cflags -c $in -o $out

# Use order-only dependencies for prerequisites
build obj/main.o: compile src/main.c || obj

build obj: phony
  command = mkdir -p obj
```

## Debugging and Troubleshooting

### Common Issues

```bash
# "multiple rules generate X" error
# Problem: Two build statements produce same output
# Solution: Check for duplicate build statements

# "unknown target" error
ninja -t targets all  # List all targets
ninja -t targets depth 0  # List top-level targets

# "dependency cycle detected" error
ninja -t graph | dot -Tpng -o graph.png
# Visualize to find cycle

# "no such file or directory" error
ninja -d explain  # Show why builds are triggered
ninja -v  # Verbose output
```

### Debug Options

```bash
# Explain rebuild decisions
ninja -d explain -v target

# Show build statistics
ninja -d stats

# List all commands
ninja -t commands target

# Browse dependency graph
ninja -t browse target

# Show dependency information
ninja -t deps

# Validate build file
ninja -t recompact

# Clean build
ninja -t clean
ninja -t clean -r rule_name  # Clean specific rule outputs
```

### Build File Debugging

```bash
# Check syntax
ninja -n

# Show what would be built
ninja -n target

# Verbose execution
ninja -v

# Keep response files
ninja -d keeprsp

# Print query results
ninja -t query target
```

### Performance Analysis

```bash
# Time the build
time ninja

# Show build stats
ninja -d stats

# Profile command execution
ninja -t compdb > compile_commands.json

# Find slow steps
ninja -d stats | grep "longest"
```

## Ninja Tools

### Built-in Tools

```bash
# List all tools
ninja -t list

# Common tools:
ninja -t clean          # Remove built files
ninja -t commands       # Show commands for target
ninja -t deps           # Show dependencies
ninja -t graph          # Dependency graph (dot format)
ninja -t targets        # List targets
ninja -t rules          # List rules
ninja -t browse         # Browse dependency graph in browser
ninja -t query          # Query target info
ninja -t compdb         # Generate compilation database
ninja -t recompact      # Recompact .ninja_deps file
```

### Compilation Database

```bash
# Generate compile_commands.json
ninja -t compdb > compile_commands.json

# Used by:
# - clangd (LSP)
# - clang-tidy
# - clang-format
# - VSCode C++ extension
# - Other IDE tools
```

## Complete Example

```ninja
# Complete build.ninja for a C++ project
# This would typically be generated by a script

# Configuration
builddir = build
srcdir = src
incdir = include
objdir = $builddir/obj
bindir = $builddir/bin

# Toolchain
cxx = g++
ar = ar

# Flags
cxxflags = -std=c++17 -Wall -Wextra -O2 -I$incdir
ldflags = -lpthread -lm
arflags = rcs

# Rules
rule compile
  command = $cxx -MMD -MF $out.d $cxxflags -c $in -o $out
  description = CXX $out
  depfile = $out.d
  deps = gcc

rule link
  command = $cxx -o $out $in $ldflags
  description = LINK $out

rule archive
  command = rm -f $out && $ar $arflags $out $in
  description = AR $out

rule mkdir
  command = mkdir -p $out
  description = MKDIR $out

# Directories
build $objdir: mkdir
build $bindir: mkdir

# Core library
build $objdir/utils.o: compile $srcdir/utils.cpp || $objdir
build $objdir/parser.o: compile $srcdir/parser.cpp || $objdir
build $objdir/network.o: compile $srcdir/network.cpp || $objdir
build $builddir/libcore.a: archive $
  $objdir/utils.o $
  $objdir/parser.o $
  $objdir/network.o

# Main application
build $objdir/main.o: compile $srcdir/main.cpp || $objdir
build $bindir/program: link $objdir/main.o $builddir/libcore.a || $bindir

# Tests
build $objdir/test_utils.o: compile tests/test_utils.cpp || $objdir
build $objdir/test_parser.o: compile tests/test_parser.cpp || $objdir
build $bindir/test_runner: link $
  $objdir/test_utils.o $
  $objdir/test_parser.o $
  $builddir/libcore.a $
  || $bindir

# Phony targets
build all: phony $bindir/program $bindir/test_runner
build test: phony $bindir/test_runner
build lib: phony $builddir/libcore.a

# Default
default all

# Regenerate build.ninja when configure.py changes
rule configure
  command = python3 configure.py
  generator = 1
  description = Regenerating build.ninja

build build.ninja: configure configure.py
```

## Quick Reference

| Command | Description |
|---------|-------------|
| `ninja` | Build all targets |
| `ninja target` | Build specific target |
| `ninja -v` | Verbose output |
| `ninja -n` | Dry run |
| `ninja -j N` | Use N parallel jobs |
| `ninja -k N` | Keep going (stop after N errors) |
| `ninja -t clean` | Clean outputs |
| `ninja -t targets` | List targets |
| `ninja -t graph` | Show dependency graph |
| `ninja -t commands` | Show commands for target |
| `ninja -d explain` | Explain rebuild decisions |
| `ninja -t compdb` | Generate compile_commands.json |

## Useful Tips

1. **Use build generators** - Don't write build.ninja manually for large projects
2. **Leverage depfiles** - Automatic header dependency tracking with `-MMD -MF`
3. **Organize with builddir** - Keep outputs separate from sources
4. **Use pools wisely** - Control resource-intensive parallel builds
5. **Generate compile_commands.json** - Essential for IDE integration
6. **Profile builds** - Use `ninja -d stats` to find bottlenecks
7. **Use response files** - Handle very long command lines
8. **Leverage restat** - Avoid unnecessary rebuilds from code generation
9. **Keep it simple** - Ninja is designed for machine generation, not human editing
10. **Integrate with meta-build systems** - CMake, Meson, GN handle complexity better

Ninja excels at fast, parallel builds with minimal overhead. It's the build system of choice for large projects like Chromium, LLVM, and Android, where build speed is critical.
