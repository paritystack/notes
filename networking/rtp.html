<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rtp - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-9dfbd86b.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-ccaedc6f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-da6337af.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="rtp-real-time-transport-protocol"><a class="header" href="#rtp-real-time-transport-protocol">RTP (Real-Time Transport Protocol)</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#key-features">Key Features</a></li>
<li><a href="#rtp-vs-other-protocols">RTP vs Other Protocols</a></li>
<li><a href="#rtp-packet-format">RTP Packet Format</a></li>
<li><a href="#how-rtp-works">How RTP Works</a></li>
<li><a href="#rtcp-rtp-control-protocol">RTCP (RTP Control Protocol)</a></li>
<li><a href="#payload-types-and-codecs">Payload Types and Codecs</a></li>
<li><a href="#code-examples">Code Examples</a></li>
<li><a href="#jitter-buffer-management">Jitter Buffer Management</a></li>
<li><a href="#packet-loss-handling">Packet Loss Handling</a></li>
<li><a href="#rtp-extensions">RTP Extensions</a></li>
<li><a href="#security-srtp">Security: SRTP</a></li>
<li><a href="#integration-with-other-protocols">Integration with Other Protocols</a></li>
<li><a href="#common-use-cases">Common Use Cases</a></li>
<li><a href="#advanced-topics">Advanced Topics</a></li>
<li><a href="#monitoring-and-debugging">Monitoring and Debugging</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#performance-optimization">Performance Optimization</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#rtp-libraries-and-tools">RTP Libraries and Tools</a></li>
<li><a href="#eli10">ELI10</a></li>
<li><a href="#further-resources">Further Resources</a></li>
</ul>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>RTP (Real-Time Transport Protocol)</strong> is a network protocol designed for delivering audio and video over IP networks in real-time. Defined in RFC 3550, RTP provides end-to-end delivery services for data with real-time characteristics, such as interactive audio and video.</p>
<h3 id="what-is-rtp"><a class="header" href="#what-is-rtp">What is RTP?</a></h3>
<p>RTP is <strong>not</strong> a complete transport protocol by itself. Instead, it’s designed to work on top of UDP, providing:</p>
<ul>
<li><strong>Payload type identification</strong> - Indicates the format of the data (codec)</li>
<li><strong>Sequence numbering</strong> - Allows detection of packet loss and out-of-order delivery</li>
<li><strong>Timestamping</strong> - Enables synchronization and jitter calculations</li>
<li><strong>Source identification</strong> - Identifies the sender of a stream</li>
</ul>
<p><strong>Key Point</strong>: RTP does NOT guarantee delivery, quality of service, or in-order delivery. It provides the mechanisms to detect and handle these issues at the application level.</p>
<h3 id="rtp-and-rtcp-relationship"><a class="header" href="#rtp-and-rtcp-relationship">RTP and RTCP Relationship</a></h3>
<p>RTP works together with <strong>RTCP (RTP Control Protocol)</strong>:</p>
<ul>
<li><strong>RTP</strong>: Carries the actual media data (audio/video packets)</li>
<li><strong>RTCP</strong>: Provides out-of-band control information (quality feedback, participant information)</li>
</ul>
<p>Think of them as partners:</p>
<ul>
<li>RTP = The delivery trucks carrying packages</li>
<li>RTCP = The quality control reports and delivery confirmations</li>
</ul>
<h3 id="why-rtp-exists"><a class="header" href="#why-rtp-exists">Why RTP Exists</a></h3>
<p>Before RTP, applications had to build custom solutions for real-time media. RTP provides:</p>
<ol>
<li><strong>Standardization</strong>: Common format for real-time media transport</li>
<li><strong>Codec Independence</strong>: Works with any audio/video codec</li>
<li><strong>Synchronization</strong>: Enables lip-sync between audio and video</li>
<li><strong>Quality Monitoring</strong>: Via RTCP feedback</li>
<li><strong>Mixing/Translation</strong>: Support for multiparty scenarios</li>
<li><strong>Scalability</strong>: From peer-to-peer to large broadcasts</li>
</ol>
<h3 id="primary-use-cases"><a class="header" href="#primary-use-cases">Primary Use Cases</a></h3>
<ul>
<li><strong>VoIP (Voice over IP)</strong>: Telephone calls over the internet</li>
<li><strong>Video Conferencing</strong>: Zoom, Teams, Google Meet</li>
<li><strong>Live Streaming</strong>: Broadcast media delivery</li>
<li><strong>WebRTC</strong>: Browser-to-browser real-time communication</li>
<li><strong>IPTV</strong>: Television over IP networks</li>
<li><strong>Gaming</strong>: Voice chat in multiplayer games</li>
</ul>
<hr>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="1-real-time-delivery"><a class="header" href="#1-real-time-delivery">1. Real-Time Delivery</a></h3>
<p>RTP is optimized for real-time delivery, not reliability:</p>
<ul>
<li>Uses UDP (not TCP) for low latency</li>
<li>No retransmissions by default (optional RTX extension)</li>
<li>Prioritizes timeliness over completeness</li>
</ul>
<h3 id="2-payload-flexibility"><a class="header" href="#2-payload-flexibility">2. Payload Flexibility</a></h3>
<p>RTP can carry any codec:</p>
<ul>
<li><strong>Audio</strong>: Opus, G.711, AAC, AMR</li>
<li><strong>Video</strong>: H.264, VP8, VP9, AV1</li>
<li><strong>Other</strong>: Text, application data</li>
</ul>
<h3 id="3-timing-information"><a class="header" href="#3-timing-information">3. Timing Information</a></h3>
<p>Each packet includes:</p>
<ul>
<li><strong>Timestamp</strong>: When the data was sampled (not when sent)</li>
<li><strong>Clock rate</strong>: Specific to the codec (e.g., 48000 Hz for Opus)</li>
<li>Enables jitter buffer and synchronization</li>
</ul>
<h3 id="4-sequence-numbering"><a class="header" href="#4-sequence-numbering">4. Sequence Numbering</a></h3>
<ul>
<li>Increments by 1 for each packet sent</li>
<li>Detects packet loss (gaps in sequence)</li>
<li>Detects out-of-order delivery</li>
<li>Detects duplicate packets</li>
</ul>
<h3 id="5-source-identification"><a class="header" href="#5-source-identification">5. Source Identification</a></h3>
<ul>
<li><strong>SSRC (Synchronization Source)</strong>: Unique identifier for each stream</li>
<li><strong>CSRC (Contributing Source)</strong>: Lists sources in mixed streams</li>
<li>Enables multiple streams in one session</li>
</ul>
<h3 id="6-quality-feedback-via-rtcp"><a class="header" href="#6-quality-feedback-via-rtcp">6. Quality Feedback (via RTCP)</a></h3>
<ul>
<li>Packet loss statistics</li>
<li>Jitter measurements</li>
<li>Round-trip time</li>
<li>Bandwidth usage</li>
</ul>
<hr>
<h2 id="rtp-vs-other-protocols"><a class="header" href="#rtp-vs-other-protocols">RTP vs Other Protocols</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>RTP</th><th>TCP</th><th>UDP</th><th>RTCP</th></tr>
</thead>
<tbody>
<tr><td><strong>Purpose</strong></td><td>Real-time media transport</td><td>Reliable data transfer</td><td>Unreliable datagram</td><td>Control/feedback for RTP</td></tr>
<tr><td><strong>Reliability</strong></td><td>No (optional RTX)</td><td>Yes (guaranteed)</td><td>No</td><td>No</td></tr>
<tr><td><strong>Ordering</strong></td><td>Sequence numbers</td><td>Yes (guaranteed)</td><td>No</td><td>N/A</td></tr>
<tr><td><strong>Latency</strong></td><td>Low</td><td>Variable (retransmits)</td><td>Low</td><td>Low</td></tr>
<tr><td><strong>Use Case</strong></td><td>Audio/video streaming</td><td>File transfer, web</td><td>DNS, gaming</td><td>Quality monitoring</td></tr>
<tr><td><strong>Overhead</strong></td><td>12+ bytes</td><td>20+ bytes</td><td>8 bytes</td><td>Variable</td></tr>
<tr><td><strong>Transport</strong></td><td>Over UDP</td><td>Direct IP</td><td>Direct IP</td><td>Over UDP</td></tr>
<tr><td><strong>Timing</strong></td><td>Timestamps</td><td>No</td><td>No</td><td>Yes (SR packets)</td></tr>
<tr><td><strong>Bandwidth</strong></td><td>Adaptive</td><td>Flow control</td><td>None</td><td>Reports usage</td></tr>
</tbody>
</table>
</div>
<h3 id="when-to-use-rtp"><a class="header" href="#when-to-use-rtp">When to Use RTP</a></h3>
<p><strong>Use RTP when:</strong></p>
<ul>
<li>Transporting real-time audio or video</li>
<li>Latency is critical (&lt; 200ms target)</li>
<li>Some packet loss is acceptable (1-3%)</li>
<li>Need synchronization between streams</li>
<li>Interoperability with VoIP/video systems</li>
</ul>
<p><strong>Don’t use RTP when:</strong></p>
<ul>
<li>Transferring files (use TCP/HTTP)</li>
<li>Every packet is critical (use TCP)</li>
<li>Not time-sensitive data</li>
<li>Simple request-response patterns</li>
</ul>
<hr>
<h2 id="rtp-packet-format"><a class="header" href="#rtp-packet-format">RTP Packet Format</a></h2>
<h3 id="header-structure"><a class="header" href="#header-structure">Header Structure</a></h3>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) Identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) Identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Header Extension (optional)                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h3 id="field-descriptions"><a class="header" href="#field-descriptions">Field Descriptions</a></h3>
<h4 id="version-v---2-bits"><a class="header" href="#version-v---2-bits">Version (V) - 2 bits</a></h4>
<ul>
<li><strong>Value</strong>: Always 2 for current RTP</li>
<li>Identifies the RTP version</li>
</ul>
<h4 id="padding-p---1-bit"><a class="header" href="#padding-p---1-bit">Padding (P) - 1 bit</a></h4>
<ul>
<li><strong>0</strong>: No padding</li>
<li><strong>1</strong>: Packet contains padding bytes at the end</li>
<li>Last byte indicates padding length</li>
<li>Used for encryption block alignment</li>
</ul>
<h4 id="extension-x---1-bit"><a class="header" href="#extension-x---1-bit">Extension (X) - 1 bit</a></h4>
<ul>
<li><strong>0</strong>: No header extension</li>
<li><strong>1</strong>: Header extension follows fixed header</li>
<li>Allows custom additions (audio level, video orientation, etc.)</li>
</ul>
<h4 id="csrc-count-cc---4-bits"><a class="header" href="#csrc-count-cc---4-bits">CSRC Count (CC) - 4 bits</a></h4>
<ul>
<li><strong>Value</strong>: 0-15</li>
<li>Number of CSRC identifiers following the SSRC</li>
<li>Used in mixed streams (conference servers)</li>
</ul>
<h4 id="marker-m---1-bit"><a class="header" href="#marker-m---1-bit">Marker (M) - 1 bit</a></h4>
<ul>
<li><strong>Meaning</strong>: Codec-specific</li>
<li><strong>Audio</strong>: Typically marks start of talk burst</li>
<li><strong>Video</strong>: Marks end of video frame</li>
<li><strong>Usage</strong>: Application-defined boundary marker</li>
</ul>
<h4 id="payload-type-pt---7-bits"><a class="header" href="#payload-type-pt---7-bits">Payload Type (PT) - 7 bits</a></h4>
<ul>
<li><strong>Value</strong>: 0-127</li>
<li>Identifies the codec/format of payload</li>
<li><strong>0-95</strong>: Static assignments (e.g., 0=PCMU, 8=PCMA)</li>
<li><strong>96-127</strong>: Dynamic assignments (negotiated via SDP)</li>
</ul>
<h4 id="sequence-number---16-bits"><a class="header" href="#sequence-number---16-bits">Sequence Number - 16 bits</a></h4>
<ul>
<li><strong>Value</strong>: 0-65535, wraps around</li>
<li>Increments by 1 for each packet sent</li>
<li><strong>Uses</strong>:
<ul>
<li>Detect packet loss (gaps)</li>
<li>Detect duplicates</li>
<li>Restore packet order</li>
<li>Initial value is random (security)</li>
</ul>
</li>
</ul>
<h4 id="timestamp---32-bits"><a class="header" href="#timestamp---32-bits">Timestamp - 32 bits</a></h4>
<ul>
<li><strong>Value</strong>: Sampling instant of first byte in payload</li>
<li>Increments based on <strong>clock rate</strong> (codec-specific)</li>
<li><strong>Not</strong> wall-clock time</li>
<li><strong>Examples</strong>:
<ul>
<li>Audio (48kHz): Increments by 960 for 20ms packet</li>
<li>Video (90kHz): Increments by 3000 for 33ms frame</li>
</ul>
</li>
<li>Used for jitter calculation and synchronization</li>
</ul>
<h4 id="ssrc-synchronization-source---32-bits"><a class="header" href="#ssrc-synchronization-source---32-bits">SSRC (Synchronization Source) - 32 bits</a></h4>
<ul>
<li><strong>Unique identifier</strong> for the source of the stream</li>
<li>Randomly chosen to avoid collisions</li>
<li>Stays constant for duration of session</li>
<li>Different streams (audio/video) have different SSRCs</li>
</ul>
<h4 id="csrc-contributing-source---0-15-items-32-bits-each"><a class="header" href="#csrc-contributing-source---0-15-items-32-bits-each">CSRC (Contributing Source) - 0-15 items, 32 bits each</a></h4>
<ul>
<li>Lists sources that contributed to mixed stream</li>
<li>Example: Conference server mixing 3 participants</li>
<li>Count specified in CC field</li>
<li>Rarely used in peer-to-peer scenarios</li>
</ul>
<h3 id="header-extension-format"><a class="header" href="#header-extension-format">Header Extension Format</a></h3>
<p>When X=1, extension follows SSRC/CSRC:</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Defined by Profile       |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Extension Data                         |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h3 id="example-packet-breakdown"><a class="header" href="#example-packet-breakdown">Example Packet Breakdown</a></h3>
<pre><code>Hex: 80 08 1a 2b 00 00 03 e8 ab cd ef 01 ...

Binary breakdown:
80 = 10000000
     10 = Version 2
       0 = No padding
        0 = No extension
         0000 = CC=0 (no CSRC)

08 = 00001000
     0 = Marker=0
      0001000 = PT=8 (PCMA/G.711 A-law)

1a 2b = Sequence number = 6699

00 00 03 e8 = Timestamp = 1000

ab cd ef 01 = SSRC = 2882400001
</code></pre>
<hr>
<h2 id="how-rtp-works"><a class="header" href="#how-rtp-works">How RTP Works</a></h2>
<h3 id="session-establishment"><a class="header" href="#session-establishment">Session Establishment</a></h3>
<p>RTP itself doesn’t establish sessions. That’s done by signaling protocols:</p>
<ol>
<li><strong>SDP (Session Description Protocol)</strong>: Describes media parameters</li>
<li><strong>SIP/SDP</strong>: VoIP call setup</li>
<li><strong>WebRTC</strong>: ICE/DTLS/SDP negotiation</li>
</ol>
<p><strong>Example SDP for Audio:</strong></p>
<pre><code>v=0
o=- 123456 123456 IN IP4 192.168.1.100
s=Audio Call
c=IN IP4 192.168.1.100
t=0 0
m=audio 5004 RTP/AVP 111
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10;useinbandfec=1
</code></pre>
<p><strong>Breakdown:</strong></p>
<ul>
<li><code>m=audio 5004 RTP/AVP 111</code>: Audio on port 5004, payload type 111</li>
<li><code>a=rtpmap:111 opus/48000/2</code>: PT 111 = Opus, 48kHz, stereo</li>
<li>RTP on even port 5004, RTCP on odd port 5005 (convention)</li>
</ul>
<h3 id="port-allocation"><a class="header" href="#port-allocation">Port Allocation</a></h3>
<p><strong>Convention:</strong></p>
<ul>
<li>RTP uses <strong>even</strong> port numbers (e.g., 5004, 16384)</li>
<li>RTCP uses <strong>odd</strong> port numbers (e.g., 5005, 16385)</li>
<li>RTCP port = RTP port + 1</li>
</ul>
<p><strong>Modern approach (RTP/RTCP Multiplexing):</strong></p>
<ul>
<li>Both RTP and RTCP on same port (WebRTC)</li>
<li>Distinguishes using packet type</li>
</ul>
<h3 id="packet-flow"><a class="header" href="#packet-flow">Packet Flow</a></h3>
<pre><code>Sender                                    Receiver
  |                                           |
  | [1] Capture audio/video frame             |
  |                                           |
  | [2] Encode with codec (Opus, H.264)       |
  |                                           |
  | [3] Packetize into RTP packets            |
  |     - Add RTP header                      |
  |     - Set timestamp, sequence, PT         |
  |                                           |
  | [4] Send RTP packet over UDP              |
  |------------------------------------------&gt;|
  |                                           | [5] Receive UDP packet
  |                                           |
  |                                           | [6] Parse RTP header
  |                                           |     - Check sequence
  |                                           |     - Extract timestamp
  |                                           |
  |                                           | [7] Buffer in jitter buffer
  |                                           |     - Absorb network jitter
  |                                           |
  |                                           | [8] Decode payload
  |                                           |
  |                                           | [9] Play audio/video
  |                                           |
  | [10] Periodic RTCP reports                |
  |&lt;-----------------------------------------&gt;|
  |   (quality feedback, statistics)          |
</code></pre>
<h3 id="timestamps-and-clock-rates"><a class="header" href="#timestamps-and-clock-rates">Timestamps and Clock Rates</a></h3>
<p><strong>Timestamp Calculation:</strong></p>
<pre><code>timestamp = previous_timestamp + (samples_in_packet)
</code></pre>
<p><strong>Clock Rates by Codec:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Codec</th><th>Clock Rate</th><th>Typical Packet Duration</th><th>Timestamp Increment</th></tr>
</thead>
<tbody>
<tr><td>Opus</td><td>48000 Hz</td><td>20ms</td><td>960</td></tr>
<tr><td>G.711 (PCMU/PCMA)</td><td>8000 Hz</td><td>20ms</td><td>160</td></tr>
<tr><td>AAC</td><td>90000 Hz</td><td>Variable</td><td>Variable</td></tr>
<tr><td>H.264 (video)</td><td>90000 Hz</td><td>33ms (30fps)</td><td>3000</td></tr>
<tr><td>VP8/VP9 (video)</td><td>90000 Hz</td><td>33ms (30fps)</td><td>3000</td></tr>
</tbody>
</table>
</div>
<p><strong>Example (Opus audio at 48kHz):</strong></p>
<pre><code>Packet 1: timestamp = 0
Packet 2: timestamp = 960     (20ms * 48000 Hz = 960)
Packet 3: timestamp = 1920
Packet 4: timestamp = 2880
...
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Timestamp is based on <strong>sampling time</strong>, not sending time</li>
<li>Clock rate is <strong>codec-specific</strong></li>
<li>Video typically uses 90kHz (historical MPEG convention)</li>
<li>Timestamps enable jitter calculation and synchronization</li>
</ul>
<h3 id="synchronization-between-streams"><a class="header" href="#synchronization-between-streams">Synchronization Between Streams</a></h3>
<p>For lip-sync (audio-video synchronization):</p>
<ol>
<li>Each stream has different SSRC</li>
<li>Both use same <strong>NTP timeline</strong> (via RTCP SR)</li>
<li>Receiver correlates timestamps to NTP time</li>
<li>Aligns playback based on NTP correlation</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code>Audio SSRC: 0x12345678
Video SSRC: 0x87654321

RTCP SR (Audio):
  NTP time: 1234567890.500000
  RTP timestamp: 48000

RTCP SR (Video):
  NTP time: 1234567890.500000  (same wall time)
  RTP timestamp: 90000

Receiver can now sync both streams to same timeline
</code></pre>
<hr>
<h2 id="rtcp-rtp-control-protocol"><a class="header" href="#rtcp-rtp-control-protocol">RTCP (RTP Control Protocol)</a></h2>
<p>RTCP is RTP’s companion protocol for quality monitoring and control. While RTP carries media, RTCP carries statistics about the RTP session.</p>
<h3 id="key-functions"><a class="header" href="#key-functions">Key Functions</a></h3>
<ol>
<li><strong>Quality Feedback</strong>: Packet loss, jitter, delay</li>
<li><strong>Participant Identification</strong>: Names, email, etc.</li>
<li><strong>Session Control</strong>: Notify when leaving</li>
<li><strong>Feedback for Congestion Control</strong>: Adapt bitrate based on reports</li>
</ol>
<h3 id="rtcp-packet-types"><a class="header" href="#rtcp-packet-types">RTCP Packet Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Name</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>200</td><td>SR (Sender Report)</td><td>Statistics from active senders</td></tr>
<tr><td>201</td><td>RR (Receiver Report)</td><td>Statistics from receivers</td></tr>
<tr><td>202</td><td>SDES (Source Description)</td><td>Participant information (name, email)</td></tr>
<tr><td>203</td><td>BYE</td><td>Leaving session</td></tr>
<tr><td>204</td><td>APP</td><td>Application-specific messages</td></tr>
</tbody>
</table>
</div>
<h3 id="sender-report-sr---type-200"><a class="header" href="#sender-report-sr---type-200">Sender Report (SR) - Type 200</a></h3>
<p>Sent by active senders (those transmitting RTP):</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |   PT=SR=200   |             Length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         SSRC of Sender                        |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|              NTP Timestamp (most significant word)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              NTP Timestamp (least significant word)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         RTP Timestamp                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Sender's Packet Count                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Sender's Octet Count                     |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 Report Blocks (0 or more)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p><strong>Fields:</strong></p>
<ul>
<li><strong>NTP Timestamp</strong>: Wall-clock time when report sent</li>
<li><strong>RTP Timestamp</strong>: Corresponds to NTP time (for sync)</li>
<li><strong>Packet Count</strong>: Total packets sent</li>
<li><strong>Octet Count</strong>: Total bytes sent</li>
<li><strong>Report Blocks</strong>: Reception quality from this sender</li>
</ul>
<h3 id="receiver-report-rr---type-201"><a class="header" href="#receiver-report-rr---type-201">Receiver Report (RR) - Type 201</a></h3>
<p>Sent by receivers (not actively sending):</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |   PT=RR=201   |             Length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     SSRC of Packet Sender                     |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 Report Blocks (0 or more)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h3 id="report-block-format"><a class="header" href="#report-block-format">Report Block Format</a></h3>
<p>Each SR/RR can contain multiple report blocks (one per source):</p>
<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 SSRC of Source Being Reported                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Fraction Lost |       Cumulative Packets Lost                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Extended Highest Sequence Number Received           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Interarrival Jitter                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Last SR (LSR)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Delay Since Last SR (DLSR)                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p><strong>Key Metrics:</strong></p>
<ol>
<li>
<p><strong>Fraction Lost</strong> (8 bits): Packet loss since last report</p>
<ul>
<li>Value: 0-255 (0 = 0%, 255 = 100%)</li>
<li>Formula: <code>(packets_lost / packets_expected) * 256</code></li>
</ul>
</li>
<li>
<p><strong>Cumulative Packets Lost</strong> (24 bits): Total lost since start</p>
<ul>
<li>Can be negative (duplicates exceed losses)</li>
</ul>
</li>
<li>
<p><strong>Extended Highest Sequence</strong> (32 bits):</p>
<ul>
<li>Highest sequence number received</li>
<li>Plus cycle count (upper 16 bits)</li>
</ul>
</li>
<li>
<p><strong>Interarrival Jitter</strong> (32 bits):</p>
<ul>
<li>Statistical variance of packet arrival times</li>
<li>Lower is better (smoother delivery)</li>
</ul>
</li>
<li>
<p><strong>LSR/DLSR</strong>: For calculating round-trip time</p>
<ul>
<li>LSR = Middle 32 bits of NTP timestamp from last SR</li>
<li>DLSR = Delay since receiving that SR</li>
<li>RTT = (current_time - LSR - DLSR)</li>
</ul>
</li>
</ol>
<h3 id="jitter-calculation"><a class="header" href="#jitter-calculation">Jitter Calculation</a></h3>
<pre><code>J(i) = J(i-1) + (|D(i-1, i)| - J(i-1)) / 16

Where:
D(i-1, i) = (R_i - R_{i-1}) - (S_i - S_{i-1})
R_i = Receive timestamp of packet i
S_i = Send timestamp of packet i (from RTP header)
</code></pre>
<p><strong>In plain English:</strong>
Jitter measures how consistently packets arrive. High jitter = inconsistent timing.</p>
<h3 id="sdes-source-description---type-202"><a class="header" href="#sdes-source-description---type-202">SDES (Source Description) - Type 202</a></h3>
<p>Contains participant information:</p>
<pre><code>Items:
- CNAME (Canonical Name): user@host.domain
- NAME: Full name
- EMAIL: Email address
- PHONE: Phone number
- LOC: Geographic location
- TOOL: Application/tool name
- NOTE: Transient messages
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>CNAME: alice@192.168.1.100
NAME: Alice Smith
TOOL: MyVoIPApp 1.0
</code></pre>
<h3 id="bye-packet---type-203"><a class="header" href="#bye-packet---type-203">BYE Packet - Type 203</a></h3>
<p>Indicates participant is leaving:</p>
<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    SC   |   PT=BYE=203  |             Length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           SSRC/CSRC                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Length    |               Reason for leaving              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p><strong>Usage:</strong></p>
<ul>
<li>Clean session termination</li>
<li>Allows receivers to free resources quickly</li>
<li>Optional reason string (e.g., “User disconnected”)</li>
</ul>
<h3 id="rtcp-bandwidth-management"><a class="header" href="#rtcp-bandwidth-management">RTCP Bandwidth Management</a></h3>
<p><strong>Rules</strong> (to prevent RTCP from overwhelming network):</p>
<ol>
<li><strong>RTCP bandwidth d 5% of RTP bandwidth</strong></li>
<li><strong>Senders get 25% of RTCP bandwidth</strong></li>
<li><strong>Receivers share remaining 75%</strong></li>
<li><strong>Minimum interval between reports: 5 seconds</strong></li>
</ol>
<p><strong>Calculation:</strong></p>
<pre><code class="language-python">def rtcp_interval(members, senders, rtcp_bw, we_sent):
    """Calculate RTCP report interval"""
    # Constants
    RTCP_MIN_TIME = 5.0  # seconds
    COMPENSATION = 2.71828  # e

    # Fraction for senders
    if we_sent:
        rtcp_fraction = 0.25
    else:
        rtcp_fraction = 0.75

    # Average packet size (assume 200 bytes for RTCP)
    avg_rtcp_size = 200

    # Calculate interval
    n = members
    t = (n * avg_rtcp_size) / (rtcp_fraction * rtcp_bw)
    t = max(t, RTCP_MIN_TIME)

    # Randomize to prevent synchronization
    # Actual interval: [0.5*t, 1.5*t]
    import random
    return t * (random.random() + 0.5)
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>10 participants, 256 kbps audio stream
RTP bandwidth = 256 kbps
RTCP bandwidth = 5% = 12.8 kbps

Average RTCP report interval H 5-10 seconds
</code></pre>
<hr>
<h2 id="payload-types-and-codecs"><a class="header" href="#payload-types-and-codecs">Payload Types and Codecs</a></h2>
<p>RTP can carry any media format. The <strong>Payload Type (PT)</strong> field identifies the codec.</p>
<h3 id="static-payload-types-0-95"><a class="header" href="#static-payload-types-0-95">Static Payload Types (0-95)</a></h3>
<p>Defined in RFC 3551, permanently assigned:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>PT</th><th>Codec</th><th>Type</th><th>Clock Rate</th><th>Channels</th><th>Bitrate</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>PCMU (G.711 μ-law)</td><td>Audio</td><td>8000 Hz</td><td>1</td><td>64 kbps</td></tr>
<tr><td>3</td><td>GSM</td><td>Audio</td><td>8000 Hz</td><td>1</td><td>13 kbps</td></tr>
<tr><td>4</td><td>G.723</td><td>Audio</td><td>8000 Hz</td><td>1</td><td>5.3/6.3 kbps</td></tr>
<tr><td>8</td><td>PCMA (G.711 A-law)</td><td>Audio</td><td>8000 Hz</td><td>1</td><td>64 kbps</td></tr>
<tr><td>9</td><td>G.722</td><td>Audio</td><td>8000 Hz</td><td>1</td><td>64 kbps</td></tr>
<tr><td>18</td><td>G.729</td><td>Audio</td><td>8000 Hz</td><td>1</td><td>8 kbps</td></tr>
<tr><td>26</td><td>JPEG</td><td>Video</td><td>90000 Hz</td><td>-</td><td>Variable</td></tr>
<tr><td>31</td><td>H.261</td><td>Video</td><td>90000 Hz</td><td>-</td><td>Variable</td></tr>
<tr><td>32</td><td>MPV (MPEG-1/2 Video)</td><td>Video</td><td>90000 Hz</td><td>-</td><td>Variable</td></tr>
<tr><td>34</td><td>H.263</td><td>Video</td><td>90000 Hz</td><td>-</td><td>Variable</td></tr>
</tbody>
</table>
</div>
<h3 id="dynamic-payload-types-96-127"><a class="header" href="#dynamic-payload-types-96-127">Dynamic Payload Types (96-127)</a></h3>
<p>Negotiated via SDP for modern codecs:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>PT</th><th>Codec</th><th>Type</th><th>Clock Rate</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>96-127</td><td>Opus</td><td>Audio</td><td>48000 Hz</td><td>Recommended for WebRTC</td></tr>
<tr><td>96-127</td><td>H.264</td><td>Video</td><td>90000 Hz</td><td>Most common video codec</td></tr>
<tr><td>96-127</td><td>VP8</td><td>Video</td><td>90000 Hz</td><td>WebRTC video</td></tr>
<tr><td>96-127</td><td>VP9</td><td>Video</td><td>90000 Hz</td><td>Better compression than VP8</td></tr>
<tr><td>96-127</td><td>AV1</td><td>Video</td><td>90000 Hz</td><td>Next-gen codec</td></tr>
<tr><td>96-127</td><td>AAC</td><td>Audio</td><td>Variable</td><td>High-quality audio</td></tr>
</tbody>
</table>
</div>
<h3 id="sdp-payload-type-mapping"><a class="header" href="#sdp-payload-type-mapping">SDP Payload Type Mapping</a></h3>
<p><strong>Example SDP with multiple codecs:</strong></p>
<pre><code>m=audio 5004 RTP/AVP 111 0 8
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10;useinbandfec=1
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000

m=video 5006 RTP/AVP 96 97
a=rtpmap:96 VP8/90000
a=rtpmap:97 H264/90000
a=fmtp:97 profile-level-id=42e01f;packetization-mode=1
</code></pre>
<p><strong>Breakdown:</strong></p>
<ul>
<li>Audio: PT 111=Opus, 0=PCMU, 8=PCMA</li>
<li>Video: PT 96=VP8, 97=H.264</li>
<li><code>a=fmtp</code>: Format-specific parameters</li>
<li>Endpoints negotiate which to use</li>
</ul>
<h3 id="audio-codec-comparison"><a class="header" href="#audio-codec-comparison">Audio Codec Comparison</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Codec</th><th>Bitrate</th><th>Latency</th><th>Quality</th><th>Complexity</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Opus</strong></td><td>6-510 kbps</td><td>5-66 ms</td><td>Excellent</td><td>Medium</td><td>Recommended for all</td></tr>
<tr><td><strong>G.711</strong></td><td>64 kbps</td><td>0.125 ms</td><td>Good</td><td>Very low</td><td>Legacy VoIP</td></tr>
<tr><td><strong>G.722</strong></td><td>64 kbps</td><td>Low</td><td>Very good</td><td>Low</td><td>HD VoIP</td></tr>
<tr><td><strong>AAC</strong></td><td>64-320 kbps</td><td>Medium</td><td>Excellent</td><td>High</td><td>Streaming, music</td></tr>
<tr><td><strong>AMR-WB</strong></td><td>6.6-23.85 kbps</td><td>Low</td><td>Good</td><td>Low</td><td>Mobile networks</td></tr>
<tr><td><strong>iLBC</strong></td><td>13.3/15.2 kbps</td><td>20-30 ms</td><td>Fair</td><td>Low</td><td>Lossy networks</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation</strong>: Use <strong>Opus</strong> for new implementations (best quality/bitrate ratio, low latency).</p>
<h3 id="video-codec-comparison"><a class="header" href="#video-codec-comparison">Video Codec Comparison</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Codec</th><th>Bitrate (1080p)</th><th>Compression</th><th>Complexity</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>H.264</strong></td><td>2-5 Mbps</td><td>Good</td><td>Medium</td><td>Universal support</td></tr>
<tr><td><strong>VP8</strong></td><td>2-6 Mbps</td><td>Good</td><td>Medium</td><td>WebRTC, open-source</td></tr>
<tr><td><strong>VP9</strong></td><td>1-3 Mbps</td><td>Better</td><td>High</td><td>YouTube, streaming</td></tr>
<tr><td><strong>AV1</strong></td><td>0.5-2 Mbps</td><td>Best</td><td>Very high</td><td>Future, streaming</td></tr>
<tr><td><strong>H.265/HEVC</strong></td><td>1-3 Mbps</td><td>Better</td><td>High</td><td>4K streaming</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation</strong>:</p>
<ul>
<li><strong>WebRTC</strong>: H.264 or VP8 (best compatibility)</li>
<li><strong>Streaming</strong>: VP9 or AV1 (better compression)</li>
<li><strong>Universal</strong>: H.264 (widest support)</li>
</ul>
<h3 id="packetization-examples"><a class="header" href="#packetization-examples">Packetization Examples</a></h3>
<h4 id="audio-packetization-opus"><a class="header" href="#audio-packetization-opus">Audio Packetization (Opus)</a></h4>
<pre><code>Audio frame: 20ms of audio at 48kHz
Samples: 20ms * 48000 Hz = 960 samples
Encoded size: ~40 bytes (at 16 kbps)

RTP Packet:
[12 byte RTP header][40 byte Opus payload]

Timestamp increment: 960 (for next packet)
</code></pre>
<h4 id="video-packetization-h264"><a class="header" href="#video-packetization-h264">Video Packetization (H.264)</a></h4>
<pre><code>Video frame: 1920x1080, encoded to 10 KB
Too large for single packet (MTU typically 1500 bytes)

Solution: Fragmentation (FU-A)
Packet 1: [RTP header][FU-A header][Fragment 1 (1400 bytes)]
Packet 2: [RTP header][FU-A header][Fragment 2 (1400 bytes)]
...
Packet 8: [RTP header][FU-A header][Fragment 8 (400 bytes)]

All packets have SAME timestamp (same frame)
Sequence numbers increment: 1, 2, 3, ...
Marker bit set on LAST packet of frame
</code></pre>
<hr>
<h2 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h2>
<h3 id="python-basic-rtp-sender"><a class="header" href="#python-basic-rtp-sender">Python: Basic RTP Sender</a></h3>
<pre><code class="language-python">import socket
import struct
import time

class RTPSender:
    def __init__(self, dest_ip, dest_port, payload_type=96, ssrc=None):
        self.dest_ip = dest_ip
        self.dest_port = dest_port
        self.payload_type = payload_type
        self.ssrc = ssrc or random.randint(0, 0xFFFFFFFF)

        # RTP state
        self.sequence = random.randint(0, 0xFFFF)
        self.timestamp = random.randint(0, 0xFFFFFFFF)

        # Create UDP socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def create_rtp_packet(self, payload, marker=False):
        """Create RTP packet with given payload"""
        # RTP header (12 bytes)
        version = 2
        padding = 0
        extension = 0
        csrc_count = 0
        marker_bit = 1 if marker else 0

        # Byte 0: V(2), P(1), X(1), CC(4)
        byte0 = (version &lt;&lt; 6) | (padding &lt;&lt; 5) | (extension &lt;&lt; 4) | csrc_count

        # Byte 1: M(1), PT(7)
        byte1 = (marker_bit &lt;&lt; 7) | self.payload_type

        # Pack header
        header = struct.pack(
            '!BBHII',
            byte0,                    # V, P, X, CC
            byte1,                    # M, PT
            self.sequence,            # Sequence number
            self.timestamp,           # Timestamp
            self.ssrc                 # SSRC
        )

        return header + payload

    def send_packet(self, payload, marker=False, timestamp_increment=960):
        """Send RTP packet"""
        packet = self.create_rtp_packet(payload, marker)
        self.sock.sendto(packet, (self.dest_ip, self.dest_port))

        # Update state
        self.sequence = (self.sequence + 1) &amp; 0xFFFF
        self.timestamp = (self.timestamp + timestamp_increment) &amp; 0xFFFFFFFF

    def close(self):
        self.sock.close()


# Example usage: Send audio packets
if __name__ == '__main__':
    import random

    sender = RTPSender('127.0.0.1', 5004, payload_type=111)  # PT 111 = Opus

    # Simulate sending audio packets (20ms each, 48kHz)
    for i in range(100):
        # Generate dummy audio payload (40 bytes for 16kbps Opus)
        audio_data = bytes([random.randint(0, 255) for _ in range(40)])

        # Send packet with 960 timestamp increment (20ms at 48kHz)
        sender.send_packet(audio_data, marker=False, timestamp_increment=960)

        print(f"Sent packet {i+1}, seq={sender.sequence-1}, ts={sender.timestamp-960}")

        # Wait 20ms between packets
        time.sleep(0.020)

    sender.close()
</code></pre>
<h3 id="python-basic-rtp-receiver"><a class="header" href="#python-basic-rtp-receiver">Python: Basic RTP Receiver</a></h3>
<pre><code class="language-python">import socket
import struct

class RTPReceiver:
    def __init__(self, listen_port):
        self.listen_port = listen_port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind(('0.0.0.0', listen_port))

        # Statistics
        self.packets_received = 0
        self.last_sequence = None
        self.packets_lost = 0

    def parse_rtp_header(self, packet):
        """Parse RTP header from packet"""
        if len(packet) &lt; 12:
            return None

        # Unpack fixed header
        byte0, byte1, seq, ts, ssrc = struct.unpack('!BBHII', packet[:12])

        # Extract fields
        version = (byte0 &gt;&gt; 6) &amp; 0x03
        padding = (byte0 &gt;&gt; 5) &amp; 0x01
        extension = (byte0 &gt;&gt; 4) &amp; 0x01
        csrc_count = byte0 &amp; 0x0F

        marker = (byte1 &gt;&gt; 7) &amp; 0x01
        payload_type = byte1 &amp; 0x7F

        # Calculate header length
        header_len = 12 + (csrc_count * 4)

        # TODO: Handle extension headers if present

        return {
            'version': version,
            'padding': padding,
            'extension': extension,
            'csrc_count': csrc_count,
            'marker': marker,
            'payload_type': payload_type,
            'sequence': seq,
            'timestamp': ts,
            'ssrc': ssrc,
            'header_length': header_len,
            'payload': packet[header_len:]
        }

    def receive_packet(self):
        """Receive and parse RTP packet"""
        data, addr = self.sock.recvfrom(2048)

        rtp = self.parse_rtp_header(data)
        if not rtp:
            return None

        # Update statistics
        self.packets_received += 1

        # Check for packet loss
        if self.last_sequence is not None:
            expected = (self.last_sequence + 1) &amp; 0xFFFF
            if rtp['sequence'] != expected:
                loss = (rtp['sequence'] - expected) &amp; 0xFFFF
                self.packets_lost += loss
                print(f"WARNING: Detected {loss} packet(s) lost!")

        self.last_sequence = rtp['sequence']

        return rtp

    def close(self):
        self.sock.close()


# Example usage: Receive and display packets
if __name__ == '__main__':
    receiver = RTPReceiver(5004)

    print("Listening for RTP packets on port 5004...")
    print("Press Ctrl+C to stop")

    try:
        while True:
            rtp = receiver.receive_packet()
            if rtp:
                print(f"RTP: seq={rtp['sequence']:5d}, "
                      f"ts={rtp['timestamp']:10d}, "
                      f"PT={rtp['payload_type']:3d}, "
                      f"marker={rtp['marker']}, "
                      f"payload={len(rtp['payload'])} bytes")
    except KeyboardInterrupt:
        print("\nStopping...")
    finally:
        print(f"\nStatistics:")
        print(f"  Packets received: {receiver.packets_received}")
        print(f"  Packets lost: {receiver.packets_lost}")
        if receiver.packets_received &gt; 0:
            loss_rate = (receiver.packets_lost /
                        (receiver.packets_received + receiver.packets_lost)) * 100
            print(f"  Loss rate: {loss_rate:.2f}%")

        receiver.close()
</code></pre>
<h3 id="python-jitter-buffer-implementation"><a class="header" href="#python-jitter-buffer-implementation">Python: Jitter Buffer Implementation</a></h3>
<pre><code class="language-python">import time
import heapq
from collections import deque

class JitterBuffer:
    """Adaptive jitter buffer for RTP packets"""

    def __init__(self, min_delay_ms=20, max_delay_ms=200, target_delay_ms=50):
        self.min_delay = min_delay_ms / 1000.0
        self.max_delay = max_delay_ms / 1000.0
        self.target_delay = target_delay_ms / 1000.0

        # Buffer storage (priority queue by timestamp)
        self.buffer = []

        # Statistics
        self.last_played_ts = None
        self.arrival_times = {}  # sequence -&gt; arrival time
        self.jitter = 0.0

    def add_packet(self, rtp_packet):
        """Add packet to jitter buffer"""
        arrival_time = time.time()
        seq = rtp_packet['sequence']
        ts = rtp_packet['timestamp']

        # Store arrival time for jitter calculation
        self.arrival_times[seq] = arrival_time

        # Add to buffer (priority queue by timestamp)
        heapq.heappush(self.buffer, (ts, seq, rtp_packet))

        # Update jitter estimate
        self._update_jitter(rtp_packet)

    def _update_jitter(self, rtp_packet):
        """Update jitter estimate (RFC 3550 formula)"""
        if self.last_played_ts is None:
            self.last_played_ts = rtp_packet['timestamp']
            return

        seq = rtp_packet['sequence']
        ts = rtp_packet['timestamp']

        if seq in self.arrival_times and (seq - 1) in self.arrival_times:
            # Calculate interarrival jitter
            arrival_diff = self.arrival_times[seq] - self.arrival_times[seq - 1]
            ts_diff = (ts - self.last_played_ts) / 48000.0  # Assume 48kHz

            D = abs(arrival_diff - ts_diff)
            self.jitter = self.jitter + (D - self.jitter) / 16.0

        self.last_played_ts = ts

    def get_packet(self):
        """Get next packet to play (if ready)"""
        if not self.buffer:
            return None

        # Check if oldest packet is ready to play
        ts, seq, packet = self.buffer[0]

        if seq not in self.arrival_times:
            return None

        arrival_time = self.arrival_times[seq]
        current_time = time.time()
        buffered_time = current_time - arrival_time

        # Adaptive delay based on jitter
        required_delay = max(self.min_delay,
                            min(self.max_delay,
                                self.target_delay + self.jitter * 4))

        if buffered_time &gt;= required_delay:
            # Ready to play
            heapq.heappop(self.buffer)
            del self.arrival_times[seq]
            return packet

        return None

    def get_stats(self):
        """Get buffer statistics"""
        return {
            'buffer_size': len(self.buffer),
            'jitter_ms': self.jitter * 1000,
            'current_delay_ms': self._get_current_delay() * 1000
        }

    def _get_current_delay(self):
        """Get current adaptive delay"""
        return max(self.min_delay,
                  min(self.max_delay,
                      self.target_delay + self.jitter * 4))


# Example usage
if __name__ == '__main__':
    jitter_buffer = JitterBuffer(min_delay_ms=20, max_delay_ms=200)

    # Simulate receiving packets with jitter
    import random

    for i in range(50):
        # Create dummy RTP packet
        packet = {
            'sequence': i,
            'timestamp': i * 960,  # 20ms at 48kHz
            'payload': b'audio_data'
        }

        jitter_buffer.add_packet(packet)

        # Simulate network jitter (0-50ms)
        time.sleep(0.020 + random.uniform(-0.010, 0.030))

        # Try to get packets ready for playout
        while True:
            ready_packet = jitter_buffer.get_packet()
            if ready_packet is None:
                break
            print(f"Playing packet seq={ready_packet['sequence']}")

        stats = jitter_buffer.get_stats()
        print(f"  Buffer: {stats['buffer_size']}, "
              f"Jitter: {stats['jitter_ms']:.1f}ms, "
              f"Delay: {stats['current_delay_ms']:.1f}ms")
</code></pre>
<h3 id="javascript-rtp-in-webrtc-browser"><a class="header" href="#javascript-rtp-in-webrtc-browser">JavaScript: RTP in WebRTC (Browser)</a></h3>
<pre><code class="language-javascript">// WebRTC handles RTP automatically, but you can inspect it

async function startVideoCall() {
    const pc = new RTCPeerConnection({
        iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
    });

    // Get local media
    const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
            echoCancellation: true,
            noiseSuppression: true
        },
        video: {
            width: 1280,
            height: 720
        }
    });

    // Add tracks to peer connection
    stream.getTracks().forEach(track =&gt; {
        pc.addTrack(track, stream);
    });

    // Monitor RTP statistics
    setInterval(async () =&gt; {
        const stats = await pc.getStats();

        stats.forEach(report =&gt; {
            if (report.type === 'outbound-rtp') {
                console.log('Outbound RTP Stats:');
                console.log(`  SSRC: ${report.ssrc}`);
                console.log(`  Packets sent: ${report.packetsSent}`);
                console.log(`  Bytes sent: ${report.bytesSent}`);
                console.log(`  Codec: ${report.codecId}`);
            }

            if (report.type === 'inbound-rtp') {
                console.log('Inbound RTP Stats:');
                console.log(`  SSRC: ${report.ssrc}`);
                console.log(`  Packets received: ${report.packetsReceived}`);
                console.log(`  Packets lost: ${report.packetsLost}`);
                console.log(`  Jitter: ${report.jitter} seconds`);
                console.log(`  Loss rate: ${(report.packetsLost /
                    (report.packetsReceived + report.packetsLost) * 100).toFixed(2)}%`);
            }
        });
    }, 2000);

    // Create offer, exchange SDP, etc.
    // (simplified for brevity)
}

// Get RTP capabilities
const capabilities = RTCRtpReceiver.getCapabilities('video');
console.log('Supported video codecs:');
capabilities.codecs.forEach(codec =&gt; {
    console.log(`  ${codec.mimeType} (PT ${codec.clockRate})`);
});
</code></pre>
<h3 id="c-low-level-rtp-packet-parsing"><a class="header" href="#c-low-level-rtp-packet-parsing">C: Low-Level RTP Packet Parsing</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;arpa/inet.h&gt;

typedef struct {
    uint8_t version;
    uint8_t padding;
    uint8_t extension;
    uint8_t csrc_count;
    uint8_t marker;
    uint8_t payload_type;
    uint16_t sequence;
    uint32_t timestamp;
    uint32_t ssrc;
} rtp_header_t;

int parse_rtp_header(const uint8_t *packet, size_t len, rtp_header_t *hdr) {
    if (len &lt; 12) {
        return -1;  // Packet too short
    }

    // Byte 0: V(2), P(1), X(1), CC(4)
    uint8_t byte0 = packet[0];
    hdr-&gt;version = (byte0 &gt;&gt; 6) &amp; 0x03;
    hdr-&gt;padding = (byte0 &gt;&gt; 5) &amp; 0x01;
    hdr-&gt;extension = (byte0 &gt;&gt; 4) &amp; 0x01;
    hdr-&gt;csrc_count = byte0 &amp; 0x0F;

    // Byte 1: M(1), PT(7)
    uint8_t byte1 = packet[1];
    hdr-&gt;marker = (byte1 &gt;&gt; 7) &amp; 0x01;
    hdr-&gt;payload_type = byte1 &amp; 0x7F;

    // Sequence number (network byte order)
    hdr-&gt;sequence = ntohs(*(uint16_t*)(packet + 2));

    // Timestamp (network byte order)
    hdr-&gt;timestamp = ntohl(*(uint32_t*)(packet + 4));

    // SSRC (network byte order)
    hdr-&gt;ssrc = ntohl(*(uint32_t*)(packet + 8));

    return 0;
}

void print_rtp_header(const rtp_header_t *hdr) {
    printf("RTP Header:\n");
    printf("  Version: %u\n", hdr-&gt;version);
    printf("  Padding: %u\n", hdr-&gt;padding);
    printf("  Extension: %u\n", hdr-&gt;extension);
    printf("  CSRC count: %u\n", hdr-&gt;csrc_count);
    printf("  Marker: %u\n", hdr-&gt;marker);
    printf("  Payload type: %u\n", hdr-&gt;payload_type);
    printf("  Sequence: %u\n", hdr-&gt;sequence);
    printf("  Timestamp: %u\n", hdr-&gt;timestamp);
    printf("  SSRC: 0x%08X\n", hdr-&gt;ssrc);
}

int main() {
    // Example RTP packet (hex)
    uint8_t packet[] = {
        0x80,                          // V=2, P=0, X=0, CC=0
        0x60,                          // M=0, PT=96 (0x60)
        0x1A, 0x2B,                    // Sequence = 6699
        0x00, 0x00, 0x03, 0xE8,        // Timestamp = 1000
        0xAB, 0xCD, 0xEF, 0x01,        // SSRC = 0xABCDEF01
        // ... payload follows
    };

    rtp_header_t hdr;
    if (parse_rtp_header(packet, sizeof(packet), &amp;hdr) == 0) {
        print_rtp_header(&amp;hdr);
    }

    return 0;
}
</code></pre>
<hr>
<h2 id="jitter-buffer-management"><a class="header" href="#jitter-buffer-management">Jitter Buffer Management</a></h2>
<p><strong>Jitter</strong> is the variation in packet arrival times. Network jitter causes packets to arrive irregularly, even if sent at constant intervals.</p>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<pre><code>Sender sends every 20ms:
  t=0ms:   Packet 1 sent
  t=20ms:  Packet 2 sent
  t=40ms:  Packet 3 sent
  t=60ms:  Packet 4 sent

Receiver arrival times (with jitter):
  t=25ms:  Packet 1 arrives (25ms delay)
  t=48ms:  Packet 2 arrives (28ms delay)
  t=61ms:  Packet 3 arrives (21ms delay)
  t=95ms:  Packet 4 arrives (35ms delay)

Without buffering  choppy audio/video
</code></pre>
<h3 id="the-solution-jitter-buffer"><a class="header" href="#the-solution-jitter-buffer">The Solution: Jitter Buffer</a></h3>
<p>A jitter buffer absorbs timing variations by:</p>
<ol>
<li><strong>Buffering</strong> incoming packets</li>
<li><strong>Delaying</strong> playout to allow late packets to arrive</li>
<li><strong>Smoothing</strong> output to constant rate</li>
</ol>
<h3 id="fixed-jitter-buffer"><a class="header" href="#fixed-jitter-buffer">Fixed Jitter Buffer</a></h3>
<p>Simplest approach: constant delay</p>
<pre><code class="language-python">class FixedJitterBuffer:
    def __init__(self, delay_ms=50):
        self.delay = delay_ms / 1000.0
        self.buffer = {}

    def add_packet(self, packet):
        arrival_time = time.time()
        playout_time = arrival_time + self.delay
        self.buffer[packet['sequence']] = (playout_time, packet)

    def get_packet_if_ready(self):
        current_time = time.time()

        for seq in sorted(self.buffer.keys()):
            playout_time, packet = self.buffer[seq]
            if current_time &gt;= playout_time:
                del self.buffer[seq]
                return packet

        return None
</code></pre>
<p><strong>Pros</strong>: Simple, predictable latency
<strong>Cons</strong>: Wastes delay when network is good, insufficient when network is bad</p>
<h3 id="adaptive-jitter-buffer"><a class="header" href="#adaptive-jitter-buffer">Adaptive Jitter Buffer</a></h3>
<p>Adjusts delay based on observed jitter:</p>
<pre><code class="language-python">class AdaptiveJitterBuffer:
    def __init__(self):
        self.buffer = []
        self.jitter_estimate = 0.020  # Start with 20ms
        self.min_delay = 0.010         # 10ms minimum
        self.max_delay = 0.200         # 200ms maximum

        # Statistics
        self.last_arrival_time = None
        self.last_rtp_timestamp = None

    def add_packet(self, packet):
        arrival_time = time.time()

        # Update jitter estimate
        if self.last_arrival_time and self.last_rtp_timestamp:
            # Calculate interarrival jitter
            arrival_delta = arrival_time - self.last_arrival_time
            timestamp_delta = (packet['timestamp'] - self.last_rtp_timestamp) / 48000.0

            D = abs(arrival_delta - timestamp_delta)
            self.jitter_estimate = self.jitter_estimate + (D - self.jitter_estimate) / 16.0

        self.last_arrival_time = arrival_time
        self.last_rtp_timestamp = packet['timestamp']

        # Calculate playout time (arrival + adaptive delay)
        adaptive_delay = self._calculate_delay()
        playout_time = arrival_time + adaptive_delay

        # Store packet
        heapq.heappush(self.buffer, (playout_time, packet['sequence'], packet))

    def _calculate_delay(self):
        """Calculate adaptive delay based on jitter"""
        # Delay = base + (jitter * safety_factor)
        delay = 0.040 + (self.jitter_estimate * 4.0)

        # Clamp to min/max
        return max(self.min_delay, min(self.max_delay, delay))

    def get_packet(self):
        if not self.buffer:
            return None

        playout_time, seq, packet = self.buffer[0]

        if time.time() &gt;= playout_time:
            heapq.heappop(self.buffer)
            return packet

        return None
</code></pre>
<p><strong>Pros</strong>: Optimizes delay for current network conditions
<strong>Cons</strong>: More complex, can oscillate</p>
<h3 id="playout-strategies"><a class="header" href="#playout-strategies">Playout Strategies</a></h3>
<h4 id="1-wait-for-first-packet"><a class="header" href="#1-wait-for-first-packet">1. Wait for First Packet</a></h4>
<pre><code class="language-python"># Simplest: play packets as they become ready
while True:
    packet = jitter_buffer.get_packet()
    if packet:
        play_audio(packet['payload'])
    else:
        time.sleep(0.001)  # Small sleep
</code></pre>
<h4 id="2-timed-playout-better"><a class="header" href="#2-timed-playout-better">2. Timed Playout (Better)</a></h4>
<pre><code class="language-python"># Play at fixed intervals regardless of arrival
playout_interval = 0.020  # 20ms

while True:
    start_time = time.time()

    packet = jitter_buffer.get_packet()
    if packet:
        play_audio(packet['payload'])
    else:
        # Packet loss concealment
        play_silence_or_repeat_last()

    # Sleep until next playout time
    elapsed = time.time() - start_time
    if elapsed &lt; playout_interval:
        time.sleep(playout_interval - elapsed)
</code></pre>
<h3 id="packet-loss-concealment-plc"><a class="header" href="#packet-loss-concealment-plc">Packet Loss Concealment (PLC)</a></h3>
<p>When packet is late or lost:</p>
<pre><code class="language-python">def conceal_packet_loss(last_packet, codec_type):
    if codec_type == 'opus':
        # Opus has built-in PLC
        return opus_decoder.decode(None, fec=True)

    elif codec_type == 'pcm':
        # Simple: repeat last packet
        return last_packet['payload']

    elif codec_type == 'advanced':
        # Interpolation between last and next packet
        return interpolate(last_packet, next_packet)
</code></pre>
<h3 id="buffer-underrunoverrun-handling"><a class="header" href="#buffer-underrunoverrun-handling">Buffer Underrun/Overrun Handling</a></h3>
<pre><code class="language-python">def monitor_buffer_health(jitter_buffer):
    buffer_size = len(jitter_buffer.buffer)

    if buffer_size == 0:
        # Underrun: buffer empty
        print("WARNING: Buffer underrun - increasing delay")
        jitter_buffer.target_delay += 0.010  # Add 10ms

    elif buffer_size &gt; 20:
        # Overrun: too much buffered
        print("WARNING: Buffer overrun - decreasing delay")
        jitter_buffer.target_delay -= 0.010  # Remove 10ms
</code></pre>
<hr>
<h2 id="packet-loss-handling"><a class="header" href="#packet-loss-handling">Packet Loss Handling</a></h2>
<p>RTP doesn’t guarantee delivery. Handling packet loss is crucial for quality.</p>
<h3 id="loss-detection"><a class="header" href="#loss-detection">Loss Detection</a></h3>
<h4 id="via-sequence-numbers"><a class="header" href="#via-sequence-numbers">Via Sequence Numbers</a></h4>
<pre><code class="language-python">def detect_loss(current_seq, last_seq):
    """Detect packet loss from sequence numbers"""
    if last_seq is None:
        return 0

    expected = (last_seq + 1) &amp; 0xFFFF

    if current_seq == expected:
        return 0  # No loss
    elif current_seq &gt; expected:
        return current_seq - expected
    else:
        # Wraparound case
        return (0x10000 - expected) + current_seq
</code></pre>
<h4 id="statistics-tracking"><a class="header" href="#statistics-tracking">Statistics Tracking</a></h4>
<pre><code class="language-python">class LossStatistics:
    def __init__(self):
        self.packets_received = 0
        self.packets_expected = 0
        self.packets_lost = 0
        self.last_seq = None

    def update(self, seq):
        if self.last_seq is not None:
            expected = (self.last_seq + 1) &amp; 0xFFFF
            gap = (seq - expected) &amp; 0xFFFF

            if gap &gt; 0:
                self.packets_lost += gap
                self.packets_expected += gap + 1
            else:
                self.packets_expected += 1

        self.packets_received += 1
        self.last_seq = seq

    def get_loss_rate(self):
        if self.packets_expected == 0:
            return 0.0
        return self.packets_lost / self.packets_expected
</code></pre>
<h3 id="loss-concealment-techniques"><a class="header" href="#loss-concealment-techniques">Loss Concealment Techniques</a></h3>
<h4 id="1-packet-repetition-simplest"><a class="header" href="#1-packet-repetition-simplest">1. Packet Repetition (Simplest)</a></h4>
<pre><code class="language-python">def packet_repetition(last_good_packet):
    """Repeat last good packet"""
    return last_good_packet.copy()
</code></pre>
<p><strong>Pros</strong>: Simple, works for all codecs
<strong>Cons</strong>: Noticeable for long losses, can cause “robotic” sound</p>
<h4 id="2-silence-insertion"><a class="header" href="#2-silence-insertion">2. Silence Insertion</a></h4>
<pre><code class="language-python">def silence_insertion(packet_size):
    """Insert silence for lost packet"""
    return bytes([0] * packet_size)
</code></pre>
<p><strong>Pros</strong>: Simple, no artifacts
<strong>Cons</strong>: Causes gaps in audio</p>
<h4 id="3-interpolation"><a class="header" href="#3-interpolation">3. Interpolation</a></h4>
<pre><code class="language-python">def interpolate_audio(prev_packet, next_packet):
    """Linear interpolation between packets"""
    prev_samples = decode(prev_packet)
    next_samples = decode(next_packet)

    interpolated = []
    for i in range(len(prev_samples)):
        value = (prev_samples[i] + next_samples[i]) / 2
        interpolated.append(value)

    return encode(interpolated)
</code></pre>
<p><strong>Pros</strong>: Smoother than repetition
<strong>Cons</strong>: Requires looking ahead (adds delay)</p>
<h4 id="4-codec-specific-plc"><a class="header" href="#4-codec-specific-plc">4. Codec-Specific PLC</a></h4>
<p>Many modern codecs have built-in PLC:</p>
<pre><code class="language-python"># Opus example
import opuslib

decoder = opuslib.Decoder(48000, 2)  # 48kHz stereo

# Decode normal packet
audio = decoder.decode(rtp_packet.payload, frame_size=960)

# Packet lost - use PLC
audio = decoder.decode(None, frame_size=960, fec=False)
</code></pre>
<p><strong>Opus PLC</strong>: Excellent, nearly transparent for 1-2% loss</p>
<h3 id="forward-error-correction-fec"><a class="header" href="#forward-error-correction-fec">Forward Error Correction (FEC)</a></h3>
<p>Send redundant data to reconstruct lost packets.</p>
<h4 id="simple-xor-fec"><a class="header" href="#simple-xor-fec">Simple XOR FEC</a></h4>
<pre><code class="language-python">def create_fec_packet(packet1, packet2):
    """Create FEC packet from XOR of two packets"""
    fec_payload = bytes([a ^ b for a, b in zip(packet1, packet2)])
    return fec_payload

def recover_lost_packet(good_packet, fec_packet):
    """Recover lost packet using FEC"""
    recovered = bytes([a ^ b for a, b in zip(good_packet, fec_packet)])
    return recovered
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code>Send:
  Packet 1 (data)
  Packet 2 (data)
  Packet 3 (FEC = P1 XOR P2)

Receive scenario:
   Packet 1 received
   Packet 2 lost
   Packet 3 (FEC) received
   Recover P2 = P1 XOR FEC
</code></pre>
<p><strong>Overhead</strong>: 33% for this scheme (1 FEC per 2 data packets)</p>
<h4 id="opus-in-band-fec"><a class="header" href="#opus-in-band-fec">Opus In-Band FEC</a></h4>
<pre><code class="language-python"># Encode with FEC
encoder = opuslib.Encoder(48000, 2, opuslib.APPLICATION_VOIP)
encoder.enable_inband_fec()

# Current frame
encoded = encoder.encode(audio_frame, frame_size=960)

# If next packet is lost, decoder can use FEC from current frame
if packet_lost:
    # Decoder extracts FEC from previous packet
    recovered_audio = decoder.decode(previous_packet, frame_size=960, fec=True)
</code></pre>
<h3 id="rtp-retransmission-rtx"><a class="header" href="#rtp-retransmission-rtx">RTP Retransmission (RTX)</a></h3>
<p>RFC 4588 defines retransmission for RTP.</p>
<p><strong>How it works:</strong></p>
<ol>
<li>Receiver detects loss (sequence gap)</li>
<li>Receiver sends RTCP NACK (Negative Acknowledgment)</li>
<li>Sender retransmits lost packet</li>
<li>RTX uses separate payload type and SSRC</li>
</ol>
<p><strong>RTX Packet Format:</strong></p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         RTP Header                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            OSN (Original Sequence Number)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Original RTP Payload                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p><strong>SDP Negotiation:</strong></p>
<pre><code>m=video 5006 RTP/AVP 96 97
a=rtpmap:96 VP8/90000
a=rtpmap:97 rtx/90000
a=fmtp:97 apt=96
</code></pre>
<ul>
<li>PT 96 = VP8 (primary)</li>
<li>PT 97 = RTX for VP8</li>
<li><code>apt=96</code> means “associated payload type = 96”</li>
</ul>
<p><strong>Trade-off</strong>: Retransmission adds latency (round-trip time). Only useful for applications that can tolerate 50-100ms extra delay.</p>
<hr>
<h2 id="rtp-extensions"><a class="header" href="#rtp-extensions">RTP Extensions</a></h2>
<p>RTP header extensions allow adding metadata without breaking compatibility.</p>
<h3 id="extension-mechanism"><a class="header" href="#extension-mechanism">Extension Mechanism</a></h3>
<p>When X=1 in RTP header, extension follows:</p>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      0xBEDE   |    length     | Extension data...             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h3 id="one-byte-extension-format-rfc-5285"><a class="header" href="#one-byte-extension-format-rfc-5285">One-Byte Extension Format (RFC 5285)</a></h3>
<pre><code> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  ID   |  len  |     data      |  ID   |  len  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>ID</strong> (4 bits): Extension identifier (1-14)</li>
<li><strong>len</strong> (4 bits): Length in bytes minus 1</li>
<li><strong>data</strong>: Extension payload</li>
</ul>
<h3 id="common-rtp-extensions"><a class="header" href="#common-rtp-extensions">Common RTP Extensions</a></h3>
<h4 id="1-audio-level-rfc-6464"><a class="header" href="#1-audio-level-rfc-6464">1. Audio Level (RFC 6464)</a></h4>
<p>Indicates audio level in packet:</p>
<pre><code> 0                   1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  ID   | len=0 |V| level       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>V</strong>: Voice activity (1 = speech, 0 = silence)</li>
<li><strong>level</strong>: Audio level in -dBov (0-127)</li>
</ul>
<p><strong>Usage</strong>: UI indicators, voice activity detection</p>
<h4 id="2-video-orientation-cvo"><a class="header" href="#2-video-orientation-cvo">2. Video Orientation (CVO)</a></h4>
<p>Indicates camera rotation:</p>
<pre><code>Extension data: 0 0 0 R R R 0 0
RRR = rotation (0=0°, 1=90°, 2=180°, 3=270°)
</code></pre>
<p><strong>Usage</strong>: Correctly rotate video on receiver</p>
<h4 id="3-transmission-time-offset"><a class="header" href="#3-transmission-time-offset">3. Transmission Time Offset</a></h4>
<p>Difference between capture and transmission time:</p>
<pre><code>Extension data: 24-bit signed offset
</code></pre>
<p><strong>Usage</strong>: Improves jitter calculation, synchronization</p>
<h4 id="4-absolute-send-time"><a class="header" href="#4-absolute-send-time">4. Absolute Send Time</a></h4>
<p>Timestamp when packet was sent (NTP format):</p>
<pre><code>Extension data: 24 bits of NTP timestamp
</code></pre>
<p><strong>Usage</strong>: More accurate RTT measurements</p>
<h3 id="example-parsing-audio-level-extension"><a class="header" href="#example-parsing-audio-level-extension">Example: Parsing Audio Level Extension</a></h3>
<pre><code class="language-python">def parse_audio_level_extension(extension_data):
    """Parse audio level extension (RFC 6464)"""
    if len(extension_data) &lt; 1:
        return None

    byte = extension_data[0]
    voice_activity = (byte &amp; 0x80) &gt;&gt; 7
    level_dbov = byte &amp; 0x7F

    # Convert to human-readable
    level_db = -level_dbov  # Negative dBov

    return {
        'voice_activity': bool(voice_activity),
        'level_dbov': level_dbov,
        'level_db': level_db
    }

# Example
ext_data = bytes([0x85])  # V=1, level=5
result = parse_audio_level_extension(ext_data)
# {'voice_activity': True, 'level_dbov': 5, 'level_db': -5}
</code></pre>
<hr>
<h2 id="security-srtp"><a class="header" href="#security-srtp">Security: SRTP</a></h2>
<p><strong>SRTP (Secure RTP)</strong> adds encryption and authentication to RTP. Defined in RFC 3711.</p>
<h3 id="why-srtp"><a class="header" href="#why-srtp">Why SRTP?</a></h3>
<p>Plain RTP has no security:</p>
<ul>
<li><strong>Eavesdropping</strong>: Anyone can capture and decode packets</li>
<li><strong>Tampering</strong>: Packets can be modified in transit</li>
<li><strong>Replay</strong>: Old packets can be re-sent</li>
<li><strong>Injection</strong>: Fake packets can be inserted</li>
</ul>
<p>SRTP provides:</p>
<ul>
<li><strong>Confidentiality</strong>: AES encryption</li>
<li><strong>Authentication</strong>: HMAC integrity check</li>
<li><strong>Replay Protection</strong>: Sequence/timestamp verification</li>
</ul>
<h3 id="srtp-packet-format"><a class="header" href="#srtp-packet-format">SRTP Packet Format</a></h3>
<pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     RTP Header (unencrypted)                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Encrypted Payload (AES)                       |
|                          ...                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Authentication Tag (HMAC)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>RTP header remains <strong>unencrypted</strong> (needed for routing)</li>
<li>Payload is <strong>encrypted</strong> with AES</li>
<li>Authentication tag protects header + encrypted payload</li>
<li>Typically adds 10-16 bytes overhead (auth tag)</li>
</ul>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<p><strong>Algorithm</strong>: AES in Counter Mode (AES-CTR)</p>
<ul>
<li><strong>AES-128</strong>: 128-bit keys (default)</li>
<li><strong>AES-256</strong>: 256-bit keys (higher security)</li>
</ul>
<p><strong>Why Counter Mode?</strong></p>
<ul>
<li>Stream cipher (can encrypt arbitrary lengths)</li>
<li>No padding needed</li>
<li>Parallel encryption/decryption</li>
<li>Same encryption key for all packets (with unique IV)</li>
</ul>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p><strong>Algorithm</strong>: HMAC-SHA1</p>
<ul>
<li><strong>Tag length</strong>: 80 bits (default) or 32 bits</li>
<li>Protects against tampering</li>
</ul>
<p><strong>What’s authenticated:</strong></p>
<ul>
<li>RTP header</li>
<li>Encrypted payload</li>
<li>Prevents modification without detection</li>
</ul>
<h3 id="key-derivation"><a class="header" href="#key-derivation">Key Derivation</a></h3>
<p>SRTP doesn’t use keys directly. Instead:</p>
<pre><code>Master Key (128 or 256 bits)
Master Salt (112 bits)
    
Key Derivation Function (KDF)
    
Encryption Key, Auth Key, Salting Key
</code></pre>
<p><strong>Separate keys for:</strong></p>
<ul>
<li>RTP encryption</li>
<li>RTP authentication</li>
<li>RTCP encryption</li>
<li>RTCP authentication</li>
</ul>
<h3 id="key-exchange-dtls-srtp-webrtc"><a class="header" href="#key-exchange-dtls-srtp-webrtc">Key Exchange: DTLS-SRTP (WebRTC)</a></h3>
<p><strong>DTLS-SRTP</strong> is the modern approach (used by WebRTC):</p>
<pre><code>1. DTLS Handshake (over UDP)
   - Certificate exchange
   - Verify fingerprints (from SDP)

2. DTLS derives SRTP keys
   - Master key
   - Master salt

3. Switch to SRTP/SRTCP
   - Use derived keys
   - DTLS only for re-keying
</code></pre>
<p><strong>SDP Example:</strong></p>
<pre><code>a=fingerprint:sha-256 AA:BB:CC:...
a=setup:actpass
a=ice-ufrag:abc123
a=ice-pwd:xyz789
</code></pre>
<h3 id="alternative-sdes-sdp-security-descriptions"><a class="header" href="#alternative-sdes-sdp-security-descriptions">Alternative: SDES (SDP Security Descriptions)</a></h3>
<p><strong>Older approach</strong>: Keys in SDP</p>
<pre><code>a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:WVNfX19zZ...
</code></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>Keys in plaintext SDP (must secure signaling)</li>
<li>No perfect forward secrecy</li>
<li>Deprecated in WebRTC (use DTLS-SRTP instead)</li>
</ul>
<h3 id="python-srtp-example-conceptual"><a class="header" href="#python-srtp-example-conceptual">Python SRTP Example (Conceptual)</a></h3>
<pre><code class="language-python">from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import hmac
import hashlib

class SRTPEncryptor:
    def __init__(self, master_key, master_salt):
        self.master_key = master_key
        self.master_salt = master_salt

        # Derive keys (simplified)
        self.enc_key = self._derive_key(0x00, 16)
        self.auth_key = self._derive_key(0x01, 20)
        self.salt_key = self._derive_key(0x02, 14)

    def _derive_key(self, label, length):
        """Simplified key derivation"""
        # Real implementation uses proper KDF (RFC 3711)
        data = self.master_key + bytes([label]) + self.master_salt
        return hashlib.sha256(data).digest()[:length]

    def encrypt_rtp(self, rtp_packet):
        """Encrypt RTP packet"""
        # Parse RTP header (first 12 bytes)
        header = rtp_packet[:12]
        payload = rtp_packet[12:]

        # Extract SSRC and sequence for IV
        ssrc = int.from_bytes(header[8:12], 'big')
        seq = int.from_bytes(header[2:4], 'big')

        # Construct IV (SSRC || packet index)
        iv = ssrc.to_bytes(4, 'big') + seq.to_bytes(8, 'big')
        iv = bytes([a ^ b for a, b in zip(iv, self.salt_key)])

        # Encrypt payload with AES-CTR
        cipher = Cipher(
            algorithms.AES(self.enc_key),
            modes.CTR(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        encrypted_payload = encryptor.update(payload) + encryptor.finalize()

        # Compute authentication tag
        auth_data = header + encrypted_payload
        tag = hmac.new(self.auth_key, auth_data, hashlib.sha1).digest()[:10]

        # Return SRTP packet
        return header + encrypted_payload + tag

# Usage
master_key = b'sixteen byte key'
master_salt = b'fourteen byte!!'
encryptor = SRTPEncryptor(master_key, master_salt)

# Encrypt RTP packet
srtp_packet = encryptor.encrypt_rtp(rtp_packet)
</code></pre>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ol>
<li><strong>Always use SRTP</strong> for real-world applications</li>
<li><strong>Use DTLS-SRTP</strong> (not SDES) for key exchange</li>
<li><strong>Verify fingerprints</strong> out-of-band if possible</li>
<li><strong>Re-key periodically</strong> (after ~2^48 packets for AES-128)</li>
<li><strong>Use strong master keys</strong> (cryptographically random)</li>
<li><strong>Protect signaling channel</strong> (HTTPS for SDP exchange)</li>
</ol>
<hr>
<h2 id="integration-with-other-protocols"><a class="header" href="#integration-with-other-protocols">Integration with Other Protocols</a></h2>
<p>RTP rarely works alone. It integrates with signaling and transport protocols.</p>
<h3 id="sdp-session-description-protocol"><a class="header" href="#sdp-session-description-protocol">SDP (Session Description Protocol)</a></h3>
<p><strong>SDP</strong> describes media sessions. Used with SIP, WebRTC, etc.</p>
<p><strong>Basic Structure:</strong></p>
<pre><code>v=0                                    # Version
o=alice 123456 123456 IN IP4 192.168.1.100  # Origin
s=Audio/Video Call                     # Session name
c=IN IP4 192.168.1.100                 # Connection info
t=0 0                                   # Time (0 0 = permanent)

m=audio 5004 RTP/SAVPF 111 0           # Media description
a=rtpmap:111 opus/48000/2              # Payload mapping
a=fmtp:111 minptime=10;useinbandfec=1  # Format parameters
a=rtpmap:0 PCMU/8000                   # Fallback codec

m=video 5006 RTP/SAVPF 96 97           # Video media
a=rtpmap:96 VP8/90000                  # VP8 codec
a=rtpmap:97 H264/90000                 # H.264 codec
a=fmtp:97 profile-level-id=42e01f      # H.264 profile
</code></pre>
<p><strong>Key Fields:</strong></p>
<ul>
<li><code>m=</code>: Media line (type, port, protocol, payload types)</li>
<li><code>a=rtpmap</code>: Maps PT to codec/clock rate</li>
<li><code>a=fmtp</code>: Format-specific parameters</li>
<li><code>RTP/SAVPF</code>: Secure RTP with feedback</li>
</ul>
<h3 id="webrtc"><a class="header" href="#webrtc">WebRTC</a></h3>
<p><strong>WebRTC</strong> is the biggest user of RTP today. Architecture:</p>
<pre><code>Application (JavaScript)
        
   WebRTC API
        
                 
  Signaling       (SDP offer/answer)
                 $
  ICE             (NAT traversal)
                 $
  DTLS            (Key exchange)
                 $
  SRTP/SRTCP      (Media transport)  RTP here
                 $
  SCTP            (Data channels)
                 
        
      UDP
</code></pre>
<p><strong>RTP in WebRTC:</strong></p>
<ul>
<li>Always uses SRTP (encryption mandatory)</li>
<li>DTLS-SRTP for key exchange</li>
<li>ICE for NAT traversal</li>
<li>Multiplexes RTP/RTCP on same port</li>
<li>Bundle: audio + video on same port</li>
</ul>
<p><strong>Example WebRTC Session Establishment:</strong></p>
<pre><code class="language-javascript">// Create peer connection
const pc = new RTCPeerConnection({
    iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
});

// Add media tracks
const stream = await navigator.mediaDevices.getUserMedia({
    audio: true,
    video: true
});
stream.getTracks().forEach(track =&gt; pc.addTrack(track, stream));

// Create offer (generates SDP)
const offer = await pc.createOffer();
await pc.setLocalDescription(offer);

// Send offer SDP to remote peer via signaling
// (WebSocket, HTTP, etc.)
signalingChannel.send({type: 'offer', sdp: offer.sdp});

// Receive answer from remote
signalingChannel.on('answer', async (answer) =&gt; {
    await pc.setRemoteDescription(answer);
    // ICE negotiation, DTLS handshake, then RTP flows!
});
</code></pre>
<p><strong>Generated SDP (simplified):</strong></p>
<pre><code>v=0
m=audio 9 UDP/TLS/RTP/SAVPF 111
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10;useinbandfec=1
a=rtcp-mux                              # RTP and RTCP multiplexed
a=setup:actpass
a=fingerprint:sha-256 AA:BB:CC:...      # DTLS cert fingerprint
a=ice-ufrag:xyz
a=ice-pwd:abc123
a=ssrc:123456789 cname:user@host        # RTP SSRC

m=video 9 UDP/TLS/RTP/SAVPF 96
a=rtpmap:96 VP8/90000
a=rtcp-fb:96 nack                       # NACK support
a=rtcp-fb:96 nack pli                   # Picture Loss Indication
a=rtcp-fb:96 goog-remb                  # Bandwidth estimation
</code></pre>
<h3 id="sip-session-initiation-protocol"><a class="header" href="#sip-session-initiation-protocol">SIP (Session Initiation Protocol)</a></h3>
<p><strong>SIP</strong> is used for VoIP calls. SIP handles signaling, RTP carries media.</p>
<p><strong>Call Flow:</strong></p>
<pre><code>Alice                    SIP Server                    Bob
  |                          |                          |
  |--- INVITE (SDP offer) --&gt;|                          |
  |                          |--- INVITE (SDP) --------&gt;|
  |                          |&lt;-- 180 Ringing ----------|
  |&lt;-- 180 Ringing ----------|                          |
  |                          |&lt;-- 200 OK (SDP answer) --|
  |&lt;-- 200 OK (SDP) ---------|                          |
  |--- ACK -----------------&gt;|--- ACK -----------------&gt;|
  |                          |                          |
  |&lt;=============== RTP Audio Stream ==================&gt;|
  |                          |                          |
  |--- BYE -----------------&gt;|--- BYE -----------------&gt;|
  |&lt;-- 200 OK ---------------|&lt;-- 200 OK ---------------|
</code></pre>
<p><strong>SIP INVITE with SDP:</strong></p>
<pre><code>INVITE sip:bob@example.com SIP/2.0
Via: SIP/2.0/UDP alice-phone.example.com
From: Alice &lt;sip:alice@example.com&gt;
To: Bob &lt;sip:bob@example.com&gt;
Content-Type: application/sdp

v=0
o=alice 123456 123456 IN IP4 192.168.1.100
s=VoIP Call
c=IN IP4 192.168.1.100
t=0 0
m=audio 5004 RTP/AVP 0 8 111
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:111 opus/48000/2
</code></pre>
<p>After SIP negotiation, RTP flows directly peer-to-peer (or via media server).</p>
<h3 id="multicast-rtp"><a class="header" href="#multicast-rtp">Multicast RTP</a></h3>
<p>RTP supports IP multicast for efficient one-to-many delivery:</p>
<pre><code>Sender
  |
  | RTP to 239.1.2.3:5004
  |
    &gt; Receiver 1
    &gt; Receiver 2
    &gt; Receiver 3
    &gt; Receiver N
</code></pre>
<p><strong>Challenges:</strong></p>
<ul>
<li>SSRC collision detection (multiple senders)</li>
<li>Scalable RTCP (report interval increases with receivers)</li>
<li>Network must support multicast (IGMP)</li>
</ul>
<p><strong>RTCP in Multicast:</strong></p>
<ul>
<li>Report interval adapts to group size</li>
<li>Prevents RTCP implosion</li>
<li>BW_rtcp = 0.05 * BW_session / num_participants</li>
</ul>
<hr>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="1-voip-phone-call"><a class="header" href="#1-voip-phone-call">1. VoIP Phone Call</a></h3>
<p><strong>Architecture:</strong></p>
<pre><code>Phone A                               Phone B
  |                                     |
  |-- SIP INVITE (with SDP) -----------&gt;|
  |&lt;- SIP 200 OK (with SDP) ------------|
  |                                     |
  |&lt;======= RTP Audio (G.711) =========&gt;|
  |&lt;======= RTCP Reports ===============|
  |                                     |
  |-- SIP BYE -------------------------&gt;|
</code></pre>
<p><strong>Typical Setup:</strong></p>
<ul>
<li><strong>Codec</strong>: G.711 (PCMU/PCMA) or Opus</li>
<li><strong>Packet size</strong>: 20ms audio (160 bytes for G.711)</li>
<li><strong>Bandwidth</strong>: ~64 kbps for G.711, ~32 kbps for Opus</li>
<li><strong>Latency target</strong>: &lt; 150ms end-to-end</li>
<li><strong>Loss tolerance</strong>: Up to 3%</li>
</ul>
<p><strong>Code Example:</strong></p>
<pre><code class="language-python"># VoIP call parameters
SAMPLE_RATE = 8000  # 8kHz for G.711
PACKET_DURATION = 0.020  # 20ms
SAMPLES_PER_PACKET = int(SAMPLE_RATE * PACKET_DURATION)  # 160

# Send audio packets
def send_voip_audio(sender, audio_stream):
    for audio_chunk in audio_stream:
        # Encode with G.711 (μ-law)
        encoded = g711_ulaw_encode(audio_chunk)

        # Send RTP packet (PT=0 for PCMU)
        sender.send_packet(
            payload=encoded,
            marker=False,
            timestamp_increment=SAMPLES_PER_PACKET
        )

        time.sleep(PACKET_DURATION)
</code></pre>
<h3 id="2-video-streaming"><a class="header" href="#2-video-streaming">2. Video Streaming</a></h3>
<p><strong>Architecture:</strong></p>
<pre><code>Streamer                             Viewer
  Camera                               Display
                                        
  H.264 Encoder                    H.264 Decoder
                                        
  RTP Packetizer                  RTP Depacketizer
                                        
  |=========== RTP/UDP/IP =============|
</code></pre>
<p><strong>Typical Setup:</strong></p>
<ul>
<li><strong>Codec</strong>: H.264 or VP8</li>
<li><strong>Resolution</strong>: 720p or 1080p</li>
<li><strong>Frame rate</strong>: 30 fps</li>
<li><strong>Bitrate</strong>: 2-5 Mbps (adaptive)</li>
<li><strong>Latency target</strong>: 200-500ms (buffering)</li>
<li><strong>Loss tolerance</strong>: 0.5-2% (FEC helps)</li>
</ul>
<p><strong>Challenges:</strong></p>
<ul>
<li><strong>Large frames</strong>: Need fragmentation (FU-A for H.264)</li>
<li><strong>Keyframes</strong>: Must arrive intact (or wait for next)</li>
<li><strong>Bitrate adaptation</strong>: Adjust to network conditions</li>
</ul>
<p><strong>Example: H.264 Fragmentation</strong></p>
<pre><code class="language-python">def fragment_h264_frame(frame_data, mtu=1400):
    """Fragment large H.264 frame into RTP packets"""
    max_payload = mtu - 12  # Account for RTP header

    if len(frame_data) &lt;= max_payload:
        # Small frame - single NAL unit
        return [frame_data]

    # Large frame - use FU-A fragmentation
    fragments = []
    nal_header = frame_data[0]
    nal_payload = frame_data[1:]

    fu_indicator = (nal_header &amp; 0xE0) | 28  # Type = FU-A

    offset = 0
    first = True
    while offset &lt; len(nal_payload):
        chunk_size = min(max_payload - 2, len(nal_payload) - offset)
        chunk = nal_payload[offset:offset + chunk_size]

        # FU header
        fu_header = (nal_header &amp; 0x1F)
        if first:
            fu_header |= 0x80  # Start bit
            first = False
        if offset + chunk_size &gt;= len(nal_payload):
            fu_header |= 0x40  # End bit

        fragment = bytes([fu_indicator, fu_header]) + chunk
        fragments.append(fragment)

        offset += chunk_size

    return fragments
</code></pre>
<h3 id="3-video-conferencing"><a class="header" href="#3-video-conferencing">3. Video Conferencing</a></h3>
<p><strong>Architecture:</strong></p>
<pre><code>Participant A                 MCU/SFU                 Participant B
     |                          |                          |
     |-- RTP (audio+video) ----&gt;|                          |
     |                          |&lt;-- RTP (audio+video) ----|
     |&lt;-- RTP (mixed) ----------|                          |
     |                          |-- RTP (mixed) ----------&gt;|
</code></pre>
<p><strong>Two Approaches:</strong></p>
<h4 id="mcu-multipoint-control-unit"><a class="header" href="#mcu-multipoint-control-unit">MCU (Multipoint Control Unit)</a></h4>
<ul>
<li>Mixes all streams into one</li>
<li>Low bandwidth for participants</li>
<li>Higher server load</li>
<li>Transcoding required</li>
</ul>
<h4 id="sfu-selective-forwarding-unit"><a class="header" href="#sfu-selective-forwarding-unit">SFU (Selective Forwarding Unit)</a></h4>
<ul>
<li>Forwards streams without mixing</li>
<li>Higher bandwidth for participants</li>
<li>Lower server load</li>
<li>No transcoding (just routing)</li>
</ul>
<p><strong>Simulcast</strong> (used in modern conferencing):</p>
<pre><code>Sender encodes 3 versions:
  - 1080p high quality
  - 720p medium quality
  - 360p low quality

SFU selects appropriate version for each receiver
based on their bandwidth/screen size
</code></pre>
<p><strong>Code: Detect Active Speaker (via audio level extension)</strong></p>
<pre><code class="language-python">def detect_active_speaker(participants):
    """Detect active speaker based on audio levels"""
    max_level = -127
    active_speaker = None

    for participant in participants:
        # Parse audio level extension from recent packets
        level = participant.get_average_audio_level()

        if level &gt; max_level and level &gt; -40:  # -40dBov threshold
            max_level = level
            active_speaker = participant

    return active_speaker
</code></pre>
<h3 id="4-screen-sharing"><a class="header" href="#4-screen-sharing">4. Screen Sharing</a></h3>
<p><strong>Characteristics:</strong></p>
<ul>
<li><strong>High resolution</strong>: 1920x1080 or higher</li>
<li><strong>Variable frame rate</strong>: 1-30 fps (based on activity)</li>
<li><strong>Content type</strong>: Text, images, video</li>
<li><strong>Compression</strong>: Screen content codecs (H.264 Screen Content Coding)</li>
</ul>
<p><strong>Optimization:</strong></p>
<pre><code class="language-python">def adaptive_screen_sharing(encoder, screen_capturer):
    """Adapt frame rate based on screen activity"""
    last_frame = None
    static_count = 0

    while True:
        frame = screen_capturer.capture()

        # Detect if screen changed
        if frame == last_frame:
            static_count += 1
        else:
            static_count = 0

        # Adaptive frame rate
        if static_count &gt; 5:
            # Screen static - send at low rate (1 fps)
            time.sleep(1.0)
        else:
            # Screen changing - send at high rate (15 fps)
            time.sleep(1.0 / 15)

        # Encode and send
        encoded = encoder.encode(frame)
        send_rtp_video(encoded)

        last_frame = frame
</code></pre>
<h3 id="5-gaming-voice-chat"><a class="header" href="#5-gaming-voice-chat">5. Gaming Voice Chat</a></h3>
<p><strong>Requirements:</strong></p>
<ul>
<li><strong>Ultra-low latency</strong>: &lt; 50ms target</li>
<li><strong>Small packets</strong>: 10-20ms audio</li>
<li><strong>Opus codec</strong>: Best quality/latency trade-off</li>
<li><strong>Minimal jitter buffer</strong>: 20-40ms</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-python"># Gaming VoIP optimized settings
opus_encoder = OpusEncoder(
    sample_rate=48000,
    channels=1,  # Mono sufficient for voice
    application=OPUS_APPLICATION_VOIP,
    bitrate=24000,  # 24 kbps
    frame_duration=10  # 10ms frames for low latency
)

# Minimal jitter buffer
jitter_buffer = JitterBuffer(
    min_delay_ms=20,
    max_delay_ms=60,
    target_delay_ms=30
)
</code></pre>
<hr>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="simulcast"><a class="header" href="#simulcast">Simulcast</a></h3>
<p><strong>Simulcast</strong>: Sending multiple encodings of same source simultaneously.</p>
<p><strong>Use case</strong>: Video conferencing where receivers have different bandwidth/screen sizes.</p>
<pre><code>Encoder produces 3 streams:
  SSRC 1: 1080p @ 2.5 Mbps  (high)
  SSRC 2: 720p  @ 1.0 Mbps  (medium)
  SSRC 3: 360p  @ 0.3 Mbps  (low)

SFU routes appropriate stream to each receiver:
  Desktop with good connection  high
  Mobile with poor connection   low
</code></pre>
<p><strong>SDP Signaling:</strong></p>
<pre><code>m=video 9 UDP/TLS/RTP/SAVPF 96
a=rtpmap:96 VP8/90000
a=ssrc-group:SIM 11111111 22222222 33333333
a=ssrc:11111111 cname:user@host
a=ssrc:22222222 cname:user@host
a=ssrc:33333333 cname:user@host
</code></pre>
<h3 id="svc-scalable-video-coding"><a class="header" href="#svc-scalable-video-coding">SVC (Scalable Video Coding)</a></h3>
<p><strong>SVC</strong>: Single encoded stream with multiple quality layers.</p>
<pre><code>Base layer: 360p
Enhancement layer 1: +360p  720p
Enhancement layer 2: +720p  1080p

Receiver can decode:
  - Base only  360p
  - Base + EL1  720p
  - Base + EL1 + EL2  1080p
</code></pre>
<p><strong>Advantages over Simulcast:</strong></p>
<ul>
<li>Lower encoding complexity</li>
<li>Bandwidth efficiency</li>
<li>Smoother quality adaptation</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Less codec support</li>
<li>More complex decoder</li>
</ul>
<h3 id="rtp-mixer"><a class="header" href="#rtp-mixer">RTP Mixer</a></h3>
<p><strong>Mixer</strong>: Combines multiple RTP streams into one.</p>
<pre><code>Input:
  SSRC A: Audio from participant A
  SSRC B: Audio from participant B
  SSRC C: Audio from participant C

Mixer:
  1. Decode all streams
  2. Mix audio (add samples)
  3. Encode mixed audio
  4. Send as new stream

Output:
  SSRC M: Mixed audio
  CSRC list: [A, B, C]  (who contributed)
</code></pre>
<p><strong>Use case</strong>: Audio conferencing with many participants.</p>
<h3 id="rtp-translator"><a class="header" href="#rtp-translator">RTP Translator</a></h3>
<p><strong>Translator</strong>: Forwards RTP packets between networks.</p>
<pre><code>Internal Network    Translator    External Network

Functions:
- NAT traversal
- Protocol conversion (RTP  RTP/RTCP mux)
- Transcoding (optional)
</code></pre>
<h3 id="bandwidth-estimation"><a class="header" href="#bandwidth-estimation">Bandwidth Estimation</a></h3>
<p>Modern RTP implementations adapt sending bitrate:</p>
<p><strong>Approaches:</strong></p>
<ol>
<li><strong>RTCP Feedback</strong> (Loss-based):</li>
</ol>
<pre><code class="language-python">def adjust_bitrate_on_loss(current_bitrate, loss_rate):
    if loss_rate &gt; 0.05:  # &gt; 5% loss
        return current_bitrate * 0.85  # Reduce 15%
    elif loss_rate &lt; 0.01:  # &lt; 1% loss
        return current_bitrate * 1.05  # Increase 5%
    return current_bitrate
</code></pre>
<ol start="2">
<li><strong>REMB (Receiver Estimated Maximum Bitrate)</strong>:</li>
</ol>
<ul>
<li>Receiver measures available bandwidth</li>
<li>Sends RTCP REMB message</li>
<li>Sender adjusts bitrate accordingly</li>
</ul>
<ol start="3">
<li><strong>Transport-CC (Transport-Wide Congestion Control)</strong>:</li>
</ol>
<ul>
<li>Fine-grained feedback on every packet</li>
<li>Uses receive timestamps</li>
<li>ML-based bandwidth estimation</li>
</ul>
<p><strong>SDP:</strong></p>
<pre><code>a=rtcp-fb:96 goog-remb
a=rtcp-fb:96 transport-cc
</code></pre>
<h3 id="ntp-synchronization"><a class="header" href="#ntp-synchronization">NTP Synchronization</a></h3>
<p>For multi-stream sync (lip-sync):</p>
<pre><code class="language-python">import ntplib
from time import time

def get_ntp_time():
    """Get current time in NTP format"""
    client = ntplib.NTPClient()
    response = client.request('pool.ntp.org')
    return response.tx_time  # NTP timestamp

def create_rtcp_sr(rtp_timestamp, ntp_time):
    """Create RTCP Sender Report with NTP correlation"""
    # NTP format: seconds since 1900-01-01
    # Split into 32-bit integer and fraction
    ntp_sec = int(ntp_time)
    ntp_frac = int((ntp_time - ntp_sec) * 2**32)

    sr_packet = struct.pack(
        '!HHIIIII',
        0x80C8,           # V=2, PT=SR(200)
        6,                # Length
        ssrc,             # SSRC
        ntp_sec,          # NTP timestamp (MSW)
        ntp_frac,         # NTP timestamp (LSW)
        rtp_timestamp,    # RTP timestamp
        packet_count,     # Sender's packet count
        octet_count       # Sender's octet count
    )
    return sr_packet
</code></pre>
<p><strong>Receiver uses NTP correlation:</strong></p>
<pre><code>Audio SR: NTP=12345.500, RTP=48000
Video SR: NTP=12345.500, RTP=90000

Both streams aligned to same NTP time
 Perfect lip-sync
</code></pre>
<hr>
<h2 id="monitoring-and-debugging"><a class="header" href="#monitoring-and-debugging">Monitoring and Debugging</a></h2>
<h3 id="wireshark-analysis"><a class="header" href="#wireshark-analysis">Wireshark Analysis</a></h3>
<p><strong>Capture RTP traffic:</strong></p>
<pre><code class="language-bash"># Capture on specific port
tcpdump -i eth0 -w rtp_capture.pcap udp port 5004

# Open in Wireshark
wireshark rtp_capture.pcap
</code></pre>
<p><strong>Wireshark RTP Filters:</strong></p>
<pre><code>rtp                          # All RTP packets
rtp.ssrc == 0x12345678       # Specific SSRC
rtp.p_type == 96             # Specific payload type
rtp.marker == 1              # Packets with marker bit
rtp.seq &gt; 1000 &amp;&amp; rtp.seq &lt; 1100  # Sequence range
</code></pre>
<p><strong>RTP Stream Analysis:</strong></p>
<ol>
<li><strong>Telephony</strong>  <strong>RTP</strong>  <strong>RTP Streams</strong></li>
<li>Select stream  <strong>Analyze</strong></li>
</ol>
<p><strong>Metrics shown:</strong></p>
<ul>
<li>Packet count</li>
<li>Lost packets and percentage</li>
<li>Maximum delta (jitter)</li>
<li>Maximum jitter</li>
<li>Mean jitter</li>
<li>Clock drift</li>
</ul>
<p><strong>Stream Player:</strong></p>
<ol>
<li><strong>Telephony</strong>  <strong>RTP</strong>  <strong>RTP Streams</strong></li>
<li>Select audio stream  <strong>Play Streams</strong></li>
<li>Listen to decoded audio</li>
</ol>
<p><strong>Packet Details:</strong></p>
<pre><code>Real-Time Transport Protocol
    Version: 2
    Padding: False
    Extension: False
    CSRC count: 0
    Marker: False
    Payload type: Opus (96)
    Sequence number: 1234
    Timestamp: 48000
    Synchronization Source identifier: 0xABCD1234 (2882400052)
    Payload: 40 bytes
</code></pre>
<h3 id="command-line-tools"><a class="header" href="#command-line-tools">Command-Line Tools</a></h3>
<h4 id="tcpdump-rtp-filtering"><a class="header" href="#tcpdump-rtp-filtering">tcpdump RTP Filtering</a></h4>
<pre><code class="language-bash"># Capture RTP on even ports (convention)
tcpdump -i eth0 'udp[1] &amp; 1 == 0 &amp;&amp; udp[8] &amp; 0xC0 == 0x80'

# Explanation:
# udp[1] &amp; 1 == 0    Even destination port
# udp[8] &amp; 0xC0 == 0x80    RTP version 2
</code></pre>
<h4 id="ffmpeg-with-rtp"><a class="header" href="#ffmpeg-with-rtp">ffmpeg with RTP</a></h4>
<p><strong>Send video via RTP:</strong></p>
<pre><code class="language-bash"># Stream video file via RTP
ffmpeg -re -i input.mp4 \
  -c:v libvpx -b:v 1M \
  -f rtp rtp://192.168.1.100:5004

# Generate SDP file for receiver
ffmpeg -re -i input.mp4 \
  -c:v libvpx -b:v 1M \
  -f rtp rtp://192.168.1.100:5004 \
  &gt; stream.sdp
</code></pre>
<p><strong>Receive video via RTP:</strong></p>
<pre><code class="language-bash"># Receive using SDP file
ffplay -protocol_whitelist file,rtp,udp stream.sdp

# Or specify directly
ffplay -protocol_whitelist rtp,udp \
  -i rtp://0.0.0.0:5004
</code></pre>
<h4 id="gstreamer-rtp-pipelines"><a class="header" href="#gstreamer-rtp-pipelines">GStreamer RTP Pipelines</a></h4>
<p><strong>Send audio:</strong></p>
<pre><code class="language-bash">gst-launch-1.0 \
  audiotestsrc ! \
  opusenc ! \
  rtpopuspay ! \
  udpsink host=192.168.1.100 port=5004
</code></pre>
<p><strong>Receive audio:</strong></p>
<pre><code class="language-bash">gst-launch-1.0 \
  udpsrc port=5004 caps="application/x-rtp" ! \
  rtpopusdepay ! \
  opusdec ! \
  autoaudiosink
</code></pre>
<p><strong>Send video:</strong></p>
<pre><code class="language-bash">gst-launch-1.0 \
  videotestsrc ! \
  x264enc ! \
  rtph264pay ! \
  udpsink host=192.168.1.100 port=5006
</code></pre>
<h3 id="rtp-statistics-monitoring"><a class="header" href="#rtp-statistics-monitoring">RTP Statistics Monitoring</a></h3>
<pre><code class="language-python">class RTPStatistics:
    def __init__(self):
        self.packets_received = 0
        self.packets_lost = 0
        self.bytes_received = 0
        self.last_seq = None
        self.highest_seq = 0

        # For jitter calculation
        self.jitter = 0.0
        self.last_arrival = None
        self.last_timestamp = None

    def update(self, rtp_packet):
        seq = rtp_packet['sequence']
        ts = rtp_packet['timestamp']
        arrival_time = time.time()

        # Packet count
        self.packets_received += 1
        self.bytes_received += len(rtp_packet['payload'])

        # Loss detection
        if self.last_seq is not None:
            expected = (self.last_seq + 1) &amp; 0xFFFF
            if seq != expected:
                loss = (seq - expected) &amp; 0xFFFF
                self.packets_lost += loss

        self.last_seq = seq
        self.highest_seq = max(self.highest_seq, seq)

        # Jitter calculation (RFC 3550)
        if self.last_arrival and self.last_timestamp:
            D = abs((arrival_time - self.last_arrival) -
                   ((ts - self.last_timestamp) / 48000.0))
            self.jitter = self.jitter + (D - self.jitter) / 16.0

        self.last_arrival = arrival_time
        self.last_timestamp = ts

    def get_report(self):
        total_expected = self.packets_received + self.packets_lost
        loss_rate = self.packets_lost / total_expected if total_expected &gt; 0 else 0

        return {
            'packets_received': self.packets_received,
            'packets_lost': self.packets_lost,
            'loss_rate': loss_rate * 100,
            'bytes_received': self.bytes_received,
            'jitter_ms': self.jitter * 1000,
            'highest_seq': self.highest_seq
        }

# Usage
stats = RTPStatistics()
for packet in rtp_stream:
    stats.update(packet)

report = stats.get_report()
print(f"Loss: {report['loss_rate']:.2f}%, Jitter: {report['jitter_ms']:.1f}ms")
</code></pre>
<hr>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<h4 id="1-no-audiovideo"><a class="header" href="#1-no-audiovideo">1. No Audio/Video</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Packets not arriving</li>
<li>Silent audio, blank video</li>
</ul>
<p><strong>Debugging:</strong></p>
<pre><code class="language-bash"># Check if packets arriving
tcpdump -i eth0 -n udp port 5004

# Check firewall
sudo iptables -L -n -v | grep 5004

# Check listening processes
sudo netstat -ulnp | grep 5004
</code></pre>
<p><strong>Common causes:</strong></p>
<ul>
<li>Firewall blocking UDP ports</li>
<li>Wrong IP address or port</li>
<li>NAT issues (need STUN/TURN)</li>
<li>Codec mismatch (sender/receiver disagree)</li>
</ul>
<p><strong>Solutions:</strong></p>
<pre><code class="language-python"># Test with simple sender/receiver
# Sender:
sender = RTPSender('192.168.1.100', 5004)
sender.send_packet(b'test_data')

# Receiver:
receiver = RTPReceiver(5004)
packet = receiver.receive_packet()
print(f"Received: {packet}")
</code></pre>
<h4 id="2-one-way-audio"><a class="header" href="#2-one-way-audio">2. One-Way Audio</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Alice hears Bob, but Bob doesn’t hear Alice</li>
</ul>
<p><strong>Common causes:</strong></p>
<ul>
<li>Asymmetric NAT traversal</li>
<li>Firewall allows outbound but blocks inbound</li>
<li>Wrong IP in SDP (private vs public)</li>
</ul>
<p><strong>Debug with Wireshark:</strong></p>
<pre><code># Check if packets flowing both directions
rtp &amp;&amp; ip.addr == 192.168.1.100
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Use STUN to discover public IP</li>
<li>Use TURN relay if direct path blocked</li>
<li>Check SDP has correct IP addresses</li>
</ul>
<h4 id="3-choppygarbled-audio"><a class="header" href="#3-choppygarbled-audio">3. Choppy/Garbled Audio</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Audio cuts in and out</li>
<li>Robotic/distorted sound</li>
</ul>
<p><strong>Common causes:</strong></p>
<ul>
<li>High packet loss (&gt; 5%)</li>
<li>Excessive jitter</li>
<li>Buffer underruns</li>
<li>CPU overload</li>
</ul>
<p><strong>Debugging:</strong></p>
<pre><code class="language-python"># Monitor packet loss and jitter
stats = RTPStatistics()
while True:
    packet = receive_packet()
    stats.update(packet)

    if stats.packets_received % 100 == 0:
        report = stats.get_report()
        print(f"Loss: {report['loss_rate']:.1f}%, "
              f"Jitter: {report['jitter_ms']:.1f}ms")

        if report['loss_rate'] &gt; 5:
            print("WARNING: High packet loss!")
        if report['jitter_ms'] &gt; 50:
            print("WARNING: High jitter!")
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Increase jitter buffer size</li>
<li>Use FEC (Opus in-band FEC)</li>
<li>Reduce bitrate</li>
<li>Use packet loss concealment</li>
<li>Check network quality (QoS)</li>
</ul>
<h4 id="4-video-freezing"><a class="header" href="#4-video-freezing">4. Video Freezing</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Video pauses/freezes</li>
<li>Last frame stuck on screen</li>
</ul>
<p><strong>Common causes:</strong></p>
<ul>
<li>Keyframe loss (I-frame didn’t arrive)</li>
<li>Bandwidth too low</li>
<li>Packet reordering</li>
</ul>
<p><strong>Debugging:</strong></p>
<pre><code class="language-python">def detect_keyframe_loss(packets):
    """Detect if we lost a keyframe"""
    last_keyframe_seq = None

    for packet in packets:
        if is_keyframe(packet):
            if last_keyframe_seq is not None:
                gap = packet['sequence'] - last_keyframe_seq
                if gap &gt; 300:  # &gt; 10 seconds at 30fps
                    print(f"WARNING: Long gap between keyframes: {gap} packets")
            last_keyframe_seq = packet['sequence']
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Request keyframe (via RTCP PLI - Picture Loss Indication)</li>
<li>Increase keyframe frequency</li>
<li>Use RTX for keyframe retransmission</li>
<li>Implement error concealment (freeze-frame vs skip-to-next)</li>
</ul>
<h4 id="5-audiovideo-out-of-sync"><a class="header" href="#5-audiovideo-out-of-sync">5. Audio/Video Out of Sync</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Lips don’t match speech</li>
<li>Delay between audio and video</li>
</ul>
<p><strong>Common causes:</strong></p>
<ul>
<li>Different jitter buffer delays</li>
<li>Clock drift</li>
<li>Missing NTP synchronization</li>
</ul>
<p><strong>Debugging:</strong></p>
<pre><code class="language-python">def check_av_sync(audio_stats, video_stats):
    """Check if A/V streams are synchronized"""
    # Compare playout times based on NTP correlation
    audio_ntp = audio_stats['ntp_time']
    video_ntp = video_stats['ntp_time']

    sync_diff_ms = abs(audio_ntp - video_ntp) * 1000

    if sync_diff_ms &gt; 100:  # &gt; 100ms out of sync
        print(f"WARNING: A/V sync off by {sync_diff_ms:.0f}ms")
        return False
    return True
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Use RTCP Sender Reports for NTP correlation</li>
<li>Synchronize jitter buffer depths</li>
<li>Implement drift compensation</li>
<li>Use same clock source for both streams</li>
</ul>
<h3 id="diagnostic-commands"><a class="header" href="#diagnostic-commands">Diagnostic Commands</a></h3>
<pre><code class="language-bash"># Check RTP packet headers
tshark -i eth0 -Y rtp -T fields \
  -e rtp.ssrc -e rtp.seq -e rtp.timestamp -e rtp.p_type

# Calculate packet loss
tshark -i eth0 -Y rtp -T fields -e rtp.seq | \
  awk 'NR&gt;1 {diff=$1-prev; if(diff&gt;1) loss+=diff-1} {prev=$1} END {print "Lost:", loss}'

# Monitor jitter
tshark -i eth0 -Y rtcp -T fields -e rtcp.jitter

# Find SSRC collisions
tshark -i eth0 -Y rtp -T fields -e rtp.ssrc | sort | uniq -c
</code></pre>
<hr>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="codec-selection"><a class="header" href="#codec-selection">Codec Selection</a></h3>
<p>Choose codec based on requirements:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Requirement</th><th>Recommended Codec</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Voice quality</td><td>Opus @ 16-24 kbps</td><td>Best quality/bitrate</td></tr>
<tr><td>Low bandwidth</td><td>Opus @ 6-12 kbps</td><td>Efficient at low rates</td></tr>
<tr><td>Low latency</td><td>Opus @ 10ms frames</td><td>Lowest latency</td></tr>
<tr><td>Universal compat</td><td>G.711 (PCMU/PCMA)</td><td>Works everywhere</td></tr>
<tr><td>Music streaming</td><td>Opus @ 64-128 kbps</td><td>Excellent music quality</td></tr>
<tr><td>Video - universal</td><td>H.264</td><td>Widest support</td></tr>
<tr><td>Video - efficiency</td><td>VP9 or AV1</td><td>Better compression</td></tr>
<tr><td>Screen sharing</td><td>H.264 SCC</td><td>Optimized for text</td></tr>
</tbody>
</table>
</div>
<h3 id="jitter-buffer-tuning"><a class="header" href="#jitter-buffer-tuning">Jitter Buffer Tuning</a></h3>
<pre><code class="language-python"># Latency-critical (gaming, live calls)
JitterBuffer(
    min_delay_ms=10,
    max_delay_ms=50,
    target_delay_ms=20
)

# Quality-critical (music streaming)
JitterBuffer(
    min_delay_ms=50,
    max_delay_ms=300,
    target_delay_ms=150
)

# Balanced (video conferencing)
JitterBuffer(
    min_delay_ms=20,
    max_delay_ms=200,
    target_delay_ms=60
)
</code></pre>
<h3 id="packet-size-optimization"><a class="header" href="#packet-size-optimization">Packet Size Optimization</a></h3>
<pre><code class="language-python">def calculate_optimal_packet_size(codec, network_mtu):
    """Calculate optimal RTP packet size"""
    # Overhead: IP(20) + UDP(8) + RTP(12) = 40 bytes
    overhead = 40

    # Target: &lt; 1200 bytes to avoid fragmentation
    max_payload = min(network_mtu - overhead, 1200)

    if codec == 'opus':
        # Opus: 20ms frames @ 24kbps = ~60 bytes
        # Can fit in single packet
        return 60

    elif codec == 'h264':
        # H.264: Use MTU - overhead
        return max_payload

    elif codec == 'g711':
        # G.711: 20ms @ 64kbps = 160 bytes
        return 160
</code></pre>
<h3 id="bandwidth-management"><a class="header" href="#bandwidth-management">Bandwidth Management</a></h3>
<pre><code class="language-python">class BandwidthController:
    def __init__(self, target_bitrate_kbps):
        self.target_bitrate = target_bitrate_kbps * 1000
        self.current_bitrate = target_bitrate_kbps * 1000

    def adapt_to_loss(self, loss_rate):
        """Adapt bitrate based on packet loss"""
        if loss_rate &gt; 0.05:  # &gt; 5%
            self.current_bitrate *= 0.85  # Reduce 15%
        elif loss_rate &lt; 0.01 and self.current_bitrate &lt; self.target_bitrate:
            self.current_bitrate *= 1.05  # Increase 5%

        return int(self.current_bitrate)

    def adapt_to_rtt(self, rtt_ms):
        """Adapt to round-trip time"""
        if rtt_ms &gt; 300:  # High latency
            # Reduce bitrate to lower queuing delay
            self.current_bitrate *= 0.90

        return int(self.current_bitrate)
</code></pre>
<h3 id="network-qos"><a class="header" href="#network-qos">Network QoS</a></h3>
<pre><code class="language-bash"># Set DSCP for RTP packets (Linux)
# EF (Expedited Forwarding) for voice
iptables -t mangle -A OUTPUT -p udp --dport 5004 \
  -j DSCP --set-dscp 46

# AF41 for video
iptables -t mangle -A OUTPUT -p udp --dport 5006 \
  -j DSCP --set-dscp 34
</code></pre>
<p><strong>DSCP Values:</strong></p>
<ul>
<li><strong>EF (46)</strong>: Expedited Forwarding - VoIP</li>
<li><strong>AF41 (34)</strong>: Assured Forwarding - Interactive video</li>
<li><strong>AF31 (26)</strong>: Streaming video</li>
<li><strong>BE (0)</strong>: Best effort - Default</li>
</ul>
<h3 id="cpu-optimization"><a class="header" href="#cpu-optimization">CPU Optimization</a></h3>
<pre><code class="language-python"># Use hardware encoding when available
def choose_encoder(codec):
    if codec == 'h264':
        # Try hardware encoders first
        encoders = [
            'h264_nvenc',    # NVIDIA
            'h264_qsv',      # Intel Quick Sync
            'h264_videotoolbox',  # Apple
            'libx264'        # Software fallback
        ]
        for enc in encoders:
            if is_available(enc):
                return enc

    return 'libx264'  # Fallback
</code></pre>
<hr>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li>
<p><strong>Always use SRTP for security</strong></p>
<ul>
<li>Encrypt all media in production</li>
<li>Use DTLS-SRTP for key exchange</li>
<li>Never send keys in plaintext</li>
</ul>
</li>
<li>
<p><strong>Implement proper jitter buffer</strong></p>
<ul>
<li>Use adaptive buffering</li>
<li>Monitor and tune delays</li>
<li>Handle underruns gracefully</li>
</ul>
</li>
<li>
<p><strong>Handle packet loss gracefully</strong></p>
<ul>
<li>Implement PLC (concealment)</li>
<li>Use FEC for important streams</li>
<li>Consider RTX for video keyframes</li>
</ul>
</li>
<li>
<p><strong>Monitor quality with RTCP</strong></p>
<ul>
<li>Send regular RTCP reports</li>
<li>Track loss, jitter, delay</li>
<li>Adapt bitrate based on feedback</li>
</ul>
</li>
<li>
<p><strong>Use appropriate codecs</strong></p>
<ul>
<li><strong>Audio</strong>: Opus for new implementations</li>
<li><strong>Video</strong>: H.264 for compatibility, VP9 for efficiency</li>
<li>Match codec to use case</li>
</ul>
</li>
<li>
<p><strong>Set correct timestamp increments</strong></p>
<ul>
<li>Based on codec clock rate</li>
<li>Consistent increments</li>
<li>Critical for synchronization</li>
</ul>
</li>
<li>
<p><strong>Use even ports for RTP (convention)</strong></p>
<ul>
<li>RTP on even ports (e.g., 5004)</li>
<li>RTCP on odd ports (e.g., 5005)</li>
<li>Or use RTP/RTCP multiplexing</li>
</ul>
</li>
<li>
<p><strong>Implement proper session cleanup</strong></p>
<ul>
<li>Send RTCP BYE when leaving</li>
<li>Close sockets properly</li>
<li>Free resources</li>
</ul>
</li>
<li>
<p><strong>Validate incoming packets</strong></p>
<ul>
<li>Check RTP version</li>
<li>Verify SSRC consistency</li>
<li>Detect duplicates</li>
</ul>
</li>
<li>
<p><strong>Use NTP for cross-stream sync</strong></p>
<ul>
<li>RTCP SR with NTP correlation</li>
<li>Essential for lip-sync</li>
<li>Use reliable NTP source</li>
</ul>
</li>
<li>
<p><strong>Set appropriate DSCP/TOS</strong></p>
<ul>
<li>QoS marking for prioritization</li>
<li>EF for voice, AF41 for video</li>
<li>Coordinate with network team</li>
</ul>
</li>
<li>
<p><strong>Test with packet loss simulation</strong></p>
<ul>
<li>Use <code>tc</code> or <code>netem</code> on Linux</li>
<li>Test 1%, 5%, 10% loss</li>
<li>Verify PLC and FEC work</li>
</ul>
</li>
<li>
<p><strong>Profile and optimize</strong></p>
<ul>
<li>Monitor CPU usage</li>
<li>Use hardware encoding</li>
<li>Optimize packet processing</li>
</ul>
</li>
<li>
<p><strong>Log important events</strong></p>
<ul>
<li>SSRC changes</li>
<li>High loss/jitter</li>
<li>Codec changes</li>
<li>Connection quality</li>
</ul>
</li>
<li>
<p><strong>Implement adaptive bitrate</strong></p>
<ul>
<li>Monitor network conditions</li>
<li>Adjust encoding bitrate</li>
<li>Smooth transitions</li>
</ul>
</li>
</ol>
<hr>
<h2 id="rtp-libraries-and-tools"><a class="header" href="#rtp-libraries-and-tools">RTP Libraries and Tools</a></h2>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p><strong>aiortc</strong> - Async WebRTC and RTP</p>
<pre><code class="language-python">from aiortc import RTCPeerConnection, RTCSessionDescription
from aiortc.contrib.media import MediaPlayer, MediaRecorder

pc = RTCPeerConnection()
player = MediaPlayer('/dev/video0', format='v4l2')
pc.addTrack(player.video)
</code></pre>
<p><strong>pyRTP</strong> - Basic RTP implementation</p>
<pre><code class="language-python">import pyrtp
</code></pre>
<h3 id="javascript"><a class="header" href="#javascript">JavaScript</a></h3>
<p><strong>WebRTC API</strong> - Built-in browser support</p>
<pre><code class="language-javascript">const pc = new RTCPeerConnection();
const stream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
stream.getTracks().forEach(track =&gt; pc.addTrack(track, stream));
</code></pre>
<h3 id="cc"><a class="header" href="#cc">C/C++</a></h3>
<p><strong>Live555</strong> - Streaming media library</p>
<pre><code class="language-cpp">#include &lt;liveMedia.hh&gt;
// Full-featured RTSP/RTP server and client
</code></pre>
<p><strong>GStreamer</strong> - Multimedia framework</p>
<pre><code class="language-bash">gst-launch-1.0 videotestsrc ! x264enc ! rtph264pay ! udpsink
</code></pre>
<p><strong>FFmpeg</strong> - Multimedia processing</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -f rtp rtp://dest:port
</code></pre>
<h3 id="go"><a class="header" href="#go">Go</a></h3>
<p><strong>pion/rtp</strong> - Pure Go RTP implementation</p>
<pre><code class="language-go">import "github.com/pion/rtp"

packet := &amp;rtp.Packet{
    Header: rtp.Header{
        Version: 2,
        PayloadType: 96,
        SequenceNumber: seq,
        Timestamp: ts,
        SSRC: ssrc,
    },
    Payload: payload,
}
</code></pre>
<h3 id="testing-tools"><a class="header" href="#testing-tools">Testing Tools</a></h3>
<p><strong>VLC</strong> - Media player with RTP support</p>
<pre><code class="language-bash"># Stream to RTP
vlc input.mp4 --sout '#rtp{dst=192.168.1.100,port=5004}'

# Receive RTP
vlc rtp://@:5004
</code></pre>
<p><strong>Wireshark</strong> - Packet analysis</p>
<ul>
<li>Comprehensive RTP analysis</li>
<li>Stream statistics</li>
<li>Audio playback</li>
</ul>
<p><strong>tcpdump</strong> - Packet capture</p>
<pre><code class="language-bash">tcpdump -i eth0 -w capture.pcap udp port 5004
</code></pre>
<p><strong>SIPp</strong> - SIP/RTP testing tool</p>
<pre><code class="language-bash">sipp -sn uac 192.168.1.100
</code></pre>
<hr>
<h2 id="eli10"><a class="header" href="#eli10">ELI10</a></h2>
<p>Imagine you’re watching a live sports game on TV.</p>
<p><strong>RTP is like the TV broadcast:</strong></p>
<ul>
<li>The game happens in real-time at the stadium</li>
<li>The TV signal carries the video and sound to your home</li>
<li>If the signal gets a bit fuzzy for a second, that’s OK - the game keeps playing</li>
<li>You’d rather see what’s happening NOW, even if a tiny bit is missing, than wait for perfect quality</li>
</ul>
<p><strong>How RTP works:</strong></p>
<ol>
<li>
<p><strong>Packets = Delivery Trucks</strong></p>
<ul>
<li>The video is split into small chunks (packets)</li>
<li>Each truck (packet) has a number on it (#1, #2, #3…)</li>
<li>Each truck has a timestamp (when it was recorded)</li>
</ul>
</li>
<li>
<p><strong>Sequence Numbers = Package Tracking</strong></p>
<ul>
<li>If truck #5 is missing, you know immediately</li>
<li>You can either wait a bit (maybe it’s just late) or skip it</li>
</ul>
</li>
<li>
<p><strong>Timestamps = Synchronization</strong></p>
<ul>
<li>Makes sure the sound matches the video</li>
<li>Like making sure the announcer’s voice matches the players’ movements</li>
</ul>
</li>
<li>
<p><strong>Jitter Buffer = DVR with Small Delay</strong></p>
<ul>
<li>Buffers a few seconds to smooth out delays</li>
<li>If trucks arrive at irregular times, buffer evens them out</li>
<li>Trade-off: slight delay for smoother playback</li>
</ul>
</li>
<li>
<p><strong>RTCP = Quality Reports</strong></p>
<ul>
<li>Like a report card for the delivery service</li>
<li>“10% of trucks were late”  send trucks slower</li>
<li>“Everything arrived on time”  can send more trucks</li>
</ul>
</li>
<li>
<p><strong>SRTP = Locked Trucks</strong></p>
<ul>
<li>Regular RTP = open trucks (anyone can see inside)</li>
<li>SRTP = locked trucks with keys (encrypted)</li>
<li>Like putting the video in a safe box</li>
</ul>
</li>
</ol>
<p><strong>Why not just use regular file download?</strong></p>
<ul>
<li>File download waits for EVERYTHING before playing</li>
<li>RTP starts playing immediately and keeps going</li>
<li>Better for live events, calls, and real-time stuff</li>
</ul>
<p><strong>Real-world examples:</strong></p>
<ul>
<li><strong>Zoom/Teams calls</strong>: Your voice  RTP  Friend’s computer</li>
<li><strong>YouTube Live</strong>: Streamer  RTP  YouTube  You</li>
<li><strong>Online gaming voice chat</strong>: Your mic  RTP  Other players</li>
</ul>
<hr>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<h3 id="rfcs-standards"><a class="header" href="#rfcs-standards">RFCs (Standards)</a></h3>
<ul>
<li><strong>RFC 3550</strong> - RTP: A Transport Protocol for Real-Time Applications</li>
<li><strong>RFC 3551</strong> - RTP Profile for Audio and Video Conferences</li>
<li><strong>RFC 3711</strong> - Secure Real-time Transport Protocol (SRTP)</li>
<li><strong>RFC 4585</strong> - Extended RTP Profile for RTCP-based Feedback</li>
<li><strong>RFC 4588</strong> - RTP Retransmission Payload Format</li>
<li><strong>RFC 5285</strong> - RTP Header Extensions</li>
<li><strong>RFC 5761</strong> - Multiplexing RTP and RTCP</li>
<li><strong>RFC 6464</strong> - Audio Level Extension</li>
<li><strong>RFC 7742</strong> - WebRTC Video Processing and Codec Requirements</li>
</ul>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<ul>
<li><strong>“RTP: Audio and Video for the Internet”</strong> by Colin Perkins</li>
<li><strong>“Internet Multimedia Communications Using SIP”</strong> by Rogelio Martinez Perea</li>
<li><strong>“WebRTC: APIs and RTCWEB Protocols of the HTML5 Real-Time Web”</strong> by Alan B. Johnston</li>
</ul>
<h3 id="online-resources"><a class="header" href="#online-resources">Online Resources</a></h3>
<ul>
<li><strong>WebRTC Glossary</strong>: https://webrtcglossary.com/</li>
<li><strong>Pion WebRTC</strong> (Go): https://github.com/pion/webrtc</li>
<li><strong>aiortc</strong> (Python): https://github.com/aiortc/aiortc</li>
<li><strong>Jitsi Meet</strong> (Open-source video conferencing): https://jitsi.org/</li>
</ul>
<h3 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h3>
<ul>
<li><strong>MDN WebRTC</strong>: https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API</li>
<li><strong>WebRTC samples</strong>: https://webrtc.github.io/samples/</li>
<li><strong>GStreamer RTP</strong>: https://gstreamer.freedesktop.org/documentation/rtp/</li>
</ul>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li><strong>Wireshark</strong>: https://www.wireshark.org/</li>
<li><strong>VLC</strong>: https://www.videolan.org/</li>
<li><strong>FFmpeg</strong>: https://ffmpeg.org/</li>
<li><strong>GStreamer</strong>: https://gstreamer.freedesktop.org/</li>
</ul>
<hr>
<p><strong>Last Updated</strong>: January 2025</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/sysfs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../linux/filesystems.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/sysfs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../linux/filesystems.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
