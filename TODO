# TODO - Notes Repository Enhancement Plan

This file tracks planned additions and improvements to the knowledge base, organized by priority.

Last Updated: 2025-11-15
Total Suggestions: 22 items

---


---

### 17. misc/computer_graphics.md - NEW GUIDE
**Target Size:** 1,800-2,200 lines
**Rationale:** Valuable for game dev, visualization, UI work

**Must Include:**
- Graphics pipeline overview
- 2D graphics:
  - Rasterization
  - Anti-aliasing
  - Compositing
- 3D graphics fundamentals:
  - Coordinate systems
  - Transformations (translate, rotate, scale)
  - Projection (orthographic, perspective)
  - Camera models
- Rendering:
  - Rasterization vs ray tracing
  - Scanline rendering
  - Z-buffering
- Shaders:
  - Vertex shaders
  - Fragment/Pixel shaders
  - Shader languages (GLSL, HLSL)
- Lighting models:
  - Phong shading
  - Physically-Based Rendering (PBR)
- Texturing:
  - Texture mapping
  - Mipmapping
  - Normal mapping
- Graphics APIs:
  - OpenGL basics
  - Vulkan overview
  - WebGL for web
  - Metal (Apple)
  - DirectX (Windows)
- GPU architecture basics
- Real-time rendering techniques
- Tools and libraries (three.js, Babylon.js)

**Estimated Effort:** 10-12 hours

---

## EXPANSION CANDIDATES (Existing Guides to Significantly Expand)

### 19. web_development/react.md - EXPAND
**Current Size:** 215 lines (TOO BASIC)
**Target Size:** 2,000-2,500 lines
**Rationale:** React is a major framework, deserves comprehensive coverage

**Add:**
- Hooks deep dive:
  - useState, useEffect, useContext
  - useReducer, useMemo, useCallback
  - useRef, useImperativeHandle
  - Custom hooks patterns
- Component composition patterns
- State management:
  - Component state vs global state
  - Context API patterns
  - When to use Redux/MobX/Zustand
- Performance optimization:
  - React.memo
  - useMemo and useCallback usage
  - Code splitting with React.lazy
  - Virtual DOM reconciliation
- Advanced patterns:
  - Render props
  - Higher-Order Components (HOC)
  - Compound components
  - Controlled vs uncontrolled components
- Forms and validation
- Error boundaries
- Portal usage
- Server components (React 18+)
- Testing React components
- React DevTools
- Best practices and anti-patterns

**Estimated Effort:** 10-12 hours

---

### 20. algorithms/dynamic_programming.md - EXPAND
**Current Size:** 5,040 lines (basic examples only)
**Target Size:** 8,000-10,000 lines
**Rationale:** DP is complex, needs more patterns and advanced topics

**Add:**
- More DP patterns:
  - State machine DP
  - Digit DP
  - DP on trees
  - DP with bitmasks
  - Interval DP
  - Probability DP
- Classic problems:
  - Knapsack variants (0/1, unbounded, bounded)
  - LCS and variants
  - LIS and variants
  - Matrix chain multiplication
  - Optimal BST
  - Palindrome partitioning
  - Coin change problems
  - Maximum subarray problems
- Advanced techniques:
  - Space optimization
  - Bottom-up vs top-down trade-offs
  - Memoization patterns
  - DP on graphs
- Multi-dimensional DP
- More real-world examples
- Optimization techniques
- How to identify DP problems

**Estimated Effort:** 12-15 hours

---

### 21. networking/tcp.md - EXPAND
**Current Size:** 737 lines
**Target Size:** 2,000-2,500 lines
**Rationale:** TCP is fundamental, deserves deeper coverage

**Add:**
- TCP connection establishment (3-way handshake) detailed
- Connection termination (4-way handshake)
- TCP state machine
- Flow control deep dive:
  - Sliding window protocol
  - Window scaling
- Congestion control:
  - Slow start
  - Congestion avoidance
  - Fast retransmit and fast recovery
  - TCP variants (Reno, NewReno, CUBIC, BBR)
- TCP performance tuning:
  - Socket buffer sizing
  - TCP_NODELAY (Nagle's algorithm)
  - TCP keepalive
  - Selective acknowledgment (SACK)
- TCP over wireless networks
- TCP optimizations for long-distance connections
- TCP security (SYN flood, RST attacks)
- Debugging TCP issues (tcpdump, Wireshark)
- TCP vs UDP trade-offs (expand)
- QUIC as TCP alternative

**Estimated Effort:** 8-10 hours

---

### 22. RTOS Guides - EXPAND
**Files:** rtos/freertos.md (1,960 lines), rtos/threadx.md (2,257 lines)
**Target Size:** 5,000-8,000 lines each
**Rationale:** Currently basic, need practical examples and depth

**Add to both:**
- Task scheduling deep dive:
  - Scheduling algorithms
  - Priority inversion
  - Priority inheritance
  - Scheduler configuration
- Inter-task communication:
  - Queues (detailed examples)
  - Semaphores (counting, binary)
  - Mutexes
  - Event flags
  - Message buffers
- Memory management in RTOS:
  - Static vs dynamic allocation
  - Memory pools
  - Stack overflow detection
  - Heap management
- Timers and timing:
  - Software timers
  - Tick rate configuration
  - Precise timing
- Interrupt handling:
  - ISR best practices
  - Deferred interrupt processing
- Real-world projects:
  - IoT device example
  - Motor control application
  - Data acquisition system
- Debugging RTOS applications:
  - Task stack usage
  - CPU utilization monitoring
  - Trace tools
- Performance optimization
- Power management
- Safety-critical considerations (RTOS certification)
- Migration guides

**Estimated Effort:** 12-15 hours per RTOS guide

---

## SUMMARY

**Total New Guides:** 18
**Expansion Candidates:** 4
**Estimated Total Effort:** 250-320 hours

**Immediate Focus (Next 1-2 Weeks):**
1. Rewrite queues.md (CRITICAL - only 22 lines)
2. Create graph_algorithms.md (CRITICAL - missing fundamental algorithms)
3. Create string_algorithms.md (CRITICAL - interview essential)
4. Create concurrency.md (CRITICAL - modern development essential)

**Next Phase (Following Month):**
5. Create load_balancing.md (HIGH - system design)
6. Create api_design.md (HIGH - practical development)
7. Create database_design.md (HIGH - practical development)
8. Create observability.md (HIGH - production systems)
9. Create memory_management.md (HIGH - fundamental CS)

**Ongoing:**
- Expand react.md (too basic at 215 lines)
- Continue with TIER 3 and TIER 4 items as time permits

---

## Notes

- **Line count targets** are estimates based on existing comprehensive guides in the repository
- **Effort estimates** assume writing with examples, diagrams (ASCII/markdown), and thorough explanations
- **Dependencies** indicate related guides that should be read/referenced during creation
- **Priority** is based on:
  1. Fundamental importance (algorithms, data structures, concurrency)
  2. Practical applicability (system design, API design, database design)
  3. Completeness of coverage (filling critical gaps)
  4. Interview preparation value

- Consider **cross-linking** between guides to build a knowledge graph
- All guides should include:
  - Theory/fundamentals
  - Code examples in multiple languages where applicable
  - Real-world applications
  - Best practices and anti-patterns
  - Interview questions/patterns (where relevant)
  - References and further reading
