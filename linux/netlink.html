<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Netlink - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-811110ea.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-bd4efd9a.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="netlink"><a class="header" href="#netlink">Netlink</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Netlink is a Linux kernel interface used for communication between the kernel and user-space processes, as well as between different user-space processes. It provides a flexible, extensible mechanism for transferring information and is the modern replacement for older interfaces like ioctl, /proc, and sysfs for many kernel subsystems.</p>
<h3 id="what-is-netlink"><a class="header" href="#what-is-netlink">What is Netlink?</a></h3>
<p>Netlink is a socket-based Inter-Process Communication (IPC) mechanism that uses a special address family (<code>AF_NETLINK</code>). Unlike traditional sockets that communicate over networks, Netlink sockets facilitate communication between user-space and kernel-space, or even between different user-space processes.</p>
<p><strong>Key Characteristics</strong>:</p>
<ul>
<li><strong>Bidirectional</strong>: Both kernel and user-space can initiate communication</li>
<li><strong>Asynchronous</strong>: Supports event-driven programming model</li>
<li><strong>Multicast</strong>: Kernel can broadcast messages to multiple user-space processes</li>
<li><strong>Extensible</strong>: Easy to add new message types and protocols</li>
<li><strong>Socket-based</strong>: Uses familiar socket API (socket, bind, send, recv)</li>
</ul>
<h3 id="why-use-netlink"><a class="header" href="#why-use-netlink">Why Use Netlink?</a></h3>
<p>Netlink offers several advantages over traditional kernel-userspace communication methods:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Advantages</th><th>Disadvantages</th></tr>
</thead>
<tbody>
<tr><td><strong>ioctl</strong></td><td>Simple, direct</td><td>Limited data transfer, not extensible, version compatibility issues</td></tr>
<tr><td><strong>/proc</strong></td><td>Human-readable</td><td>Text parsing overhead, not suitable for complex data, one-way</td></tr>
<tr><td><strong>/sys</strong></td><td>Organized, one-value-per-file</td><td>Inefficient for bulk operations, read-only limitations</td></tr>
<tr><td><strong>Netlink</strong></td><td>Flexible, extensible, bidirectional, multicast support</td><td>More complex API, steeper learning curve</td></tr>
</tbody>
</table>
</div>
<p><strong>Advantages of Netlink</strong>:</p>
<ol>
<li><strong>Structured Messages</strong>: Well-defined binary format with TLV (Type-Length-Value) attributes</li>
<li><strong>Extensibility</strong>: Easy to add new attributes without breaking compatibility</li>
<li><strong>Asynchronous Notifications</strong>: Kernel can push events to user-space</li>
<li><strong>Multicast Support</strong>: One-to-many communication</li>
<li><strong>Standard Socket API</strong>: Familiar programming interface</li>
<li><strong>Better Performance</strong>: No text parsing, efficient binary protocol</li>
<li><strong>Bidirectional</strong>: Both sides can initiate communication</li>
</ol>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h3>
<p>Netlink is used extensively throughout the Linux kernel for:</p>
<ul>
<li><strong>Network Configuration</strong>: <code>rtnetlink</code> for routing, interfaces, addresses (used by <code>ip</code> command)</li>
<li><strong>Wireless Configuration</strong>: <code>nl80211</code> for WiFi management</li>
<li><strong>Netfilter/iptables</strong>: Firewall rule management</li>
<li><strong>SELinux</strong>: Security policy communication</li>
<li><strong>Audit System</strong>: Kernel audit events</li>
<li><strong>udev Events</strong>: Device hotplug notifications</li>
<li><strong>Task Statistics</strong>: Per-process statistics (taskstats)</li>
<li><strong>Connector</strong>: Generic kernel-to-user notifications</li>
<li><strong>Socket Diagnostics</strong>: Detailed socket information</li>
</ul>
<h3 id="netlink-architecture-overview"><a class="header" href="#netlink-architecture-overview">Netlink Architecture Overview</a></h3>
<pre><code class="language-mermaid">graph TB
    subgraph UserSpace["User Space"]
        App1[Application 1]
        App2[Application 2]
        App3[Application 3]
        Lib[libnl/pyroute2]
    end

    subgraph KernelSpace["Kernel Space"]
        NLS[Netlink Socket Layer]

        subgraph Families["Netlink Families"]
            ROUTE[NETLINK_ROUTE&lt;br/&gt;rtnetlink]
            GEN[NETLINK_GENERIC&lt;br/&gt;generic netlink]
            NF[NETLINK_NETFILTER]
            KOBJ[NETLINK_KOBJECT_UEVENT]
            DIAG[NETLINK_SOCK_DIAG]
        end

        subgraph Subsystems["Kernel Subsystems"]
            NET[Network Stack]
            FW[Netfilter]
            UDEV[Device Manager]
        end
    end

    App1 --&gt;|AF_NETLINK| NLS
    App2 --&gt;|AF_NETLINK| NLS
    App3 --&gt;|AF_NETLINK| NLS
    Lib --&gt;|AF_NETLINK| NLS

    NLS --&gt; ROUTE
    NLS --&gt; GEN
    NLS --&gt; NF
    NLS --&gt; KOBJ
    NLS --&gt; DIAG

    ROUTE &lt;--&gt; NET
    GEN &lt;--&gt; NET
    NF &lt;--&gt; FW
    KOBJ &lt;--&gt; UDEV

    style UserSpace fill:#E6F3FF
    style KernelSpace fill:#FFE6E6
    style Families fill:#FFF9E6
    style Subsystems fill:#E6FFE6
</code></pre>
<h3 id="history-and-evolution"><a class="header" href="#history-and-evolution">History and Evolution</a></h3>
<ul>
<li><strong>Linux 2.0 (1996)</strong>: Initial netlink implementation for routing</li>
<li><strong>Linux 2.2 (1999)</strong>: Expanded to support multiple protocols</li>
<li><strong>Linux 2.4 (2001)</strong>: Generic netlink introduced</li>
<li><strong>Linux 2.6 (2003)</strong>: Major expansion, nl80211 for wireless</li>
<li><strong>Linux 3.x (2011+)</strong>: Continued expansion, netlink used for most kernel-user communication</li>
<li><strong>Modern Linux</strong>: Primary interface for network configuration, replacing ioctl</li>
</ul>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="netlink-socket-family"><a class="header" href="#netlink-socket-family">Netlink Socket Family</a></h3>
<p>Netlink uses the <code>AF_NETLINK</code> address family. Creating a netlink socket is similar to creating any other socket:</p>
<pre><code class="language-c">int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
</code></pre>
<p><strong>Socket Type</strong>:</p>
<ul>
<li><code>SOCK_RAW</code>: Used for netlink (not UDP/TCP)</li>
<li><code>SOCK_DGRAM</code>: Also supported, functionally equivalent to SOCK_RAW for netlink</li>
</ul>
<p><strong>Protocol Parameter</strong>: Specifies the netlink family/protocol:</p>
<ul>
<li><code>NETLINK_ROUTE</code> - Routing and interface configuration</li>
<li><code>NETLINK_GENERIC</code> - Generic netlink</li>
<li><code>NETLINK_NETFILTER</code> - Netfilter subsystem</li>
<li>Many others (see complete list below)</li>
</ul>
<h3 id="netlink-protocolsfamilies"><a class="header" href="#netlink-protocolsfamilies">Netlink Protocols/Families</a></h3>
<p>The Linux kernel supports numerous netlink families:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Protocol</th><th>Value</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>NETLINK_ROUTE</code></td><td>0</td><td>Routing and link configuration (rtnetlink)</td></tr>
<tr><td><code>NETLINK_UNUSED</code></td><td>1</td><td>Unused (legacy)</td></tr>
<tr><td><code>NETLINK_USERSOCK</code></td><td>2</td><td>Reserved for user-mode socket protocols</td></tr>
<tr><td><code>NETLINK_FIREWALL</code></td><td>3</td><td>Unused (legacy firewall)</td></tr>
<tr><td><code>NETLINK_SOCK_DIAG</code></td><td>4</td><td>Socket diagnostics</td></tr>
<tr><td><code>NETLINK_NFLOG</code></td><td>5</td><td>Netfilter logging</td></tr>
<tr><td><code>NETLINK_XFRM</code></td><td>6</td><td>IPsec</td></tr>
<tr><td><code>NETLINK_SELINUX</code></td><td>7</td><td>SELinux events</td></tr>
<tr><td><code>NETLINK_ISCSI</code></td><td>8</td><td>iSCSI</td></tr>
<tr><td><code>NETLINK_AUDIT</code></td><td>9</td><td>Kernel audit</td></tr>
<tr><td><code>NETLINK_FIB_LOOKUP</code></td><td>10</td><td>FIB lookup</td></tr>
<tr><td><code>NETLINK_CONNECTOR</code></td><td>11</td><td>Kernel connector</td></tr>
<tr><td><code>NETLINK_NETFILTER</code></td><td>12</td><td>Netfilter subsystem</td></tr>
<tr><td><code>NETLINK_IP6_FW</code></td><td>13</td><td>Unused (legacy IPv6 firewall)</td></tr>
<tr><td><code>NETLINK_DNRTMSG</code></td><td>14</td><td>DECnet routing</td></tr>
<tr><td><code>NETLINK_KOBJECT_UEVENT</code></td><td>15</td><td>Kernel object events (udev)</td></tr>
<tr><td><code>NETLINK_GENERIC</code></td><td>16</td><td>Generic netlink</td></tr>
<tr><td><code>NETLINK_SCSITRANSPORT</code></td><td>18</td><td>SCSI transport</td></tr>
<tr><td><code>NETLINK_ECRYPTFS</code></td><td>19</td><td>eCryptfs</td></tr>
<tr><td><code>NETLINK_RDMA</code></td><td>20</td><td>RDMA</td></tr>
<tr><td><code>NETLINK_CRYPTO</code></td><td>21</td><td>Crypto layer</td></tr>
</tbody>
</table>
</div>
<h3 id="communication-model"><a class="header" href="#communication-model">Communication Model</a></h3>
<p>Netlink supports several communication patterns:</p>
<pre><code class="language-mermaid">graph TB
    subgraph Pattern1["Unicast (Request-Response)"]
        U1[User Process] --&gt;|Request| K1[Kernel]
        K1 --&gt;|Response| U1
    end

    subgraph Pattern2["Multicast (Event Broadcasting)"]
        K2[Kernel] --&gt;|Event| M1[Subscribed Process 1]
        K2 --&gt;|Event| M2[Subscribed Process 2]
        K2 --&gt;|Event| M3[Subscribed Process 3]
    end

    subgraph Pattern3["User-to-User"]
        UU1[User Process 1] --&gt;|Message| UU2[User Process 2]
    end

    style Pattern1 fill:#E6F3FF
    style Pattern2 fill:#FFE6F0
    style Pattern3 fill:#E6FFE6
</code></pre>
<p><strong>Communication Patterns</strong>:</p>
<ol>
<li>
<p><strong>Unicast (Request-Response)</strong>:</p>
<ul>
<li>User-space sends request to kernel</li>
<li>Kernel responds with data</li>
<li>Example: Getting interface information</li>
</ul>
</li>
<li>
<p><strong>Multicast (Event Broadcasting)</strong>:</p>
<ul>
<li>Kernel broadcasts events to multiple listeners</li>
<li>User-space processes subscribe to multicast groups</li>
<li>Example: Link state changes, route updates</li>
</ul>
</li>
<li>
<p><strong>User-to-User</strong>:</p>
<ul>
<li>Communication between user-space processes</li>
<li>Less common, but supported</li>
<li>Example: Custom IPC using netlink</li>
</ul>
</li>
</ol>
<h3 id="netlink-addressing"><a class="header" href="#netlink-addressing">Netlink Addressing</a></h3>
<p>Netlink uses a unique addressing scheme:</p>
<pre><code class="language-c">struct sockaddr_nl {
    sa_family_t     nl_family;  /* AF_NETLINK */
    unsigned short  nl_pad;     /* Zero */
    __u32           nl_pid;     /* Port ID (process ID or 0) */
    __u32           nl_groups;  /* Multicast groups mask */
};
</code></pre>
<p><strong>Port ID (nl_pid)</strong>:</p>
<ul>
<li><strong>User-space</strong>: Typically the process PID, but can be any unique value</li>
<li><strong>Kernel</strong>: Always 0</li>
<li><strong>Autobind</strong>: Use 0 to let kernel assign a unique port ID</li>
<li><strong>Custom</strong>: Can specify any value, but must be unique</li>
</ul>
<p><strong>Multicast Groups (nl_groups)</strong>:</p>
<ul>
<li>Bitmask of multicast groups to join</li>
<li>Each bit represents a group (0-31)</li>
<li>Used for receiving broadcast notifications</li>
<li>Different for each netlink family</li>
</ul>
<h3 id="port-id-assignment"><a class="header" href="#port-id-assignment">Port ID Assignment</a></h3>
<pre><code class="language-mermaid">flowchart LR
    A[Create Socket] --&gt; B{Specify nl_pid?}
    B --&gt;|pid = 0| C[Kernel Auto-assigns&lt;br/&gt;unique PID]
    B --&gt;|pid = getpid| D[Use process PID]
    B --&gt;|pid = custom| E[Use custom value&lt;br/&gt;must be unique]

    C --&gt; F[bind success]
    D --&gt; G{PID available?}
    E --&gt; H{Value available?}

    G --&gt;|Yes| F
    G --&gt;|No| I[EADDRINUSE error]
    H --&gt;|Yes| F
    H --&gt;|No| I

    style F fill:#90EE90
    style I fill:#FFB6C6
</code></pre>
<h3 id="multicast-groups"><a class="header" href="#multicast-groups">Multicast Groups</a></h3>
<p>Multicast groups allow kernel to broadcast events to multiple user-space listeners:</p>
<pre><code class="language-c">// Example: Join RTMGRP_LINK group to receive link state changes
struct sockaddr_nl sa = {
    .nl_family = AF_NETLINK,
    .nl_groups = RTMGRP_LINK | RTMGRP_IPV4_ROUTE
};
bind(sock, (struct sockaddr *)&amp;sa, sizeof(sa));
</code></pre>
<p><strong>Common rtnetlink Multicast Groups</strong>:</p>
<ul>
<li><code>RTMGRP_LINK</code> - Link state changes</li>
<li><code>RTMGRP_NOTIFY</code> - General notifications</li>
<li><code>RTMGRP_NEIGH</code> - Neighbor table updates</li>
<li><code>RTMGRP_TC</code> - Traffic control</li>
<li><code>RTMGRP_IPV4_IFADDR</code> - IPv4 address changes</li>
<li><code>RTMGRP_IPV4_ROUTE</code> - IPv4 routing changes</li>
<li><code>RTMGRP_IPV6_IFADDR</code> - IPv6 address changes</li>
<li><code>RTMGRP_IPV6_ROUTE</code> - IPv6 routing changes</li>
</ul>
<h2 id="message-format"><a class="header" href="#message-format">Message Format</a></h2>
<h3 id="netlink-message-header"><a class="header" href="#netlink-message-header">Netlink Message Header</a></h3>
<p>Every netlink message starts with a <code>struct nlmsghdr</code>:</p>
<pre><code class="language-c">struct nlmsghdr {
    __u32 nlmsg_len;    /* Length of message including header */
    __u16 nlmsg_type;   /* Message type (protocol specific) */
    __u16 nlmsg_flags;  /* Additional flags */
    __u32 nlmsg_seq;    /* Sequence number */
    __u32 nlmsg_pid;    /* Sender port ID */
};
</code></pre>
<p><strong>Field Details</strong>:</p>
<ol>
<li><strong>nlmsg_len</strong>: Total message length in bytes, including header</li>
<li><strong>nlmsg_type</strong>: Message type/command (specific to each netlink family)</li>
<li><strong>nlmsg_flags</strong>: Control flags (request, multi-part, etc.)</li>
<li><strong>nlmsg_seq</strong>: Sequence number for matching requests/responses</li>
<li><strong>nlmsg_pid</strong>: Sender’s port ID (0 for kernel, process ID for user-space)</li>
</ol>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<p><strong>Standard Message Types</strong> (common across all netlink families):</p>
<pre><code class="language-c">#define NLMSG_NOOP      0x1     /* Nothing, ignore */
#define NLMSG_ERROR     0x2     /* Error message */
#define NLMSG_DONE      0x3     /* End of multi-part message */
#define NLMSG_OVERRUN   0x4     /* Data lost */
</code></pre>
<p><strong>Family-Specific Types</strong>: Each netlink family defines its own message types (&gt;= 16)</p>
<p>For rtnetlink (NETLINK_ROUTE):</p>
<pre><code class="language-c">RTM_NEWLINK     // Create/update link
RTM_DELLINK     // Delete link
RTM_GETLINK     // Get link info
RTM_NEWADDR     // Add address
RTM_DELADDR     // Delete address
RTM_GETADDR     // Get address
RTM_NEWROUTE    // Add route
RTM_DELROUTE    // Delete route
RTM_GETROUTE    // Get route
// ... many more
</code></pre>
<h3 id="message-flags"><a class="header" href="#message-flags">Message Flags</a></h3>
<pre><code class="language-c">/* Request flags */
#define NLM_F_REQUEST   0x01    /* Request message */
#define NLM_F_MULTI     0x02    /* Multi-part message */
#define NLM_F_ACK       0x04    /* Request acknowledgment */
#define NLM_F_ECHO      0x08    /* Echo request */

/* Modifiers for GET requests */
#define NLM_F_ROOT      0x100   /* Return complete table */
#define NLM_F_MATCH     0x200   /* Return all matching */
#define NLM_F_ATOMIC    0x400   /* Atomic operation */
#define NLM_F_DUMP      (NLM_F_ROOT | NLM_F_MATCH)

/* Modifiers for NEW requests */
#define NLM_F_REPLACE   0x100   /* Replace existing */
#define NLM_F_EXCL      0x200   /* Don't replace if exists */
#define NLM_F_CREATE    0x400   /* Create if doesn't exist */
#define NLM_F_APPEND    0x800   /* Add to end of list */
</code></pre>
<p><strong>Common Flag Combinations</strong>:</p>
<ul>
<li><code>NLM_F_REQUEST | NLM_F_DUMP</code>: Get all entries</li>
<li><code>NLM_F_REQUEST | NLM_F_ACK</code>: Request with acknowledgment</li>
<li><code>NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL</code>: Create only if doesn’t exist</li>
<li><code>NLM_F_REQUEST | NLM_F_REPLACE</code>: Replace existing entry</li>
</ul>
<h3 id="message-structure"><a class="header" href="#message-structure">Message Structure</a></h3>
<pre><code class="language-mermaid">graph TB
    subgraph Message["Netlink Message"]
        direction TB
        Header[nlmsghdr&lt;br/&gt;16 bytes]
        Payload[Message Payload]

        subgraph PayloadDetail["Payload Structure"]
            FamilyHdr[Family-specific Header&lt;br/&gt;e.g., ifinfomsg, rtmsg]
            Attrs[Attributes TLV]

            subgraph AttrDetail["Attributes (TLV Format)"]
                Attr1[Attribute 1&lt;br/&gt;rtattr/nlattr]
                Attr2[Attribute 2]
                Attr3[Attribute 3]
                AttrN[...]
            end
        end
    end

    Header --&gt; Payload
    Payload --&gt; FamilyHdr
    FamilyHdr --&gt; Attrs
    Attrs --&gt; Attr1
    Attrs --&gt; Attr2
    Attrs --&gt; Attr3
    Attrs --&gt; AttrN

    style Header fill:#FFE6E6
    style FamilyHdr fill:#E6F3FF
    style Attrs fill:#E6FFE6
</code></pre>
<h3 id="netlink-attributes-tlv-format"><a class="header" href="#netlink-attributes-tlv-format">Netlink Attributes (TLV Format)</a></h3>
<p>Netlink uses Type-Length-Value (TLV) encoding for flexible, extensible message payloads:</p>
<pre><code class="language-c">/* Old-style attributes */
struct rtattr {
    unsigned short  rta_len;    /* Length including header */
    unsigned short  rta_type;   /* Attribute type */
    /* Attribute data follows */
};

/* New-style attributes */
struct nlattr {
    __u16           nla_len;    /* Length including header */
    __u16           nla_type;   /* Attribute type */
    /* Attribute data follows */
};
</code></pre>
<p><strong>Attribute Alignment</strong>: All attributes must be aligned to 4-byte boundaries.</p>
<p><strong>Macros for Attribute Manipulation</strong>:</p>
<pre><code class="language-c">/* Attribute length macros */
#define RTA_ALIGNTO     4
#define RTA_ALIGN(len)  (((len)+RTA_ALIGNTO-1) &amp; ~(RTA_ALIGNTO-1))
#define RTA_LENGTH(len) (RTA_ALIGN(sizeof(struct rtattr)) + (len))
#define RTA_SPACE(len)  RTA_ALIGN(RTA_LENGTH(len))

/* Attribute data access */
#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))
#define RTA_PAYLOAD(rta) ((int)((rta)-&gt;rta_len) - RTA_LENGTH(0))

/* Attribute iteration */
#define RTA_OK(rta,len) \
    ((len) &gt;= (int)sizeof(struct rtattr) &amp;&amp; \
     (rta)-&gt;rta_len &gt;= sizeof(struct rtattr) &amp;&amp; \
     (rta)-&gt;rta_len &lt;= (len))
#define RTA_NEXT(rta,attrlen) \
    ((attrlen) -= RTA_ALIGN((rta)-&gt;rta_len), \
     (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)-&gt;rta_len)))
</code></pre>
<h3 id="nested-attributes"><a class="header" href="#nested-attributes">Nested Attributes</a></h3>
<p>Attributes can contain other attributes (nesting):</p>
<pre><code class="language-c">/* Creating nested attribute */
struct rtattr *nest = (struct rtattr *)buffer;
nest-&gt;rta_type = IFLA_LINKINFO;
nest-&gt;rta_len = RTA_LENGTH(0);

/* Add child attributes */
add_attribute(buffer, IFLA_INFO_KIND, "vlan", 4);
add_attribute(buffer, IFLA_INFO_DATA, &amp;data, sizeof(data));

/* Update nest length */
nest-&gt;rta_len = (char *)current_pos - (char *)nest;
</code></pre>
<h3 id="message-alignment-and-padding"><a class="header" href="#message-alignment-and-padding">Message Alignment and Padding</a></h3>
<pre><code class="language-mermaid">graph LR
    subgraph Msg["Message Layout (bytes)"]
        H[Header&lt;br/&gt;0-15]
        P1[Payload&lt;br/&gt;16-N]
        Pad1[Padding&lt;br/&gt;0-3 bytes]
        A1[Attr1 Header&lt;br/&gt;4 bytes]
        A1D[Attr1 Data]
        Pad2[Padding]
        A2[Attr2 Header]
        A2D[Attr2 Data]
    end

    style H fill:#FFE6E6
    style P1 fill:#E6F3FF
    style Pad1 fill:#FFFFE6
    style A1 fill:#E6FFE6
    style Pad2 fill:#FFFFE6
</code></pre>
<p><strong>Alignment Rules</strong>:</p>
<ol>
<li>Messages are aligned to 4-byte boundaries (NLMSG_ALIGNTO)</li>
<li>Attributes are aligned to 4-byte boundaries (RTA_ALIGNTO/NLA_ALIGNTO)</li>
<li>Padding bytes should be zeroed</li>
<li>Length fields include the header and data, but not padding</li>
</ol>
<h2 id="rtnetlink-netlink_route"><a class="header" href="#rtnetlink-netlink_route">rtnetlink (NETLINK_ROUTE)</a></h2>
<p>rtnetlink is the most commonly used netlink family, providing network configuration capabilities used by tools like <code>ip</code>, <code>ifconfig</code>, and <code>route</code>.</p>
<h3 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h3>
<p>rtnetlink can manage:</p>
<ul>
<li>Network interfaces (create, delete, configure)</li>
<li>IP addresses (add, remove, query)</li>
<li>Routing tables (add/delete routes)</li>
<li>Neighbor tables (ARP/NDP)</li>
<li>Traffic control (qdisc, classes, filters)</li>
<li>Network namespaces</li>
<li>Tunnels and virtual interfaces</li>
</ul>
<h3 id="message-types-1"><a class="header" href="#message-types-1">Message Types</a></h3>
<pre><code class="language-c">/* Link messages */
RTM_NEWLINK     /* Create/modify link */
RTM_DELLINK     /* Delete link */
RTM_GETLINK     /* Get link info */
RTM_SETLINK     /* Set link attributes */

/* Address messages */
RTM_NEWADDR     /* Add address */
RTM_DELADDR     /* Delete address */
RTM_GETADDR     /* Get address */

/* Route messages */
RTM_NEWROUTE    /* Add route */
RTM_DELROUTE    /* Delete route */
RTM_GETROUTE    /* Get route */

/* Neighbor messages */
RTM_NEWNEIGH    /* Add neighbor */
RTM_DELNEIGH    /* Delete neighbor */
RTM_GETNEIGH    /* Get neighbor */

/* Rule messages */
RTM_NEWRULE     /* Add routing rule */
RTM_DELRULE     /* Delete routing rule */
RTM_GETRULE     /* Get routing rule */

/* Qdisc messages */
RTM_NEWQDISC    /* Add qdisc */
RTM_DELQDISC    /* Delete qdisc */
RTM_GETQDISC    /* Get qdisc */

/* Traffic class messages */
RTM_NEWTCLASS   /* Add traffic class */
RTM_DELTCLASS   /* Delete traffic class */
RTM_GETTCLASS   /* Get traffic class */

/* Filter messages */
RTM_NEWTFILTER  /* Add filter */
RTM_DELTFILTER  /* Delete filter */
RTM_GETTFILTER  /* Get filter */
</code></pre>
<h3 id="link-management"><a class="header" href="#link-management">Link Management</a></h3>
<p><strong>Interface Information Message (<code>ifinfomsg</code>)</strong>:</p>
<pre><code class="language-c">struct ifinfomsg {
    unsigned char   ifi_family;     /* AF_UNSPEC */
    unsigned char   __ifi_pad;
    unsigned short  ifi_type;       /* Device type (ARPHRD_*) */
    int             ifi_index;      /* Interface index */
    unsigned int    ifi_flags;      /* Device flags (IFF_*) */
    unsigned int    ifi_change;     /* Change mask */
};
</code></pre>
<p><strong>Link Attributes</strong>:</p>
<pre><code class="language-c">enum {
    IFLA_UNSPEC,
    IFLA_ADDRESS,           /* Hardware address */
    IFLA_BROADCAST,         /* Broadcast address */
    IFLA_IFNAME,            /* Interface name */
    IFLA_MTU,               /* MTU */
    IFLA_LINK,              /* Link index */
    IFLA_QDISC,             /* Queueing discipline */
    IFLA_STATS,             /* Interface statistics */
    IFLA_MASTER,            /* Master device index */
    IFLA_OPERSTATE,         /* Operating state */
    IFLA_LINKMODE,          /* Link mode */
    IFLA_LINKINFO,          /* Link type info (nested) */
    IFLA_TXQLEN,            /* Transmit queue length */
    IFLA_MAP,               /* Device mapping */
    IFLA_WEIGHT,            /* Weight */
    // ... many more
};
</code></pre>
<h3 id="example-getting-link-information"><a class="header" href="#example-getting-link-information">Example: Getting Link Information</a></h3>
<pre><code class="language-c">#include &lt;linux/netlink.h&gt;
#include &lt;linux/rtnetlink.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    int sock;
    struct {
        struct nlmsghdr nlh;
        struct ifinfomsg ifi;
    } req;
    char buf[8192];
    struct iovec iov;
    struct msghdr msg;

    /* Create netlink socket */
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock &lt; 0) {
        perror("socket");
        return 1;
    }

    /* Prepare request message */
    memset(&amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_GETLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
    req.nlh.nlmsg_seq = 1;
    req.nlh.nlmsg_pid = getpid();

    req.ifi.ifi_family = AF_UNSPEC;

    /* Send request */
    iov.iov_base = &amp;req;
    iov.iov_len = req.nlh.nlmsg_len;
    memset(&amp;msg, 0, sizeof(msg));
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;

    if (sendmsg(sock, &amp;msg, 0) &lt; 0) {
        perror("sendmsg");
        close(sock);
        return 1;
    }

    /* Receive response */
    while (1) {
        struct nlmsghdr *nlh;
        int len;

        iov.iov_base = buf;
        iov.iov_len = sizeof(buf);
        len = recvmsg(sock, &amp;msg, 0);

        if (len &lt; 0) {
            perror("recvmsg");
            break;
        }

        for (nlh = (struct nlmsghdr *)buf;
             NLMSG_OK(nlh, len);
             nlh = NLMSG_NEXT(nlh, len)) {

            if (nlh-&gt;nlmsg_type == NLMSG_DONE) {
                goto done;
            }

            if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
                fprintf(stderr, "Error in netlink response\n");
                goto done;
            }

            if (nlh-&gt;nlmsg_type == RTM_NEWLINK) {
                struct ifinfomsg *ifi = NLMSG_DATA(nlh);
                struct rtattr *rta = IFLA_RTA(ifi);
                int rtalen = IFLA_PAYLOAD(nlh);

                printf("Interface %d: ", ifi-&gt;ifi_index);

                /* Parse attributes */
                while (RTA_OK(rta, rtalen)) {
                    if (rta-&gt;rta_type == IFLA_IFNAME) {
                        printf("%s ", (char *)RTA_DATA(rta));
                    } else if (rta-&gt;rta_type == IFLA_MTU) {
                        printf("MTU=%u ", *(unsigned int *)RTA_DATA(rta));
                    } else if (rta-&gt;rta_type == IFLA_OPERSTATE) {
                        unsigned char state = *(unsigned char *)RTA_DATA(rta);
                        printf("State=%s ",
                               state == 6 ? "UP" :
                               state == 2 ? "DOWN" : "UNKNOWN");
                    }
                    rta = RTA_NEXT(rta, rtalen);
                }
                printf("\n");
            }
        }
    }

done:
    close(sock);
    return 0;
}
</code></pre>
<h3 id="example-setting-link-updown"><a class="header" href="#example-setting-link-updown">Example: Setting Link UP/DOWN</a></h3>
<pre><code class="language-c">#include &lt;linux/netlink.h&gt;
#include &lt;linux/rtnetlink.h&gt;
#include &lt;net/if.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int set_link_state(const char *ifname, int up) {
    int sock;
    struct {
        struct nlmsghdr nlh;
        struct ifinfomsg ifi;
        char attrbuf[512];
    } req;
    struct rtattr *rta;
    int ifindex;

    /* Get interface index */
    ifindex = if_nametoindex(ifname);
    if (ifindex == 0) {
        perror("if_nametoindex");
        return -1;
    }

    /* Create socket */
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock &lt; 0) {
        perror("socket");
        return -1;
    }

    /* Prepare request */
    memset(&amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;
    req.nlh.nlmsg_pid = getpid();

    req.ifi.ifi_family = AF_UNSPEC;
    req.ifi.ifi_index = ifindex;
    req.ifi.ifi_flags = up ? IFF_UP : 0;
    req.ifi.ifi_change = IFF_UP;

    /* Send request */
    if (send(sock, &amp;req, req.nlh.nlmsg_len, 0) &lt; 0) {
        perror("send");
        close(sock);
        return -1;
    }

    /* Wait for acknowledgment */
    char buf[4096];
    int len = recv(sock, buf, sizeof(buf), 0);

    struct nlmsghdr *nlh = (struct nlmsghdr *)buf;
    if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(nlh);
        if (err-&gt;error != 0) {
            fprintf(stderr, "Netlink error: %d\n", err-&gt;error);
            close(sock);
            return -1;
        }
    }

    close(sock);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s &lt;interface&gt; &lt;up|down&gt;\n", argv[0]);
        return 1;
    }

    int up = strcmp(argv[2], "up") == 0;

    if (set_link_state(argv[1], up) == 0) {
        printf("Successfully set %s %s\n", argv[1], up ? "UP" : "DOWN");
        return 0;
    }

    return 1;
}
</code></pre>
<h3 id="address-management"><a class="header" href="#address-management">Address Management</a></h3>
<p><strong>Address Information Message (<code>ifaddrmsg</code>)</strong>:</p>
<pre><code class="language-c">struct ifaddrmsg {
    __u8    ifa_family;     /* Address family (AF_INET/AF_INET6) */
    __u8    ifa_prefixlen;  /* Prefix length */
    __u8    ifa_flags;      /* Address flags (IFA_F_*) */
    __u8    ifa_scope;      /* Address scope (RT_SCOPE_*) */
    __u32   ifa_index;      /* Interface index */
};
</code></pre>
<p><strong>Address Attributes</strong>:</p>
<pre><code class="language-c">enum {
    IFA_UNSPEC,
    IFA_ADDRESS,        /* Address itself */
    IFA_LOCAL,          /* Local address */
    IFA_LABEL,          /* Interface name */
    IFA_BROADCAST,      /* Broadcast address */
    IFA_ANYCAST,        /* Anycast address */
    IFA_CACHEINFO,      /* Address cache info */
    IFA_MULTICAST,      /* Multicast address */
    IFA_FLAGS,          /* Extended flags */
    // ...
};
</code></pre>
<h3 id="example-adding-an-ip-address"><a class="header" href="#example-adding-an-ip-address">Example: Adding an IP Address</a></h3>
<pre><code class="language-c">#include &lt;linux/netlink.h&gt;
#include &lt;linux/rtnetlink.h&gt;
#include &lt;net/if.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int add_ipv4_address(const char *ifname, const char *ip, int prefixlen) {
    int sock;
    struct {
        struct nlmsghdr nlh;
        struct ifaddrmsg ifa;
        char attrbuf[512];
    } req;
    struct rtattr *rta;
    int ifindex;
    struct in_addr addr;

    /* Get interface index */
    ifindex = if_nametoindex(ifname);
    if (ifindex == 0) {
        perror("if_nametoindex");
        return -1;
    }

    /* Parse IP address */
    if (inet_pton(AF_INET, ip, &amp;addr) != 1) {
        fprintf(stderr, "Invalid IP address\n");
        return -1;
    }

    /* Create socket */
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock &lt; 0) {
        perror("socket");
        return -1;
    }

    /* Prepare request */
    memset(&amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifaddrmsg));
    req.nlh.nlmsg_type = RTM_NEWADDR;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;
    req.nlh.nlmsg_pid = getpid();

    req.ifa.ifa_family = AF_INET;
    req.ifa.ifa_prefixlen = prefixlen;
    req.ifa.ifa_flags = IFA_F_PERMANENT;
    req.ifa.ifa_scope = RT_SCOPE_UNIVERSE;
    req.ifa.ifa_index = ifindex;

    /* Add IFA_LOCAL attribute */
    rta = (struct rtattr *)(((char *)&amp;req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    rta-&gt;rta_type = IFA_LOCAL;
    rta-&gt;rta_len = RTA_LENGTH(sizeof(addr));
    memcpy(RTA_DATA(rta), &amp;addr, sizeof(addr));
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(sizeof(addr));

    /* Add IFA_ADDRESS attribute */
    rta = (struct rtattr *)(((char *)&amp;req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    rta-&gt;rta_type = IFA_ADDRESS;
    rta-&gt;rta_len = RTA_LENGTH(sizeof(addr));
    memcpy(RTA_DATA(rta), &amp;addr, sizeof(addr));
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(sizeof(addr));

    /* Send request */
    if (send(sock, &amp;req, req.nlh.nlmsg_len, 0) &lt; 0) {
        perror("send");
        close(sock);
        return -1;
    }

    /* Check acknowledgment */
    char buf[4096];
    int len = recv(sock, buf, sizeof(buf), 0);
    struct nlmsghdr *nlh = (struct nlmsghdr *)buf;

    if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(nlh);
        if (err-&gt;error != 0) {
            fprintf(stderr, "Failed to add address: %s\n", strerror(-err-&gt;error));
            close(sock);
            return -1;
        }
    }

    close(sock);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s &lt;interface&gt; &lt;ip&gt; &lt;prefixlen&gt;\n", argv[0]);
        fprintf(stderr, "Example: %s eth0 192.168.1.100 24\n", argv[0]);
        return 1;
    }

    int prefixlen = atoi(argv[3]);

    if (add_ipv4_address(argv[1], argv[2], prefixlen) == 0) {
        printf("Successfully added %s/%d to %s\n", argv[2], prefixlen, argv[1]);
        return 0;
    }

    return 1;
}
</code></pre>
<h3 id="route-management"><a class="header" href="#route-management">Route Management</a></h3>
<p><strong>Route Message (<code>rtmsg</code>)</strong>:</p>
<pre><code class="language-c">struct rtmsg {
    unsigned char   rtm_family;     /* Address family (AF_INET/AF_INET6) */
    unsigned char   rtm_dst_len;    /* Destination prefix length */
    unsigned char   rtm_src_len;    /* Source prefix length */
    unsigned char   rtm_tos;        /* Type of service */
    unsigned char   rtm_table;      /* Routing table ID */
    unsigned char   rtm_protocol;   /* Routing protocol */
    unsigned char   rtm_scope;      /* Route scope */
    unsigned char   rtm_type;       /* Route type */
    unsigned int    rtm_flags;      /* Route flags */
};
</code></pre>
<p><strong>Route Attributes</strong>:</p>
<pre><code class="language-c">enum {
    RTA_UNSPEC,
    RTA_DST,            /* Destination address */
    RTA_SRC,            /* Source address */
    RTA_IIF,            /* Input interface */
    RTA_OIF,            /* Output interface */
    RTA_GATEWAY,        /* Gateway address */
    RTA_PRIORITY,       /* Route priority/metric */
    RTA_PREFSRC,        /* Preferred source address */
    RTA_METRICS,        /* Route metrics */
    RTA_MULTIPATH,      /* Multipath route */
    RTA_FLOW,           /* Flow classification */
    RTA_CACHEINFO,      /* Cache information */
    RTA_TABLE,          /* Routing table ID (extended) */
    // ... more
};
</code></pre>
<h3 id="example-adding-a-route"><a class="header" href="#example-adding-a-route">Example: Adding a Route</a></h3>
<pre><code class="language-c">#include &lt;linux/netlink.h&gt;
#include &lt;linux/rtnetlink.h&gt;
#include &lt;net/if.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int add_route(const char *dest, int prefixlen, const char *gateway, const char *ifname) {
    int sock;
    struct {
        struct nlmsghdr nlh;
        struct rtmsg rtm;
        char attrbuf[512];
    } req;
    struct rtattr *rta;
    struct in_addr dst_addr, gw_addr;
    int ifindex;

    /* Parse addresses */
    if (inet_pton(AF_INET, dest, &amp;dst_addr) != 1) {
        fprintf(stderr, "Invalid destination address\n");
        return -1;
    }

    if (gateway &amp;&amp; inet_pton(AF_INET, gateway, &amp;gw_addr) != 1) {
        fprintf(stderr, "Invalid gateway address\n");
        return -1;
    }

    /* Get interface index if specified */
    if (ifname) {
        ifindex = if_nametoindex(ifname);
        if (ifindex == 0) {
            perror("if_nametoindex");
            return -1;
        }
    }

    /* Create socket */
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock &lt; 0) {
        perror("socket");
        return -1;
    }

    /* Prepare request */
    memset(&amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));
    req.nlh.nlmsg_type = RTM_NEWROUTE;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;
    req.nlh.nlmsg_pid = getpid();

    req.rtm.rtm_family = AF_INET;
    req.rtm.rtm_dst_len = prefixlen;
    req.rtm.rtm_table = RT_TABLE_MAIN;
    req.rtm.rtm_protocol = RTPROT_BOOT;
    req.rtm.rtm_scope = RT_SCOPE_UNIVERSE;
    req.rtm.rtm_type = RTN_UNICAST;

    /* Add RTA_DST attribute */
    rta = (struct rtattr *)(((char *)&amp;req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    rta-&gt;rta_type = RTA_DST;
    rta-&gt;rta_len = RTA_LENGTH(sizeof(dst_addr));
    memcpy(RTA_DATA(rta), &amp;dst_addr, sizeof(dst_addr));
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(sizeof(dst_addr));

    /* Add RTA_GATEWAY attribute if specified */
    if (gateway) {
        rta = (struct rtattr *)(((char *)&amp;req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
        rta-&gt;rta_type = RTA_GATEWAY;
        rta-&gt;rta_len = RTA_LENGTH(sizeof(gw_addr));
        memcpy(RTA_DATA(rta), &amp;gw_addr, sizeof(gw_addr));
        req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(sizeof(gw_addr));
    }

    /* Add RTA_OIF attribute if specified */
    if (ifname) {
        rta = (struct rtattr *)(((char *)&amp;req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
        rta-&gt;rta_type = RTA_OIF;
        rta-&gt;rta_len = RTA_LENGTH(sizeof(ifindex));
        memcpy(RTA_DATA(rta), &amp;ifindex, sizeof(ifindex));
        req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(sizeof(ifindex));
    }

    /* Send request */
    if (send(sock, &amp;req, req.nlh.nlmsg_len, 0) &lt; 0) {
        perror("send");
        close(sock);
        return -1;
    }

    /* Check acknowledgment */
    char buf[4096];
    int len = recv(sock, buf, sizeof(buf), 0);
    struct nlmsghdr *nlh = (struct nlmsghdr *)buf;

    if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(nlh);
        if (err-&gt;error != 0) {
            fprintf(stderr, "Failed to add route: %s\n", strerror(-err-&gt;error));
            close(sock);
            return -1;
        }
    }

    close(sock);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc &lt; 3) {
        fprintf(stderr, "Usage: %s &lt;dest&gt; &lt;prefixlen&gt; [gateway] [interface]\n", argv[0]);
        fprintf(stderr, "Example: %s 192.168.2.0 24 192.168.1.1 eth0\n", argv[0]);
        return 1;
    }

    const char *dest = argv[1];
    int prefixlen = atoi(argv[2]);
    const char *gateway = argc &gt; 3 ? argv[3] : NULL;
    const char *ifname = argc &gt; 4 ? argv[4] : NULL;

    if (add_route(dest, prefixlen, gateway, ifname) == 0) {
        printf("Successfully added route\n");
        return 0;
    }

    return 1;
}
</code></pre>
<h3 id="monitoring-link-changes"><a class="header" href="#monitoring-link-changes">Monitoring Link Changes</a></h3>
<pre><code class="language-c">#include &lt;linux/netlink.h&gt;
#include &lt;linux/rtnetlink.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void monitor_link_changes() {
    int sock;
    struct sockaddr_nl sa;
    char buf[8192];

    /* Create socket */
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock &lt; 0) {
        perror("socket");
        return;
    }

    /* Bind to multicast groups */
    memset(&amp;sa, 0, sizeof(sa));
    sa.nl_family = AF_NETLINK;
    sa.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE;

    if (bind(sock, (struct sockaddr *)&amp;sa, sizeof(sa)) &lt; 0) {
        perror("bind");
        close(sock);
        return;
    }

    printf("Monitoring network changes...\n");

    /* Receive and process events */
    while (1) {
        struct nlmsghdr *nlh;
        int len = recv(sock, buf, sizeof(buf), 0);

        if (len &lt; 0) {
            perror("recv");
            break;
        }

        for (nlh = (struct nlmsghdr *)buf;
             NLMSG_OK(nlh, len);
             nlh = NLMSG_NEXT(nlh, len)) {

            if (nlh-&gt;nlmsg_type == RTM_NEWLINK || nlh-&gt;nlmsg_type == RTM_DELLINK) {
                struct ifinfomsg *ifi = NLMSG_DATA(nlh);
                const char *action = nlh-&gt;nlmsg_type == RTM_NEWLINK ? "NEW/UPDATE" : "DELETE";

                printf("LINK %s: index=%d flags=0x%x\n",
                       action, ifi-&gt;ifi_index, ifi-&gt;ifi_flags);

                /* Parse attributes */
                struct rtattr *rta = IFLA_RTA(ifi);
                int rtalen = IFLA_PAYLOAD(nlh);

                while (RTA_OK(rta, rtalen)) {
                    if (rta-&gt;rta_type == IFLA_IFNAME) {
                        printf("  Interface: %s\n", (char *)RTA_DATA(rta));
                    }
                    rta = RTA_NEXT(rta, rtalen);
                }
            } else if (nlh-&gt;nlmsg_type == RTM_NEWADDR || nlh-&gt;nlmsg_type == RTM_DELADDR) {
                struct ifaddrmsg *ifa = NLMSG_DATA(nlh);
                const char *action = nlh-&gt;nlmsg_type == RTM_NEWADDR ? "NEW" : "DELETE";

                printf("ADDR %s: family=%d index=%d\n",
                       action, ifa-&gt;ifa_family, ifa-&gt;ifa_index);
            } else if (nlh-&gt;nlmsg_type == RTM_NEWROUTE || nlh-&gt;nlmsg_type == RTM_DELROUTE) {
                struct rtmsg *rtm = NLMSG_DATA(nlh);
                const char *action = nlh-&gt;nlmsg_type == RTM_NEWROUTE ? "NEW" : "DELETE";

                printf("ROUTE %s: family=%d dst_len=%d\n",
                       action, rtm-&gt;rtm_family, rtm-&gt;rtm_dst_len);
            }
        }
    }

    close(sock);
}

int main() {
    monitor_link_changes();
    return 0;
}
</code></pre>
<h2 id="generic-netlink"><a class="header" href="#generic-netlink">Generic Netlink</a></h2>
<p>Generic Netlink (<code>NETLINK_GENERIC</code>) is a meta-protocol that allows kernel modules to create custom netlink families without needing a dedicated netlink protocol number. It’s the recommended way to add new netlink-based interfaces.</p>
<h3 id="why-generic-netlink"><a class="header" href="#why-generic-netlink">Why Generic Netlink?</a></h3>
<p><strong>Traditional Approach Problems</strong>:</p>
<ul>
<li>Limited number of netlink protocol numbers (0-31)</li>
<li>Each subsystem needs a dedicated protocol number</li>
<li>Protocol numbers are a scarce resource</li>
</ul>
<p><strong>Generic Netlink Solution</strong>:</p>
<ul>
<li>Multiplexes multiple “families” over a single protocol (<code>NETLINK_GENERIC</code>)</li>
<li>Dynamic family registration</li>
<li>Automatic command and attribute validation</li>
<li>Easier to add new interfaces</li>
</ul>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<pre><code class="language-mermaid">graph TB
    subgraph UserSpace["User Space"]
        App[Application]
    end

    subgraph KernelSpace["Kernel Space"]
        GNL[Generic Netlink Core]

        subgraph Families["Generic Netlink Families"]
            NL80211[nl80211&lt;br/&gt;WiFi]
            DEVLINK[devlink&lt;br/&gt;Device Config]
            TEAM[team&lt;br/&gt;Link Aggregation]
            TASKSTATS[taskstats&lt;br/&gt;Task Statistics]
            CUSTOM[Custom Family]
        end
    end

    App --&gt;|NETLINK_GENERIC| GNL
    GNL --&gt; NL80211
    GNL --&gt; DEVLINK
    GNL --&gt; TEAM
    GNL --&gt; TASKSTATS
    GNL --&gt; CUSTOM

    style UserSpace fill:#E6F3FF
    style KernelSpace fill:#FFE6E6
    style Families fill:#E6FFE6
</code></pre>
<h3 id="generic-netlink-message-structure"><a class="header" href="#generic-netlink-message-structure">Generic Netlink Message Structure</a></h3>
<pre><code class="language-c">struct genlmsghdr {
    __u8    cmd;        /* Command */
    __u8    version;    /* Version */
    __u16   reserved;   /* Reserved */
};
</code></pre>
<p>The complete message structure:</p>
<pre><code>+-------------------+
| nlmsghdr          |  &lt;- Standard netlink header
+-------------------+
| genlmsghdr        |  &lt;- Generic netlink header
+-------------------+
| Family Attributes |  &lt;- Family-specific data (TLV)
+-------------------+
</code></pre>
<h3 id="family-resolution"><a class="header" href="#family-resolution">Family Resolution</a></h3>
<p>Before using a generic netlink family, you must resolve its family ID:</p>
<pre><code class="language-c">#include &lt;linux/genetlink.h&gt;

#define GENL_CTRL_NAME "nlctrl"     /* Controller family name */
#define GENL_CTRL_VERSION 2

/* Get family ID by name */
int get_family_id(int sock, const char *family_name) {
    struct {
        struct nlmsghdr nlh;
        struct genlmsghdr gnlh;
        char attrbuf[512];
    } req;
    struct rtattr *rta;
    int family_id = -1;

    /* Prepare request to controller */
    memset(&amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
    req.nlh.nlmsg_type = GENL_ID_CTRL;  /* Controller family ID is always 0x10 */
    req.nlh.nlmsg_flags = NLM_F_REQUEST;
    req.nlh.nlmsg_seq = 1;
    req.nlh.nlmsg_pid = getpid();

    req.gnlh.cmd = CTRL_CMD_GETFAMILY;
    req.gnlh.version = GENL_CTRL_VERSION;

    /* Add family name attribute */
    rta = (struct rtattr *)(((char *)&amp;req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    rta-&gt;rta_type = CTRL_ATTR_FAMILY_NAME;
    rta-&gt;rta_len = RTA_LENGTH(strlen(family_name) + 1);
    strcpy(RTA_DATA(rta), family_name);
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_ALIGN(rta-&gt;rta_len);

    /* Send request */
    if (send(sock, &amp;req, req.nlh.nlmsg_len, 0) &lt; 0) {
        return -1;
    }

    /* Receive response and parse family ID */
    char buf[4096];
    int len = recv(sock, buf, sizeof(buf), 0);

    struct nlmsghdr *nlh = (struct nlmsghdr *)buf;
    if (NLMSG_OK(nlh, len) &amp;&amp; nlh-&gt;nlmsg_type != NLMSG_ERROR) {
        struct genlmsghdr *gnlh = (struct genlmsghdr *)NLMSG_DATA(nlh);
        rta = (struct rtattr *)((char *)gnlh + GENL_HDRLEN);
        int rtalen = nlh-&gt;nlmsg_len - NLMSG_LENGTH(GENL_HDRLEN);

        while (RTA_OK(rta, rtalen)) {
            if (rta-&gt;rta_type == CTRL_ATTR_FAMILY_ID) {
                family_id = *(__u16 *)RTA_DATA(rta);
                break;
            }
            rta = RTA_NEXT(rta, rtalen);
        }
    }

    return family_id;
}
</code></pre>
<h3 id="example-nl80211-wifi-configuration"><a class="header" href="#example-nl80211-wifi-configuration">Example: nl80211 (WiFi Configuration)</a></h3>
<p>nl80211 is one of the most commonly used generic netlink families for WiFi configuration.</p>
<p><strong>Listing WiFi Interfaces</strong>:</p>
<pre><code class="language-c">#include &lt;linux/netlink.h&gt;
#include &lt;linux/genetlink.h&gt;
#include &lt;linux/nl80211.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int list_wifi_interfaces() {
    int sock;
    struct {
        struct nlmsghdr nlh;
        struct genlmsghdr gnlh;
    } req;
    int nl80211_id;

    /* Create socket */
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
    if (sock &lt; 0) {
        perror("socket");
        return -1;
    }

    /* Get nl80211 family ID */
    nl80211_id = get_family_id(sock, "nl80211");
    if (nl80211_id &lt; 0) {
        fprintf(stderr, "Failed to get nl80211 family ID\n");
        close(sock);
        return -1;
    }

    /* Prepare request */
    memset(&amp;req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
    req.nlh.nlmsg_type = nl80211_id;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
    req.nlh.nlmsg_seq = 1;
    req.nlh.nlmsg_pid = getpid();

    req.gnlh.cmd = NL80211_CMD_GET_INTERFACE;
    req.gnlh.version = 1;

    /* Send request */
    if (send(sock, &amp;req, req.nlh.nlmsg_len, 0) &lt; 0) {
        perror("send");
        close(sock);
        return -1;
    }

    /* Receive and process response */
    char buf[8192];
    while (1) {
        struct nlmsghdr *nlh;
        int len = recv(sock, buf, sizeof(buf), 0);

        if (len &lt; 0) {
            perror("recv");
            break;
        }

        for (nlh = (struct nlmsghdr *)buf;
             NLMSG_OK(nlh, len);
             nlh = NLMSG_NEXT(nlh, len)) {

            if (nlh-&gt;nlmsg_type == NLMSG_DONE) {
                goto done;
            }

            if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
                fprintf(stderr, "Error in response\n");
                goto done;
            }

            struct genlmsghdr *gnlh = (struct genlmsghdr *)NLMSG_DATA(nlh);
            struct rtattr *rta = (struct rtattr *)((char *)gnlh + GENL_HDRLEN);
            int rtalen = nlh-&gt;nlmsg_len - NLMSG_LENGTH(GENL_HDRLEN);

            printf("WiFi Interface:\n");

            while (RTA_OK(rta, rtalen)) {
                if (rta-&gt;rta_type == NL80211_ATTR_IFNAME) {
                    printf("  Name: %s\n", (char *)RTA_DATA(rta));
                } else if (rta-&gt;rta_type == NL80211_ATTR_IFINDEX) {
                    printf("  Index: %u\n", *(__u32 *)RTA_DATA(rta));
                } else if (rta-&gt;rta_type == NL80211_ATTR_WIPHY) {
                    printf("  PHY: %u\n", *(__u32 *)RTA_DATA(rta));
                }
                rta = RTA_NEXT(rta, rtalen);
            }
            printf("\n");
        }
    }

done:
    close(sock);
    return 0;
}
</code></pre>
<h2 id="python-examples-with-pyroute2"><a class="header" href="#python-examples-with-pyroute2">Python Examples with pyroute2</a></h2>
<p>Working with netlink in C can be verbose. Python’s <code>pyroute2</code> library provides a much simpler interface.</p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<pre><code class="language-bash">pip install pyroute2
</code></pre>
<h3 id="example-listing-network-interfaces"><a class="header" href="#example-listing-network-interfaces">Example: Listing Network Interfaces</a></h3>
<pre><code class="language-python">from pyroute2 import IPRoute

# Create IPRoute object
ip = IPRoute()

# Get all links
links = ip.get_links()

for link in links:
    # Extract attributes
    attrs = dict(link['attrs'])

    print(f"Interface: {attrs.get('IFLA_IFNAME', 'unknown')}")
    print(f"  Index: {link['index']}")
    print(f"  State: {'UP' if link['flags'] &amp; 1 else 'DOWN'}")
    print(f"  MTU: {attrs.get('IFLA_MTU', 'N/A')}")

    if 'IFLA_ADDRESS' in attrs:
        mac = ':'.join(f'{b:02x}' for b in attrs['IFLA_ADDRESS'])
        print(f"  MAC: {mac}")
    print()

# Close connection
ip.close()
</code></pre>
<h3 id="example-adding-an-ip-address-1"><a class="header" href="#example-adding-an-ip-address-1">Example: Adding an IP Address</a></h3>
<pre><code class="language-python">from pyroute2 import IPRoute

ip = IPRoute()

# Get interface index
idx = ip.link_lookup(ifname='eth0')[0]

# Add IP address
ip.addr('add', index=idx, address='192.168.1.100', prefixlen=24)

# Verify
addrs = ip.get_addr(index=idx)
for addr in addrs:
    attrs = dict(addr['attrs'])
    if 'IFA_ADDRESS' in attrs:
        print(f"Address: {attrs['IFA_ADDRESS']}/{addr['prefixlen']}")

ip.close()
</code></pre>
<h3 id="example-managing-routes"><a class="header" href="#example-managing-routes">Example: Managing Routes</a></h3>
<pre><code class="language-python">from pyroute2 import IPRoute

ip = IPRoute()

# Add a route
ip.route('add', dst='192.168.2.0/24', gateway='192.168.1.1')

# List routes
routes = ip.get_routes(family=2)  # AF_INET

for route in routes:
    attrs = dict(route['attrs'])
    dst = attrs.get('RTA_DST', 'default')
    gateway = attrs.get('RTA_GATEWAY', 'direct')

    print(f"Route: {dst}/{route.get('dst_len', 0)} via {gateway}")

# Delete a route
ip.route('del', dst='192.168.2.0/24', gateway='192.168.1.1')

ip.close()
</code></pre>
<h3 id="example-monitoring-network-events"><a class="header" href="#example-monitoring-network-events">Example: Monitoring Network Events</a></h3>
<pre><code class="language-python">from pyroute2 import IPRoute

ip = IPRoute()

# Bind to multicast groups
ip.bind()

print("Monitoring network events... (Ctrl+C to stop)")

try:
    for message in ip.get():
        event = message.get('event')

        if event == 'RTM_NEWLINK':
            attrs = dict(message['attrs'])
            ifname = attrs.get('IFLA_IFNAME', 'unknown')
            print(f"Link added/changed: {ifname}")

        elif event == 'RTM_DELLINK':
            attrs = dict(message['attrs'])
            ifname = attrs.get('IFLA_IFNAME', 'unknown')
            print(f"Link deleted: {ifname}")

        elif event == 'RTM_NEWADDR':
            attrs = dict(message['attrs'])
            addr = attrs.get('IFA_ADDRESS', 'N/A')
            print(f"Address added: {addr}")

        elif event == 'RTM_DELADDR':
            attrs = dict(message['attrs'])
            addr = attrs.get('IFA_ADDRESS', 'N/A')
            print(f"Address deleted: {addr}")

except KeyboardInterrupt:
    print("\nStopped monitoring")

ip.close()
</code></pre>
<h3 id="example-creating-a-vlan-interface"><a class="header" href="#example-creating-a-vlan-interface">Example: Creating a VLAN Interface</a></h3>
<pre><code class="language-python">from pyroute2 import IPRoute

ip = IPRoute()

try:
    # Get parent interface index
    parent_idx = ip.link_lookup(ifname='eth0')[0]

    # Create VLAN interface
    ip.link('add',
            ifname='eth0.100',
            kind='vlan',
            link=parent_idx,
            vlan_id=100)

    # Get new interface index
    vlan_idx = ip.link_lookup(ifname='eth0.100')[0]

    # Bring interface up
    ip.link('set', index=vlan_idx, state='up')

    # Add IP address
    ip.addr('add', index=vlan_idx, address='10.0.100.1', prefixlen=24)

    print("VLAN interface eth0.100 created successfully")

except Exception as e:
    print(f"Error: {e}")

ip.close()
</code></pre>
<h2 id="netlink-libraries"><a class="header" href="#netlink-libraries">Netlink Libraries</a></h2>
<h3 id="libnl-c-library"><a class="header" href="#libnl-c-library">libnl (C Library)</a></h3>
<p>libnl is the standard C library for netlink programming, providing high-level abstractions.</p>
<p><strong>Installation</strong>:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install libnl-3-dev libnl-route-3-dev libnl-genl-3-dev

# Fedora/RHEL
sudo dnf install libnl3-devel
</code></pre>
<p><strong>Example</strong>:</p>
<pre><code class="language-c">#include &lt;netlink/netlink.h&gt;
#include &lt;netlink/route/link.h&gt;

int main() {
    struct nl_sock *sock;
    struct nl_cache *link_cache;
    struct rtnl_link *link;

    /* Allocate socket */
    sock = nl_socket_alloc();
    if (!sock) {
        return -1;
    }

    /* Connect to route netlink */
    nl_connect(sock, NETLINK_ROUTE);

    /* Allocate link cache */
    rtnl_link_alloc_cache(sock, AF_UNSPEC, &amp;link_cache);

    /* Iterate through links */
    link = (struct rtnl_link *)nl_cache_get_first(link_cache);
    while (link) {
        printf("Interface: %s\n", rtnl_link_get_name(link));
        printf("  Index: %d\n", rtnl_link_get_ifindex(link));
        printf("  MTU: %u\n", rtnl_link_get_mtu(link));

        link = (struct rtnl_link *)nl_cache_get_next((struct nl_object *)link);
    }

    /* Cleanup */
    nl_cache_free(link_cache);
    nl_socket_free(sock);

    return 0;
}
</code></pre>
<p><strong>Compilation</strong>:</p>
<pre><code class="language-bash">gcc -o example example.c $(pkg-config --cflags --libs libnl-3.0 libnl-route-3.0)
</code></pre>
<h3 id="pyroute2-python"><a class="header" href="#pyroute2-python">pyroute2 (Python)</a></h3>
<p>We’ve already seen several examples above. pyroute2 is the most popular Python library for netlink.</p>
<p><strong>Features</strong>:</p>
<ul>
<li>IPRoute: Network interface and routing management</li>
<li>IPDB: Transactional interface for network configuration</li>
<li>Generic netlink support</li>
<li>Network namespace support</li>
<li>Async/await support</li>
</ul>
<h3 id="other-libraries"><a class="header" href="#other-libraries">Other Libraries</a></h3>
<p><strong>Rust</strong>:</p>
<ul>
<li><code>netlink-rs</code>: Rust bindings for netlink</li>
<li><code>rtnetlink</code>: High-level rtnetlink API</li>
</ul>
<p><strong>Go</strong>:</p>
<ul>
<li><code>vishvananda/netlink</code>: Popular Go netlink library</li>
<li><code>mdlayher/netlink</code>: Low-level netlink library</li>
</ul>
<h2 id="tools-using-netlink"><a class="header" href="#tools-using-netlink">Tools Using Netlink</a></h2>
<h3 id="iproute2"><a class="header" href="#iproute2">iproute2</a></h3>
<p>The <code>ip</code> command is the primary tool for network configuration on Linux, using rtnetlink.</p>
<p><strong>Common Commands</strong>:</p>
<pre><code class="language-bash"># Link management
ip link show
ip link set eth0 up
ip link set eth0 down
ip link set eth0 mtu 9000

# Address management
ip addr show
ip addr add 192.168.1.100/24 dev eth0
ip addr del 192.168.1.100/24 dev eth0

# Route management
ip route show
ip route add 192.168.2.0/24 via 192.168.1.1
ip route del 192.168.2.0/24

# Neighbor (ARP) management
ip neigh show
ip neigh add 192.168.1.1 lladdr 00:11:22:33:44:55 dev eth0
</code></pre>
<h3 id="iw"><a class="header" href="#iw">iw</a></h3>
<p>WiFi configuration tool using nl80211:</p>
<pre><code class="language-bash"># List WiFi devices
iw dev

# Scan for networks
iw dev wlan0 scan

# Connect to network
iw dev wlan0 connect "SSID"

# Get interface info
iw dev wlan0 info

# Set channel
iw dev wlan0 set channel 6
</code></pre>
<h3 id="ss-socket-statistics"><a class="header" href="#ss-socket-statistics">ss (Socket Statistics)</a></h3>
<p>Uses <code>NETLINK_SOCK_DIAG</code> for socket information:</p>
<pre><code class="language-bash"># Show all TCP sockets
ss -t

# Show listening sockets
ss -l

# Show detailed information
ss -e

# Show socket memory usage
ss -m

# Filter by state
ss state established
</code></pre>
<h3 id="ethtool"><a class="header" href="#ethtool">ethtool</a></h3>
<p>Some operations use netlink (newer versions):</p>
<pre><code class="language-bash"># Show interface statistics
ethtool -S eth0

# Show driver info
ethtool -i eth0

# Set speed/duplex
ethtool -s eth0 speed 1000 duplex full
</code></pre>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="netlink-error-handling"><a class="header" href="#netlink-error-handling">Netlink Error Handling</a></h3>
<p>Netlink errors are returned via <code>NLMSG_ERROR</code> messages:</p>
<pre><code class="language-c">struct nlmsgerr {
    int error;                  /* Negative errno or 0 for ack */
    struct nlmsghdr msg;        /* Original request header */
};
</code></pre>
<p><strong>Handling Errors</strong>:</p>
<pre><code class="language-c">if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
    struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(nlh);

    if (err-&gt;error == 0) {
        /* Success acknowledgment */
        printf("Success\n");
    } else {
        /* Error occurred */
        fprintf(stderr, "Netlink error: %s\n", strerror(-err-&gt;error));
    }
}
</code></pre>
<h3 id="extended-acknowledgments"><a class="header" href="#extended-acknowledgments">Extended Acknowledgments</a></h3>
<p>Modern kernels support extended acknowledgments with error messages:</p>
<pre><code class="language-c">/* Request extended ack */
int val = 1;
setsockopt(sock, SOL_NETLINK, NETLINK_EXT_ACK, &amp;val, sizeof(val));
</code></pre>
<p>When enabled, error messages can include:</p>
<ul>
<li>Human-readable error strings</li>
<li>Attribute that caused the error</li>
<li>Error offset in message</li>
</ul>
<h3 id="multi-part-messages"><a class="header" href="#multi-part-messages">Multi-part Messages</a></h3>
<p>Large responses are sent as multi-part messages:</p>
<pre><code class="language-c">/* Request with DUMP flag */
req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;

/* Receive loop */
while (1) {
    len = recv(sock, buf, sizeof(buf), 0);

    for (nlh = (struct nlmsghdr *)buf;
         NLMSG_OK(nlh, len);
         nlh = NLMSG_NEXT(nlh, len)) {

        if (nlh-&gt;nlmsg_type == NLMSG_DONE) {
            goto done;  /* End of multi-part */
        }

        /* Process message */
        process_message(nlh);
    }
}
</code></pre>
<h3 id="netlink-socket-options"><a class="header" href="#netlink-socket-options">Netlink Socket Options</a></h3>
<pre><code class="language-c">/* Set receive buffer size */
int bufsize = 32768;
setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, sizeof(bufsize));

/* Enable broadcast */
int val = 1;
setsockopt(sock, SOL_NETLINK, NETLINK_BROADCAST_ERROR, &amp;val, sizeof(val));

/* Enable listening to all namespaces */
setsockopt(sock, SOL_NETLINK, NETLINK_LISTEN_ALL_NSID, &amp;val, sizeof(val));

/* Disable auto-ack */
val = 0;
setsockopt(sock, SOL_NETLINK, NETLINK_NO_ENOBUFS, &amp;val, sizeof(val));
</code></pre>
<h3 id="network-namespaces"><a class="header" href="#network-namespaces">Network Namespaces</a></h3>
<p>Netlink operates within network namespaces:</p>
<pre><code class="language-c">/* Open namespace file descriptor */
int nsfd = open("/var/run/netns/myns", O_RDONLY);

/* Switch to namespace */
setns(nsfd, CLONE_NEWNET);

/* Now netlink operations affect the new namespace */
int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
/* ... */
</code></pre>
<p><strong>Python Example</strong>:</p>
<pre><code class="language-python">from pyroute2 import NetNS

# Open namespace
ns = NetNS('myns')

# List interfaces in namespace
links = ns.get_links()

# Close namespace
ns.close()
</code></pre>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<p><strong>Batching Requests</strong>:</p>
<pre><code class="language-c">/* Send multiple requests in one syscall */
struct iovec iov[10];
for (int i = 0; i &lt; 10; i++) {
    /* Prepare each message */
    iov[i].iov_base = &amp;requests[i];
    iov[i].iov_len = requests[i].nlh.nlmsg_len;
}

struct msghdr msg = {
    .msg_iov = iov,
    .msg_iovlen = 10,
};
sendmsg(sock, &amp;msg, 0);
</code></pre>
<p><strong>Buffer Size</strong>:</p>
<ul>
<li>Use large buffers (32KB+) for DUMP operations</li>
<li>Set SO_RCVBUF to avoid message drops</li>
<li>Monitor ENOBUFS errors</li>
</ul>
<p><strong>Message Size</strong>:</p>
<ul>
<li>Keep messages under page size (4KB) when possible</li>
<li>Use NLM_F_MULTI for large data transfers</li>
</ul>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<p><strong>Capabilities Required</strong>:</p>
<ul>
<li>Most netlink operations require <code>CAP_NET_ADMIN</code></li>
<li>Read-only operations (GET) typically allowed for all users</li>
<li>Modify operations (NEW/DEL/SET) require privileges</li>
</ul>
<p><strong>Checking Permissions</strong>:</p>
<pre><code class="language-c">#include &lt;sys/capability.h&gt;

int check_net_admin() {
    cap_t caps = cap_get_proc();
    cap_flag_value_t value;

    cap_get_flag(caps, CAP_NET_ADMIN, CAP_EFFECTIVE, &amp;value);
    cap_free(caps);

    return value == CAP_SET;
}
</code></pre>
<p><strong>Port ID Validation</strong>:</p>
<ul>
<li>Always validate sender’s port ID</li>
<li>Kernel messages always have nl_pid = 0</li>
<li>User messages should match their PID</li>
</ul>
<h2 id="debugging-netlink"><a class="header" href="#debugging-netlink">Debugging Netlink</a></h2>
<h3 id="using-strace"><a class="header" href="#using-strace">Using strace</a></h3>
<pre><code class="language-bash"># Trace netlink syscalls
strace -e sendto,recvfrom,bind,socket ip link show

# Show data in hex
strace -e trace=sendto,recvfrom -x ip addr show

# Follow forks
strace -f -e trace=network ip link show
</code></pre>
<h3 id="using-nlmon"><a class="header" href="#using-nlmon">Using nlmon</a></h3>
<p>Create a netlink monitor interface:</p>
<pre><code class="language-bash"># Load module
modprobe nlmon

# Create interface
ip link add nlmon0 type nlmon
ip link set nlmon0 up

# Capture with tcpdump
tcpdump -i nlmon0 -w netlink.pcap

# Or with Wireshark
wireshark -i nlmon0
</code></pre>
<h3 id="wireshark-dissectors"><a class="header" href="#wireshark-dissectors">Wireshark Dissectors</a></h3>
<p>Wireshark can dissect netlink messages:</p>
<ul>
<li>rtnetlink messages</li>
<li>Generic netlink messages</li>
<li>nl80211 (WiFi) messages</li>
</ul>
<h3 id="manual-parsing"><a class="header" href="#manual-parsing">Manual Parsing</a></h3>
<pre><code class="language-bash"># Dump netlink messages in hex
ip -d link show | od -A x -t x1z -v

# Use hexdump for better formatting
ip link show 2&gt;&amp;1 | hexdump -C
</code></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-incorrect-message-alignment"><a class="header" href="#1-incorrect-message-alignment">1. Incorrect Message Alignment</a></h3>
<p><strong>Wrong</strong>:</p>
<pre><code class="language-c">req.nlh.nlmsg_len = sizeof(struct nlmsghdr) + sizeof(struct ifinfomsg);
</code></pre>
<p><strong>Correct</strong>:</p>
<pre><code class="language-c">req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
</code></pre>
<h3 id="2-not-checking-nlmsg_error"><a class="header" href="#2-not-checking-nlmsg_error">2. Not Checking NLMSG_ERROR</a></h3>
<p>Always check for error responses:</p>
<pre><code class="language-c">if (nlh-&gt;nlmsg_type == NLMSG_ERROR) {
    struct nlmsgerr *err = NLMSG_DATA(nlh);
    if (err-&gt;error != 0) {
        /* Handle error */
    }
}
</code></pre>
<h3 id="3-buffer-too-small"><a class="header" href="#3-buffer-too-small">3. Buffer Too Small</a></h3>
<p>Use adequately sized buffers for DUMP operations:</p>
<pre><code class="language-c">char buf[32768];  /* 32KB is recommended */
</code></pre>
<h3 id="4-not-handling-multi-part-messages"><a class="header" href="#4-not-handling-multi-part-messages">4. Not Handling Multi-part Messages</a></h3>
<p>Always loop until NLMSG_DONE:</p>
<pre><code class="language-c">while (1) {
    for (nlh = ...; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) {
        if (nlh-&gt;nlmsg_type == NLMSG_DONE) goto done;
        /* ... */
    }
}
</code></pre>
<h3 id="5-incorrect-attribute-parsing"><a class="header" href="#5-incorrect-attribute-parsing">5. Incorrect Attribute Parsing</a></h3>
<p>Always use macros for attribute manipulation:</p>
<pre><code class="language-c">/* Wrong */
rta = (struct rtattr *)((char *)ifi + sizeof(*ifi));

/* Correct */
rta = IFLA_RTA(ifi);
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Netlink is a powerful and flexible IPC mechanism that has become the standard for kernel-userspace communication in Linux. Key takeaways:</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Bidirectional, asynchronous communication</li>
<li>Multicast support for event notifications</li>
<li>Extensible TLV format</li>
<li>Type-safe and efficient binary protocol</li>
</ul>
<p><strong>Common Use Cases</strong>:</p>
<ul>
<li>Network configuration (rtnetlink)</li>
<li>WiFi management (nl80211)</li>
<li>Firewall rules (netfilter)</li>
<li>Device events (kobject_uevent)</li>
<li>Custom kernel modules (generic netlink)</li>
</ul>
<p><strong>Best Practices</strong>:</p>
<ul>
<li>Use libraries (libnl, pyroute2) for simpler code</li>
<li>Always check for errors via NLMSG_ERROR</li>
<li>Use proper alignment macros</li>
<li>Handle multi-part messages correctly</li>
<li>Set appropriate buffer sizes</li>
</ul>
<p><strong>Resources</strong>:</p>
<ul>
<li>Kernel Documentation: <code>Documentation/userspace-api/netlink/</code></li>
<li>libnl: https://www.infradead.org/~tgr/libnl/</li>
<li>pyroute2: https://docs.pyroute2.org/</li>
<li>iproute2 source code: https://git.kernel.org/pub/scm/network/iproute2/iproute2.git</li>
</ul>
<p>Netlink continues to evolve, with new families and features being added regularly. Understanding netlink is essential for anyone working with Linux networking, device management, or kernel-userspace communication.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/ebpf.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../linux/commands.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/ebpf.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../linux/commands.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
