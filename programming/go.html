<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Go - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-programming"><a class="header" href="#go-programming">Go Programming</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Go (Golang) is a statically typed, compiled programming language designed at Google. It's known for its simplicity, efficiency, and excellent support for concurrent programming.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>Fast compilation and execution</li>
<li>Built-in concurrency (goroutines and channels)</li>
<li>Garbage collection</li>
<li>Strong static typing with type inference</li>
<li>Simple and clean syntax</li>
<li>Excellent standard library</li>
<li>Cross-platform compilation</li>
</ul>
<hr />
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<h3 id="variables-and-data-types"><a class="header" href="#variables-and-data-types">Variables and Data Types</a></h3>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Variable declaration
    var name string = "Alice"
    var age int = 30

    // Short declaration (type inference)
    city := "NYC"
    isActive := true

    // Multiple declarations
    var x, y, z int = 1, 2, 3
    a, b := 10, 20

    // Constants
    const PI = 3.14159
    const MaxSize = 100

    // Zero values (default values)
    var num int        // 0
    var str string     // ""
    var flag bool      // false
    var ptr *int       // nil

    fmt.Println(name, age, city, isActive)
}
</code></pre>
<h3 id="data-types"><a class="header" href="#data-types">Data Types</a></h3>
<pre><code class="language-go">// Basic types
var i int = 42           // Platform-dependent (32 or 64 bit)
var i8 int8 = 127        // 8-bit
var i16 int16 = 32767    // 16-bit
var i32 int32 = 2147483647  // 32-bit (rune alias)
var i64 int64 = 9223372036854775807  // 64-bit

var u uint = 42          // Unsigned, platform-dependent
var u8 uint8 = 255       // 8-bit (byte alias)

var f32 float32 = 3.14   // 32-bit float
var f64 float64 = 3.14159  // 64-bit float

var c64 complex64 = 1 + 2i
var c128 complex128 = 1 + 2i

var b bool = true
var r rune = 'A'         // Unicode code point (int32)
var by byte = 65         // Alias for uint8

var str string = "Hello, 世界"

// Type conversion
var x int = 42
var y float64 = float64(x)
var z uint = uint(x)
</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<pre><code class="language-go">// String operations
s1 := "Hello"
s2 := "World"

// Concatenation
full := s1 + " " + s2

// Length (bytes, not runes)
length := len(s1)

// Accessing bytes
firstByte := s1[0]

// Substrings
sub := s1[1:4]  // "ell"

// String comparison
if s1 == s2 {
    fmt.Println("Equal")
}

// Multi-line strings
multiline := `This is a
multi-line
string`

// String iteration
for i, char := range "Hello" {
    fmt.Printf("%d: %c\n", i, char)
}

// String formatting
import "fmt"
formatted := fmt.Sprintf("Name: %s, Age: %d", "Alice", 30)

// String conversion
import "strconv"
numStr := strconv.Itoa(42)        // int to string
num, err := strconv.Atoi("42")    // string to int
</code></pre>
<hr />
<h2 id="arrays-and-slices"><a class="header" href="#arrays-and-slices">Arrays and Slices</a></h2>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<pre><code class="language-go">// Fixed-size arrays
var arr [5]int
arr[0] = 1

// Array literal
numbers := [5]int{1, 2, 3, 4, 5}

// Compiler counts length
auto := [...]int{1, 2, 3, 4}

// Multi-dimensional arrays
matrix := [3][3]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

// Array length
length := len(numbers)

// Iterate over array
for i, v := range numbers {
    fmt.Printf("%d: %d\n", i, v)
}
</code></pre>
<h3 id="slices-dynamic-arrays"><a class="header" href="#slices-dynamic-arrays">Slices (Dynamic Arrays)</a></h3>
<pre><code class="language-go">// Creating slices
var slice []int                    // nil slice
slice = []int{1, 2, 3, 4, 5}      // slice literal
slice = make([]int, 5)             // length 5, all zeros
slice = make([]int, 5, 10)         // length 5, capacity 10

// Append to slice
slice = append(slice, 6)
slice = append(slice, 7, 8, 9)

// Slice operations
arr := []int{1, 2, 3, 4, 5}
sub := arr[1:4]        // [2, 3, 4]
first := arr[:3]       // [1, 2, 3]
last := arr[3:]        // [4, 5]

// Length and capacity
len := len(slice)
cap := cap(slice)

// Copy slices
src := []int{1, 2, 3}
dst := make([]int, len(src))
copy(dst, src)

// 2D slices
matrix := [][]int{
    {1, 2, 3},
    {4, 5, 6},
}

// Iterate
for i, v := range slice {
    fmt.Printf("%d: %d\n", i, v)
}
</code></pre>
<hr />
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<pre><code class="language-go">// Creating maps
var m map[string]int               // nil map
m = make(map[string]int)           // empty map
m = map[string]int{                // map literal
    "Alice": 25,
    "Bob":   30,
}

// Adding/updating elements
m["Charlie"] = 35
m["Alice"] = 26

// Accessing elements
age := m["Alice"]

// Check if key exists
age, ok := m["Alice"]
if ok {
    fmt.Println("Alice's age:", age)
}

// Delete element
delete(m, "Bob")

// Iterate over map
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// Map length
size := len(m)

// Nested maps
nested := map[string]map[string]int{
    "group1": {
        "Alice": 25,
        "Bob":   30,
    },
    "group2": {
        "Charlie": 35,
    },
}
</code></pre>
<hr />
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="if-else"><a class="header" href="#if-else">If-Else</a></h3>
<pre><code class="language-go">age := 18

if age &lt; 13 {
    fmt.Println("Child")
} else if age &lt; 20 {
    fmt.Println("Teenager")
} else {
    fmt.Println("Adult")
}

// If with initialization
if num := 42; num &gt; 0 {
    fmt.Println("Positive")
}

// Error checking pattern
if err := someFunction(); err != nil {
    fmt.Println("Error:", err)
}
</code></pre>
<h3 id="switch"><a class="header" href="#switch">Switch</a></h3>
<pre><code class="language-go">// Basic switch
day := 3
switch day {
case 1:
    fmt.Println("Monday")
case 2:
    fmt.Println("Tuesday")
case 3:
    fmt.Println("Wednesday")
default:
    fmt.Println("Other day")
}

// Multiple cases
switch day {
case 1, 2, 3, 4, 5:
    fmt.Println("Weekday")
case 6, 7:
    fmt.Println("Weekend")
}

// Switch with condition
num := 42
switch {
case num &lt; 0:
    fmt.Println("Negative")
case num == 0:
    fmt.Println("Zero")
case num &gt; 0:
    fmt.Println("Positive")
}

// Type switch
var i interface{} = "hello"
switch v := i.(type) {
case string:
    fmt.Println("String:", v)
case int:
    fmt.Println("Int:", v)
default:
    fmt.Println("Unknown type")
}
</code></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<pre><code class="language-go">// For loop (only loop in Go)
for i := 0; i &lt; 5; i++ {
    fmt.Println(i)
}

// While-style loop
count := 0
for count &lt; 5 {
    fmt.Println(count)
    count++
}

// Infinite loop
for {
    fmt.Println("Forever")
    break  // Exit loop
}

// Range over slice
numbers := []int{1, 2, 3, 4, 5}
for i, v := range numbers {
    fmt.Printf("%d: %d\n", i, v)
}

// Range over map
m := map[string]int{"a": 1, "b": 2}
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// Ignore index/value with _
for _, v := range numbers {
    fmt.Println(v)
}

// Break and continue
for i := 0; i &lt; 10; i++ {
    if i == 5 {
        continue
    }
    if i == 8 {
        break
    }
    fmt.Println(i)
}
</code></pre>
<hr />
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="basic-functions"><a class="header" href="#basic-functions">Basic Functions</a></h3>
<pre><code class="language-go">// Simple function
func greet(name string) {
    fmt.Println("Hello,", name)
}

// Function with return value
func add(a, b int) int {
    return a + b
}

// Multiple parameters of same type
func multiply(a, b, c int) int {
    return a * b * c
}

// Multiple return values
func swap(a, b string) (string, string) {
    return b, a
}

// Named return values
func divide(a, b float64) (result float64, err error) {
    if b == 0 {
        err = fmt.Errorf("division by zero")
        return
    }
    result = a / b
    return  // Naked return
}

// Variadic functions
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// Usage
result := sum(1, 2, 3, 4, 5)
</code></pre>
<h3 id="anonymous-functions-and-closures"><a class="header" href="#anonymous-functions-and-closures">Anonymous Functions and Closures</a></h3>
<pre><code class="language-go">// Anonymous function
add := func(a, b int) int {
    return a + b
}
result := add(5, 3)

// Immediately invoked function
result := func(a, b int) int {
    return a + b
}(5, 3)

// Closure
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

c := counter()
fmt.Println(c())  // 1
fmt.Println(c())  // 2
fmt.Println(c())  // 3
</code></pre>
<h3 id="defer"><a class="header" href="#defer">Defer</a></h3>
<pre><code class="language-go">// Defer executes at function end
func example() {
    defer fmt.Println("World")
    fmt.Println("Hello")
}
// Output: Hello
//         World

// Multiple defers (LIFO order)
func multiDefer() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
// Output: 3, 2, 1

// Common pattern: cleanup
func readFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()

    // Work with file
    return nil
}
</code></pre>
<hr />
<h2 id="structs-and-methods"><a class="header" href="#structs-and-methods">Structs and Methods</a></h2>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<pre><code class="language-go">// Define struct
type Person struct {
    Name string
    Age  int
    Email string
}

// Create struct
p1 := Person{
    Name:  "Alice",
    Age:   30,
    Email: "alice@example.com",
}

// Short form
p2 := Person{"Bob", 25, "bob@example.com"}

// Anonymous struct
person := struct {
    name string
    age  int
}{
    name: "Charlie",
    age:  35,
}

// Accessing fields
fmt.Println(p1.Name)
p1.Age = 31

// Pointer to struct
p := &amp;Person{Name: "Alice", Age: 30}
p.Age = 31  // Automatic dereferencing

// Embedded structs
type Address struct {
    City    string
    Country string
}

type Employee struct {
    Person   // Embedded struct
    Address  // Embedded struct
    Salary   float64
}

emp := Employee{
    Person:  Person{Name: "Alice", Age: 30},
    Address: Address{City: "NYC", Country: "USA"},
    Salary:  100000,
}

// Access embedded fields
fmt.Println(emp.Name)  // From Person
fmt.Println(emp.City)  // From Address
</code></pre>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<pre><code class="language-go">// Method on struct
type Rectangle struct {
    Width  float64
    Height float64
}

// Value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Pointer receiver (can modify)
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// Usage
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()
rect.Scale(2)

// Method on any type
type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}

num := MyInt(5)
result := num.Double()  // 10
</code></pre>
<hr />
<h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<pre><code class="language-go">// Define interface
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Implement interface (implicit)
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * 3.14159 * c.Radius
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// Use interface
func printArea(s Shape) {
    fmt.Printf("Area: %.2f\n", s.Area())
}

// Usage
c := Circle{Radius: 5}
r := Rectangle{Width: 10, Height: 5}

printArea(c)
printArea(r)

// Empty interface (any type)
func printAnything(v interface{}) {
    fmt.Println(v)
}

printAnything(42)
printAnything("hello")
printAnything(true)

// Type assertion
var i interface{} = "hello"
s := i.(string)
s, ok := i.(string)  // Safe type assertion

// Type switch
switch v := i.(type) {
case string:
    fmt.Println("String:", v)
case int:
    fmt.Println("Int:", v)
default:
    fmt.Println("Unknown")
}
</code></pre>
<hr />
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h3 id="goroutines"><a class="header" href="#goroutines">Goroutines</a></h3>
<pre><code class="language-go">// Start goroutine
go func() {
    fmt.Println("Hello from goroutine")
}()

// Multiple goroutines
for i := 0; i &lt; 5; i++ {
    go func(n int) {
        fmt.Println("Goroutine", n)
    }(i)
}

// Wait for goroutines
import "sync"

var wg sync.WaitGroup

for i := 0; i &lt; 5; i++ {
    wg.Add(1)
    go func(n int) {
        defer wg.Done()
        fmt.Println("Worker", n)
    }(i)
}

wg.Wait()
</code></pre>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<pre><code class="language-go">// Create channel
ch := make(chan int)

// Buffered channel
ch := make(chan int, 5)

// Send to channel
go func() {
    ch &lt;- 42
}()

// Receive from channel
value := &lt;-ch

// Close channel
close(ch)

// Range over channel
go func() {
    for i := 0; i &lt; 5; i++ {
        ch &lt;- i
    }
    close(ch)
}()

for value := range ch {
    fmt.Println(value)
}

// Select statement
ch1 := make(chan string)
ch2 := make(chan string)

go func() {
    ch1 &lt;- "from ch1"
}()

go func() {
    ch2 &lt;- "from ch2"
}()

select {
case msg1 := &lt;-ch1:
    fmt.Println(msg1)
case msg2 := &lt;-ch2:
    fmt.Println(msg2)
case &lt;-time.After(1 * time.Second):
    fmt.Println("timeout")
}
</code></pre>
<h3 id="sync-package"><a class="header" href="#sync-package">Sync Package</a></h3>
<pre><code class="language-go">import "sync"

// Mutex
var (
    mu    sync.Mutex
    count int
)

func increment() {
    mu.Lock()
    defer mu.Unlock()
    count++
}

// RWMutex (multiple readers, single writer)
var (
    rwMu sync.RWMutex
    data map[string]int
)

func read(key string) int {
    rwMu.RLock()
    defer rwMu.RUnlock()
    return data[key]
}

func write(key string, value int) {
    rwMu.Lock()
    defer rwMu.Unlock()
    data[key] = value
}

// Once (execute only once)
var once sync.Once

func initialize() {
    once.Do(func() {
        fmt.Println("Initialized")
    })
}
</code></pre>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<pre><code class="language-go">import "errors"
import "fmt"

// Return error
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// Formatted error
func validateAge(age int) error {
    if age &lt; 0 {
        return fmt.Errorf("invalid age: %d", age)
    }
    return nil
}

// Custom error type
type ValidationError struct {
    Field string
    Value interface{}
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error: %s = %v", e.Field, e.Value)
}

// Error handling pattern
result, err := divide(10, 0)
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Println("Result:", result)

// Panic and recover
func riskyOperation() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()

    panic("something went wrong")
}
</code></pre>
<hr />
<h2 id="packages-and-imports"><a class="header" href="#packages-and-imports">Packages and Imports</a></h2>
<pre><code class="language-go">// Package declaration
package main

// Import single package
import "fmt"

// Import multiple packages
import (
    "fmt"
    "math"
    "strings"
)

// Aliased import
import f "fmt"
f.Println("Hello")

// Blank import (side effects)
import _ "database/sql/driver"

// Creating a package
// mypackage/mypackage.go
package mypackage

// Exported (capitalized)
func PublicFunction() {
    fmt.Println("Public")
}

// Not exported (lowercase)
func privateFunction() {
    fmt.Println("Private")
}

// Using the package
import "myproject/mypackage"

mypackage.PublicFunction()
</code></pre>
<hr />
<h2 id="file-io"><a class="header" href="#file-io">File I/O</a></h2>
<pre><code class="language-go">import (
    "bufio"
    "fmt"
    "io/ioutil"
    "os"
)

// Read entire file
data, err := ioutil.ReadFile("file.txt")
if err != nil {
    panic(err)
}
fmt.Println(string(data))

// Write file
err = ioutil.WriteFile("output.txt", []byte("Hello"), 0644)

// Open file
file, err := os.Open("file.txt")
if err != nil {
    panic(err)
}
defer file.Close()

// Read line by line
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    fmt.Println(scanner.Text())
}

// Write to file
file, err := os.Create("output.txt")
if err != nil {
    panic(err)
}
defer file.Close()

writer := bufio.NewWriter(file)
writer.WriteString("Hello, World!\n")
writer.Flush()
</code></pre>
<hr />
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="singleton"><a class="header" href="#singleton">Singleton</a></h3>
<pre><code class="language-go">import "sync"

type singleton struct {
    data string
}

var (
    instance *singleton
    once     sync.Once
)

func GetInstance() *singleton {
    once.Do(func() {
        instance = &amp;singleton{data: "singleton"}
    })
    return instance
}
</code></pre>
<h3 id="factory-pattern"><a class="header" href="#factory-pattern">Factory Pattern</a></h3>
<pre><code class="language-go">type Animal interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string { return "Woof!" }

type Cat struct{}
func (c Cat) Speak() string { return "Meow!" }

func NewAnimal(animalType string) Animal {
    switch animalType {
    case "dog":
        return Dog{}
    case "cat":
        return Cat{}
    default:
        return nil
    }
}
</code></pre>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<pre><code class="language-go">type User struct {
    firstName string
    lastName  string
    age       int
    email     string
}

type UserBuilder struct {
    user User
}

func NewUserBuilder() *UserBuilder {
    return &amp;UserBuilder{}
}

func (b *UserBuilder) FirstName(name string) *UserBuilder {
    b.user.firstName = name
    return b
}

func (b *UserBuilder) LastName(name string) *UserBuilder {
    b.user.lastName = name
    return b
}

func (b *UserBuilder) Age(age int) *UserBuilder {
    b.user.age = age
    return b
}

func (b *UserBuilder) Email(email string) *UserBuilder {
    b.user.email = email
    return b
}

func (b *UserBuilder) Build() User {
    return b.user
}

// Usage
user := NewUserBuilder().
    FirstName("Alice").
    LastName("Smith").
    Age(30).
    Email("alice@example.com").
    Build()
</code></pre>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><code class="language-go">// main.go
package main

func Add(a, b int) int {
    return a + b
}

// main_test.go
package main

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5

    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}

func TestAddNegative(t *testing.T) {
    result := Add(-1, -1)
    expected := -2

    if result != expected {
        t.Errorf("Add(-1, -1) = %d; want %d", result, expected)
    }
}

// Table-driven tests
func TestAddTable(t *testing.T) {
    tests := []struct {
        a, b, expected int
    }{
        {1, 2, 3},
        {0, 0, 0},
        {-1, 1, 0},
        {10, 20, 30},
    }

    for _, tt := range tests {
        result := Add(tt.a, tt.b)
        if result != tt.expected {
            t.Errorf("Add(%d, %d) = %d; want %d",
                tt.a, tt.b, result, tt.expected)
        }
    }
}

// Run tests: go test
// Run with coverage: go test -cover
</code></pre>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use gofmt</strong> - Format code automatically</p>
<pre><code class="language-bash">gofmt -w .
</code></pre>
</li>
<li>
<p><strong>Use golint</strong> - Check code style</p>
<pre><code class="language-bash">golint ./...
</code></pre>
</li>
<li>
<p><strong>Error handling</strong> - Always check errors</p>
<pre><code class="language-go">if err != nil {
    return err
}
</code></pre>
</li>
<li>
<p><strong>Use interfaces</strong> - Program to interfaces, not implementations</p>
</li>
<li>
<p><strong>Prefer composition</strong> over inheritance</p>
</li>
<li>
<p><strong>Keep functions small</strong> - Single responsibility</p>
</li>
<li>
<p><strong>Use meaningful names</strong> - Clear and descriptive</p>
</li>
<li>
<p><strong>Document exported items</strong> - Comments for public API</p>
<pre><code class="language-go">// Add returns the sum of two integers.
func Add(a, b int) int {
    return a + b
}
</code></pre>
</li>
<li>
<p><strong>Use context</strong> for cancellation and timeouts</p>
<pre><code class="language-go">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
</code></pre>
</li>
<li>
<p><strong>Avoid global state</strong> - Pass dependencies explicitly</p>
</li>
</ol>
<hr />
<h2 id="common-libraries"><a class="header" href="#common-libraries">Common Libraries</a></h2>
<ul>
<li><strong>gorilla/mux</strong>: HTTP router</li>
<li><strong>gin</strong>: Web framework</li>
<li><strong>gorm</strong>: ORM</li>
<li><strong>viper</strong>: Configuration</li>
<li><strong>cobra</strong>: CLI applications</li>
<li><strong>logrus</strong>: Logging</li>
<li><strong>testify</strong>: Testing toolkit</li>
<li><strong>zap</strong>: Fast logging</li>
<li><strong>grpc</strong>: RPC framework</li>
<li><strong>redis</strong>: Redis client</li>
</ul>
<hr />
<h2 id="go-modules"><a class="header" href="#go-modules">Go Modules</a></h2>
<pre><code class="language-bash"># Initialize module
go mod init github.com/username/project

# Add dependency
go get github.com/gin-gonic/gin

# Update dependencies
go get -u

# Tidy dependencies
go mod tidy

# Vendor dependencies
go mod vendor
</code></pre>
<hr />
<h2 id="useful-commands"><a class="header" href="#useful-commands">Useful Commands</a></h2>
<pre><code class="language-bash"># Run program
go run main.go

# Build executable
go build

# Install binary
go install

# Format code
go fmt ./...

# Run tests
go test ./...

# Get dependencies
go get package

# Show documentation
go doc fmt.Println
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programming/java.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../programming/lua.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programming/java.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../programming/lua.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
