# SDIO (Secure Digital Input Output)

## Overview

SDIO (Secure Digital Input Output) is an extension of the SD (Secure Digital) card standard that allows for the integration of input/output devices beyond just memory storage. Developed by the SD Card Association, SDIO enables various peripherals such as Wi-Fi modules, Bluetooth adapters, GPS receivers, cameras, and other I/O devices to communicate with a host device through a standard SD card interface.

Unlike standard SD cards that only provide storage, SDIO cards can perform various I/O functions while maintaining backward compatibility with the SD card protocol. The SDIO interface provides high-speed, multi-line data transfer capabilities that make it ideal for bandwidth-intensive applications.

## Key Features

- **High-Speed Data Transfer**: Supports speeds up to 200 MB/s in UHS-II mode, with default speed at 12.5 MB/s and high-speed at 25 MB/s
- **Multiple Data Lines**: Can operate in 1-bit or 4-bit mode for parallel data transfer
- **Hot Swappable**: SDIO devices can be inserted and removed while the host device is powered on
- **Interrupt Support**: Built-in interrupt mechanism allows devices to signal the host without polling
- **Backward Compatible**: SDIO interface is backward compatible with SD memory card protocol
- **Standardized Interface**: Standardized by the SD Card Association, simplifying development
- **Low Power Modes**: Supports various power-saving modes for battery-operated devices
- **Versatile Applications**: Supports a wide range of peripherals from wireless modules to sensors

## Signal Lines

SDIO uses up to 6 signal lines for communication, depending on the operating mode:

| Signal | Alternative Names | Description |
|--------|------------------|-------------|
| **CLK** | SCLK | Clock - Generated by host to synchronize data transfer (up to 50 MHz default, 200 MHz UHS-II) |
| **CMD** | COMMAND | Command/Response - Bidirectional line for commands from host and responses from device |
| **DAT0** | DATA0 | Data Line 0 - Used in both 1-bit and 4-bit modes, also used for card busy signaling |
| **DAT1** | DATA1 | Data Line 1 - Used in 4-bit mode only, can be used for interrupt in 1-bit mode |
| **DAT2** | DATA2 | Data Line 2 - Used in 4-bit mode only |
| **DAT3** | DATA3, CS | Data Line 3 - Used in 4-bit mode only, acts as card detect in SPI mode |
| **VDD** | Power | Power supply (typically 3.3V or 1.8V) |
| **VSS** | Ground | Ground reference |

### Why Multiple Data Lines?

Unlike SPI's separate MOSI/MISO lines, SDIO uses bidirectional data lines that can all transmit simultaneously in the same direction. In 4-bit mode, this allows 4 bits to be transferred per clock cycle, significantly increasing throughput compared to 1-bit mode.

## Protocol Specifications

### Electrical Characteristics

| Parameter | 3.3V Signaling | 1.8V Signaling | Notes |
|-----------|----------------|----------------|-------|
| **Supply Voltage (VDD)** | 2.7-3.6V | 1.65-1.95V | Host must support voltage switching for 1.8V |
| **Logic HIGH (VIH)** | 2.0-3.6V | 1.26-1.95V | CMOS levels |
| **Logic LOW (VIL)** | 0-0.8V | 0-0.615V | CMOS levels |
| **Output High Voltage (VOH)** | 2.4V min | 1.4V min | At 2mA source |
| **Output Low Voltage (VOL)** | 0.4V max | 0.4V max | At 2mA sink |
| **Pull-up Resistance** | 10-90 kΩ | 10-90 kΩ | CMD and DAT lines |
| **Input Capacitance** | < 10 pF | < 10 pF | Per signal line |
| **Output Current** | 2-10 mA | 2-10 mA | Varies by implementation |

### Clock Frequency Modes

| Mode | Frequency Range | Data Rate (4-bit) | Description |
|------|----------------|-------------------|-------------|
| **Identification Mode** | 0-400 kHz | - | Card identification and initialization |
| **Default Speed (DS)** | 0-25 MHz | 0-12.5 MB/s | Standard SDIO mode |
| **High Speed (HS)** | 0-50 MHz | 0-25 MB/s | Requires HS support from card |
| **SDR50** | 0-100 MHz | 0-50 MB/s | UHS-I Single Data Rate |
| **SDR104** | 0-208 MHz | 0-104 MB/s | UHS-I highest speed mode |
| **DDR50** | 0-50 MHz | 0-50 MB/s | UHS-I Double Data Rate |

### Timing Requirements

| Parameter | Symbol | Min | Typical | Max | Unit | Description |
|-----------|--------|-----|---------|-----|------|-------------|
| Clock Frequency | f_CLK | 0 | 25 | 50 | MHz | Default/High Speed mode |
| Clock Period | t_CLK | 20 | 40 | ∞ | ns | At 50 MHz |
| Clock Low Time | t_WLCLK | 5 | - | - | ns | Minimum low duration |
| Clock High Time | t_WHCLK | 5 | - | - | ns | Minimum high duration |
| Output Delay | t_OD | - | 5 | 14 | ns | From CLK edge to valid data |
| Input Setup Time | t_IS | 2 | 5 | - | ns | Data valid before CLK edge |
| Input Hold Time | t_IH | 2 | 5 | - | ns | Data valid after CLK edge |
| CMD-to-Response | t_CR | 1 | - | 64 | CLK | Response latency |
| Rise Time | t_r | - | - | 10 | ns | Signal rise time |
| Fall Time | t_f | - | - | 10 | ns | Signal fall time |

**Important Notes:**
- Timing requirements vary significantly between default, high-speed, and UHS modes
- Higher speeds require careful PCB layout and impedance matching
- Cards must complete initialization at 400 kHz before switching to higher speeds
- Temperature and voltage variations affect timing margins

### Signal Integrity Considerations

#### PCB Layout Guidelines

- **Trace Impedance**: Target 50Ω controlled impedance for high-speed signals
- **Trace Length**: Match DAT0-3 lengths within 5mm for 4-bit mode
- **Trace Spacing**: Minimum 3x trace width between SDIO signals
- **Ground Plane**: Continuous ground plane under all SDIO traces
- **Via Count**: Minimize vias in signal paths, especially for UHS modes
- **Layer Stack**: Route SDIO signals on outer layers when possible

#### Termination and Matching

```
For High-Speed SDIO (> 25 MHz):
- Series termination: 22-33Ω resistors on CLK and CMD near host
- Pull-up resistors: 10-50kΩ on CMD and DAT lines (often internal)
- AC coupling: 0.1µF capacitors for voltage level shifting
- Length matching: Critical for 4-bit mode at high speeds
```

#### Noise Mitigation

- **Decoupling capacitors**: 100nF ceramic + 10µF bulk per SDIO device
- **Ferrite beads**: On VDD line for noise-sensitive modules (WiFi, BT)
- **Ground isolation**: Separate analog and digital grounds where appropriate
- **EMI shielding**: Metal can or shield for wireless SDIO modules

## How It Works

### Basic Communication Flow

1. **Initialization Sequence**:
   - Host supplies power and starts clock at 400 kHz
   - Host sends CMD0 (GO_IDLE_STATE) to reset all cards
   - Host sends CMD5 (IO_SEND_OP_COND) to identify SDIO cards
   - Card responds with OCR (Operating Condition Register)
   - Host sends CMD3 (SEND_RELATIVE_ADDR) to assign RCA (Relative Card Address)

2. **Command-Response Protocol**:
   - Host sends command on CMD line synchronized with CLK
   - Card decodes command and prepares response
   - Card sends response on CMD line (latency: 1-64 clock cycles)
   - Data transfer may follow on DAT lines for read/write operations

3. **Data Transfer**:
   - After successful command, data transfer begins on DAT lines
   - In 4-bit mode, DAT0-3 transfer 4 bits per clock cycle
   - CRC protection ensures data integrity
   - DAT0 line indicates busy status after write operations

4. **Interrupt Handling**:
   - SDIO devices can generate interrupts on DAT1 line
   - Interrupt signals asynchronous events (e.g., WiFi packet received)
   - Host polls or uses interrupt to detect events

### SDIO Operating Modes

#### 1-Bit Mode vs 4-Bit Mode

| Feature | 1-Bit Mode | 4-Bit Mode |
|---------|------------|------------|
| **Data Lines Used** | DAT0 only | DAT0, DAT1, DAT2, DAT3 |
| **Bandwidth** | 1 bit/cycle | 4 bits/cycle |
| **Speed (50 MHz)** | 6.25 MB/s | 25 MB/s |
| **Use Case** | Simple I/O, low-speed devices | WiFi, Bluetooth, high-speed I/O |
| **Interrupt Line** | DAT1 dedicated | Shared with data |

### Command Structure

SDIO commands are 48 bits transmitted serially on CMD line:

```
Bit 47: Start bit (0)
Bit 46: Transmission bit (1 = host to card)
Bits 45-40: Command index (CMD0-CMD63)
Bits 39-8: Argument (32 bits)
Bits 7-1: CRC7 checksum
Bit 0: End bit (1)
```

### Response Types

| Response | Length | Description |
|----------|--------|-------------|
| **R1** | 48 bits | Normal response with card status |
| **R2** | 136 bits | CID or CSD register contents |
| **R3** | 48 bits | OCR register (no CRC) |
| **R4** | 48 bits | Fast I/O response |
| **R5** | 48 bits | I/O function response |
| **R6** | 48 bits | Published RCA response |

## Hardware Timing Diagrams

### SDIO Command Transaction (1-bit mode)

```
         ___     ___     ___     ___     ___     ___     ___     ___
CLK   __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___

CMD   _____  _______________________________________________  ___________
         __|_____________COMMAND (48 bits)_______________|__
      Start                                              End
       (0)                                               (1)

           <------------- t_CR (Response Delay) ------------->

CMD   _______________  _______________________________________________
                     |_____________RESPONSE (48 bits)_______________|
                    Start                                          End
```

### 4-Bit Data Transfer Timing

```
         ___     ___     ___     ___     ___     ___     ___     ___
CLK   __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___
         ^       ^       ^       ^       ^       ^       ^       ^
         |       |       |       |       |       |       |       |
      Sample  Sample  Sample  Sample  Sample  Sample  Sample  Sample

         ____    ____    ____    ____    ____    ____    ____    ____
DAT0  __|_B0_|__|_B4_|__|_B8_|__|B12_|__|B16_|__|B20_|__|B24_|__|B28_|__

         ____    ____    ____    ____    ____    ____    ____    ____
DAT1  __|_B1_|__|_B5_|__|_B9_|__|B13_|__|B17_|__|B21_|__|B25_|__|B29_|__

         ____    ____    ____    ____    ____    ____    ____    ____
DAT2  __|_B2_|__|_B6_|__|B10_|__|B14_|__|B18_|__|B22_|__|B26_|__|B30_|__

         ____    ____    ____    ____    ____    ____    ____    ____
DAT3  __|_B3_|__|_B7_|__|B11_|__|B15_|__|B19_|__|B23_|__|B27_|__|B31_|__

      4 bits transferred per clock cycle
      One 32-bit word transferred in 8 clock cycles
```

### SDIO Interrupt Timing

```
         ___     ___     ___     ___     ___     ___     ___     ___
CLK   __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___

                                  Interrupt Period
DAT1  _______________________________|  |_________________________________
                                     |__|
                                   (Low pulse)

      Note: DAT1 used for interrupts in 1-bit mode or when data transfer inactive
```

## Code Examples

### ESP32 SDIO WiFi Module

The ESP32 commonly uses SDIO to interface with WiFi modules:

```cpp
#include "driver/sdmmc_host.h"
#include "driver/sdspi_host.h"
#include "sdmmc_cmd.h"
#include "esp_vfs_fat.h"

#define SDIO_CLK_PIN  14
#define SDIO_CMD_PIN  15
#define SDIO_D0_PIN   2
#define SDIO_D1_PIN   4
#define SDIO_D2_PIN   12
#define SDIO_D3_PIN   13

void sdio_init() {
    // Configure SDIO host
    sdmmc_host_t host = SDMMC_HOST_DEFAULT();
    host.flags = SDMMC_HOST_FLAG_4BIT;  // Use 4-bit mode
    host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;  // 50 MHz

    // Configure slot
    sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();
    slot_config.width = 4;  // 4-bit mode
    slot_config.clk = SDIO_CLK_PIN;
    slot_config.cmd = SDIO_CMD_PIN;
    slot_config.d0 = SDIO_D0_PIN;
    slot_config.d1 = SDIO_D1_PIN;
    slot_config.d2 = SDIO_D2_PIN;
    slot_config.d3 = SDIO_D3_PIN;

    // Initialize SDIO
    sdmmc_card_t *card;
    esp_err_t ret = sdmmc_host_init();
    if (ret != ESP_OK) {
        printf("SDIO host init failed\n");
        return;
    }

    ret = sdmmc_host_init_slot(SDMMC_HOST_SLOT_1, &slot_config);
    if (ret != ESP_OK) {
        printf("SDIO slot init failed\n");
        return;
    }
}

// Read SDIO register
uint8_t sdio_read_reg(sdmmc_card_t *card, uint32_t func, uint32_t reg) {
    uint8_t data;
    sdmmc_io_read_byte(card, func, reg, &data);
    return data;
}

// Write SDIO register
void sdio_write_reg(sdmmc_card_t *card, uint32_t func, uint32_t reg, uint8_t val) {
    sdmmc_io_write_byte(card, func, reg, val);
}

// Read multiple bytes
esp_err_t sdio_read_bytes(sdmmc_card_t *card, uint32_t func,
                          uint32_t addr, void *dst, size_t size) {
    return sdmmc_io_read_bytes(card, func, addr, dst, size);
}

// Write multiple bytes
esp_err_t sdio_write_bytes(sdmmc_card_t *card, uint32_t func,
                           uint32_t addr, const void *src, size_t size) {
    return sdmmc_io_write_bytes(card, func, addr, src, size);
}
```

### STM32 HAL SDIO Example

```c
#include "stm32f4xx_hal.h"

SD_HandleTypeDef hsd;

void SDIO_Init(void) {
    hsd.Instance = SDIO;
    hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
    hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
    hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
    hsd.Init.BusWide = SDIO_BUS_WIDE_4B;  // 4-bit mode
    hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
    hsd.Init.ClockDiv = 0;  // Maximum speed

    // Initialize SDIO peripheral
    if (HAL_SD_Init(&hsd) != HAL_OK) {
        Error_Handler();
    }

    // Configure for 4-bit wide bus
    if (HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B) != HAL_OK) {
        Error_Handler();
    }
}

// Read single block (512 bytes)
HAL_StatusTypeDef SDIO_ReadBlock(uint8_t *buffer, uint32_t block_addr) {
    return HAL_SD_ReadBlocks(&hsd, buffer, block_addr, 1, HAL_MAX_DELAY);
}

// Write single block (512 bytes)
HAL_StatusTypeDef SDIO_WriteBlock(uint8_t *buffer, uint32_t block_addr) {
    return HAL_SD_WriteBlocks(&hsd, buffer, block_addr, 1, HAL_MAX_DELAY);
}

// Read multiple blocks with DMA
HAL_StatusTypeDef SDIO_ReadBlocks_DMA(uint8_t *buffer, uint32_t block_addr, uint32_t num_blocks) {
    return HAL_SD_ReadBlocks_DMA(&hsd, buffer, block_addr, num_blocks);
}

// Write multiple blocks with DMA
HAL_StatusTypeDef SDIO_WriteBlocks_DMA(uint8_t *buffer, uint32_t block_addr, uint32_t num_blocks) {
    return HAL_SD_WriteBlocks_DMA(&hsd, buffer, block_addr, num_blocks);
}

// Get card information
void SDIO_GetCardInfo(void) {
    HAL_SD_CardInfoTypeDef cardInfo;
    HAL_SD_GetCardInfo(&hsd, &cardInfo);

    printf("Card Type: %d\n", cardInfo.CardType);
    printf("Card Version: %d\n", cardInfo.CardVersion);
    printf("Block Size: %d bytes\n", cardInfo.BlockSize);
    printf("Block Count: %d\n", cardInfo.BlockNbr);
    printf("Capacity: %llu MB\n",
           (uint64_t)cardInfo.BlockNbr * cardInfo.BlockSize / 1024 / 1024);
}

// DMA transfer complete callback
void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd) {
    // Transfer complete - handle in application
}

void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd) {
    // Reception complete - handle in application
}
```

### Linux Kernel SDIO Driver Example

```c
#include <linux/mmc/sdio.h>
#include <linux/mmc/sdio_func.h>
#include <linux/mmc/sdio_ids.h>
#include <linux/mmc/card.h>
#include <linux/module.h>

struct sdio_driver my_sdio_driver;

// SDIO device probe function
static int my_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id) {
    int ret;

    printk(KERN_INFO "SDIO device detected: Vendor 0x%04x, Device 0x%04x\n",
           func->vendor, func->device);

    // Enable the SDIO function
    sdio_claim_host(func);
    ret = sdio_enable_func(func);
    if (ret) {
        printk(KERN_ERR "Failed to enable SDIO function\n");
        sdio_release_host(func);
        return ret;
    }

    // Set block size (typically 512 bytes)
    ret = sdio_set_block_size(func, 512);
    if (ret) {
        printk(KERN_ERR "Failed to set block size\n");
        sdio_disable_func(func);
        sdio_release_host(func);
        return ret;
    }

    sdio_release_host(func);
    return 0;
}

// SDIO device remove function
static void my_sdio_remove(struct sdio_func *func) {
    sdio_claim_host(func);
    sdio_disable_func(func);
    sdio_release_host(func);
    printk(KERN_INFO "SDIO device removed\n");
}

// Read bytes from SDIO function
static int sdio_read_data(struct sdio_func *func, u32 addr, void *dst, int count) {
    int ret;

    sdio_claim_host(func);
    ret = sdio_memcpy_fromio(func, dst, addr, count);
    sdio_release_host(func);

    return ret;
}

// Write bytes to SDIO function
static int sdio_write_data(struct sdio_func *func, u32 addr, void *src, int count) {
    int ret;

    sdio_claim_host(func);
    ret = sdio_memcpy_toio(func, addr, src, count);
    sdio_release_host(func);

    return ret;
}

// Read single byte from register
static u8 sdio_read_byte(struct sdio_func *func, unsigned int addr) {
    int ret;
    u8 val;

    sdio_claim_host(func);
    val = sdio_readb(func, addr, &ret);
    sdio_release_host(func);

    return val;
}

// Write single byte to register
static void sdio_write_byte(struct sdio_func *func, unsigned int addr, u8 val) {
    sdio_claim_host(func);
    sdio_writeb(func, val, addr, NULL);
    sdio_release_host(func);
}

// Device ID table
static const struct sdio_device_id my_sdio_ids[] = {
    { SDIO_DEVICE(0x02d0, 0x4330) },  // Example: Broadcom WiFi
    { /* end */ }
};
MODULE_DEVICE_TABLE(sdio, my_sdio_ids);

// SDIO driver structure
static struct sdio_driver my_sdio_driver = {
    .name = "my_sdio_driver",
    .id_table = my_sdio_ids,
    .probe = my_sdio_probe,
    .remove = my_sdio_remove,
};

// Module init
static int __init my_sdio_init(void) {
    return sdio_register_driver(&my_sdio_driver);
}

// Module exit
static void __exit my_sdio_exit(void) {
    sdio_unregister_driver(&my_sdio_driver);
}

module_init(my_sdio_init);
module_exit(my_sdio_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Example SDIO Driver");
```

### Raspberry Pi SDIO Example (Using WiFi Chip)

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>

// This example shows conceptual SDIO access on Raspberry Pi
// Actual implementation depends on specific SDIO device

#define SDIO_FUNC_0  0  // Common I/O Area (CIA)
#define SDIO_FUNC_1  1  // I/O Function 1
#define SDIO_FUNC_2  2  // I/O Function 2

// Common SDIO registers
#define SDIO_CCCR_REV       0x00  // CCCR/SDIO revision
#define SDIO_SD_SPEC        0x01  // SD specification revision
#define SDIO_IO_ENABLE      0x02  // I/O Enable
#define SDIO_IO_READY       0x03  // I/O Ready
#define SDIO_INT_ENABLE     0x04  // Interrupt Enable
#define SDIO_INT_PENDING    0x05  // Interrupt Pending
#define SDIO_IO_ABORT       0x06  // I/O Abort
#define SDIO_BUS_IF_CTRL    0x07  // Bus Interface Control

void sdio_enable_function(int func_num) {
    // Enable specific SDIO function
    printf("Enabling SDIO function %d\n", func_num);
    // Implementation would use ioctl calls to MMC subsystem
}

void sdio_set_block_size(int func_num, int block_size) {
    // Set block size for function
    printf("Setting block size to %d for function %d\n", block_size, func_num);
}

void sdio_enable_interrupts(int func_mask) {
    // Enable interrupts for specified functions
    printf("Enabling interrupts for functions: 0x%02x\n", func_mask);
}

int main() {
    printf("Raspberry Pi SDIO Example\n");

    // Initialize SDIO
    sdio_enable_function(SDIO_FUNC_1);
    sdio_set_block_size(SDIO_FUNC_1, 512);
    sdio_enable_interrupts(0x02);  // Enable interrupts for function 1

    return 0;
}
```

### Bare-Metal SDIO (STM32F4)

```c
#include <stdint.h>

// STM32F4 SDIO register definitions
#define SDIO_BASE           0x40012C00
#define SDIO_POWER          (*(volatile uint32_t *)(SDIO_BASE + 0x00))
#define SDIO_CLKCR          (*(volatile uint32_t *)(SDIO_BASE + 0x04))
#define SDIO_ARG            (*(volatile uint32_t *)(SDIO_BASE + 0x08))
#define SDIO_CMD            (*(volatile uint32_t *)(SDIO_BASE + 0x0C))
#define SDIO_RESPCMD        (*(volatile uint32_t *)(SDIO_BASE + 0x10))
#define SDIO_RESP1          (*(volatile uint32_t *)(SDIO_BASE + 0x14))
#define SDIO_RESP2          (*(volatile uint32_t *)(SDIO_BASE + 0x18))
#define SDIO_RESP3          (*(volatile uint32_t *)(SDIO_BASE + 0x1C))
#define SDIO_RESP4          (*(volatile uint32_t *)(SDIO_BASE + 0x20))
#define SDIO_DTIMER         (*(volatile uint32_t *)(SDIO_BASE + 0x24))
#define SDIO_DLEN           (*(volatile uint32_t *)(SDIO_BASE + 0x28))
#define SDIO_DCTRL          (*(volatile uint32_t *)(SDIO_BASE + 0x2C))
#define SDIO_STA            (*(volatile uint32_t *)(SDIO_BASE + 0x34))
#define SDIO_ICR            (*(volatile uint32_t *)(SDIO_BASE + 0x38))
#define SDIO_FIFO           (*(volatile uint32_t *)(SDIO_BASE + 0x80))

// SDIO Command register bits
#define SDIO_CMD_WAITRESP_SHORT   (1 << 6)
#define SDIO_CMD_WAITRESP_LONG    (2 << 6)
#define SDIO_CMD_CPSMEN           (1 << 10)

// SDIO Status register bits
#define SDIO_STA_CCRCFAIL   (1 << 0)
#define SDIO_STA_DCRCFAIL   (1 << 1)
#define SDIO_STA_CTIMEOUT   (1 << 2)
#define SDIO_STA_DTIMEOUT   (1 << 3)
#define SDIO_STA_CMDREND    (1 << 6)
#define SDIO_STA_CMDSENT    (1 << 7)

// Common SDIO commands
#define CMD0_GO_IDLE_STATE      0
#define CMD5_IO_SEND_OP_COND    5
#define CMD3_SEND_RELATIVE_ADDR 3
#define CMD7_SELECT_CARD        7
#define CMD52_IO_RW_DIRECT      52
#define CMD53_IO_RW_EXTENDED    53

void sdio_init(void) {
    // Enable SDIO clock (assume RCC already configured)

    // Power on SDIO
    SDIO_POWER = 0x03;  // Power ON

    // Configure clock: 48 MHz / (2 + 118) = 400 kHz for initialization
    SDIO_CLKCR = 118 |   // Clock divider
                 (0 << 11) |  // 1-bit bus width
                 (1 << 8);    // Clock enable

    // Wait for power on
    for (volatile int i = 0; i < 10000; i++);
}

uint32_t sdio_send_command(uint8_t cmd_index, uint32_t argument, uint8_t response_type) {
    // Set argument
    SDIO_ARG = argument;

    // Clear flags
    SDIO_ICR = 0x7FF;

    // Send command
    uint32_t cmd_reg = cmd_index | SDIO_CMD_CPSMEN;

    if (response_type == 1) {
        cmd_reg |= SDIO_CMD_WAITRESP_SHORT;
    } else if (response_type == 2) {
        cmd_reg |= SDIO_CMD_WAITRESP_LONG;
    }

    SDIO_CMD = cmd_reg;

    // Wait for command sent or response
    if (response_type == 0) {
        while (!(SDIO_STA & SDIO_STA_CMDSENT));
    } else {
        while (!(SDIO_STA & SDIO_STA_CMDREND) &&
               !(SDIO_STA & SDIO_STA_CTIMEOUT) &&
               !(SDIO_STA & SDIO_STA_CCRCFAIL));

        if (SDIO_STA & (SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL)) {
            return 0;  // Error
        }
    }

    return SDIO_RESP1;
}

void sdio_set_bus_width(uint8_t width) {
    // width: 0 = 1-bit, 1 = 4-bit, 2 = 8-bit
    uint32_t clkcr = SDIO_CLKCR;
    clkcr &= ~(3 << 11);
    clkcr |= (width << 11);
    SDIO_CLKCR = clkcr;
}

void sdio_set_clock_speed(uint32_t clock_div) {
    uint32_t clkcr = SDIO_CLKCR;
    clkcr &= ~0xFF;
    clkcr |= clock_div;
    SDIO_CLKCR = clkcr;
}

uint8_t sdio_read_byte(uint8_t func, uint32_t addr) {
    // CMD52: IO_RW_DIRECT for reading
    uint32_t arg = (func << 28) |     // Function number
                   (addr << 9) |       // Register address
                   (0 << 31) |         // Read operation
                   (0 << 27);          // RAW flag

    uint32_t response = sdio_send_command(CMD52_IO_RW_DIRECT, arg, 1);
    return response & 0xFF;
}

void sdio_write_byte(uint8_t func, uint32_t addr, uint8_t data) {
    // CMD52: IO_RW_DIRECT for writing
    uint32_t arg = (func << 28) |     // Function number
                   (addr << 9) |       // Register address
                   (1 << 31) |         // Write operation
                   (data & 0xFF);      // Data to write

    sdio_send_command(CMD52_IO_RW_DIRECT, arg, 1);
}
```

## Advanced Topics

### DMA-Based SDIO Transfers

DMA (Direct Memory Access) is essential for high-performance SDIO applications like WiFi streaming or high-speed storage access.

#### STM32 SDIO with DMA

```c
#include "stm32f4xx_hal.h"

SD_HandleTypeDef hsd;
DMA_HandleTypeDef hdma_sdio_rx;
DMA_HandleTypeDef hdma_sdio_tx;

volatile uint8_t transfer_complete = 0;

void SDIO_DMA_Init(void) {
    // Enable DMA2 clock
    __HAL_RCC_DMA2_CLK_ENABLE();

    // Configure DMA for SDIO RX (Channel 4, Stream 3)
    hdma_sdio_rx.Instance = DMA2_Stream3;
    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;

    HAL_DMA_Init(&hdma_sdio_rx);
    __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio_rx);

    // Configure DMA for SDIO TX (Channel 4, Stream 6)
    hdma_sdio_tx.Instance = DMA2_Stream6;
    hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
    hdma_sdio_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;

    HAL_DMA_Init(&hdma_sdio_tx);
    __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio_tx);

    // Enable DMA interrupts
    HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
    HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
}

// High-performance block read with DMA
HAL_StatusTypeDef SDIO_ReadBlocks_HighSpeed(uint8_t *buffer, uint32_t block_addr,
                                            uint32_t num_blocks) {
    transfer_complete = 0;

    HAL_StatusTypeDef status = HAL_SD_ReadBlocks_DMA(&hsd, buffer, block_addr, num_blocks);

    if (status != HAL_OK) {
        return status;
    }

    // Wait for DMA transfer complete (or use callback)
    while (!transfer_complete) {
        // Can do other work here
    }

    return HAL_OK;
}

// DMA callbacks
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd) {
    transfer_complete = 1;
}

void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd) {
    transfer_complete = 1;
}

void DMA2_Stream3_IRQHandler(void) {
    HAL_DMA_IRQHandler(&hdma_sdio_rx);
}

void DMA2_Stream6_IRQHandler(void) {
    HAL_DMA_IRQHandler(&hdma_sdio_tx);
}
```

**Benefits of DMA with SDIO:**
- Sustained 25 MB/s (4-bit, 50 MHz) without CPU intervention
- Essential for WiFi packet processing and video streaming
- Reduces interrupt overhead significantly
- CPU free for protocol processing

### SDIO Interrupt Handling

SDIO supports card-to-host interrupts on the DAT1 line, crucial for asynchronous event notification.

```c
// Enable SDIO interrupt
void sdio_enable_interrupt(void) {
    // Enable interrupt in card (CMD52 to CCCR)
    sdio_write_byte(0, SDIO_INT_ENABLE, 0x03);  // Master + Function 1

    // Enable SDIO peripheral interrupt
    SDIO->MASK |= SDIO_MASK_SDIOITIE;

    // Enable NVIC interrupt
    HAL_NVIC_SetPriority(SDIO_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SDIO_IRQn);
}

// SDIO interrupt handler
void SDIO_IRQHandler(void) {
    if (SDIO->STA & SDIO_STA_SDIOIT) {
        // Clear interrupt flag
        SDIO->ICR = SDIO_ICR_SDIOITC;

        // Read interrupt pending register to identify source
        uint8_t pending = sdio_read_byte(0, SDIO_INT_PENDING);

        if (pending & 0x02) {  // Function 1 interrupt
            // Handle WiFi/BT interrupt
            handle_sdio_device_interrupt();
        }
    }
}
```

### 1-Bit vs 4-Bit Mode Configuration

```c
// Switch from 1-bit to 4-bit mode
HAL_StatusTypeDef switch_to_4bit_mode(void) {
    uint8_t bus_width;

    // Read current bus width from CCCR
    bus_width = sdio_read_byte(0, SDIO_BUS_IF_CTRL);

    // Set 4-bit mode in card
    bus_width &= ~0x03;
    bus_width |= 0x02;  // 4-bit mode
    sdio_write_byte(0, SDIO_BUS_IF_CTRL, bus_width);

    // Configure host for 4-bit mode
    if (HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B) != HAL_OK) {
        return HAL_ERROR;
    }

    return HAL_OK;
}
```

### High-Speed Mode Switching

```c
// Enable high-speed mode (50 MHz)
HAL_StatusTypeDef enable_high_speed_mode(void) {
    uint8_t speed;

    // Check if card supports high-speed
    speed = sdio_read_byte(0, 0x13);  // Card Capability register
    if (!(speed & 0x01)) {
        return HAL_ERROR;  // High-speed not supported
    }

    // Enable high-speed in card
    speed = sdio_read_byte(0, SDIO_BUS_SPEED_SELECT);
    speed |= 0x01;  // Enable high-speed
    sdio_write_byte(0, SDIO_BUS_SPEED_SELECT, speed);

    // Increase host clock to 50 MHz
    SDIO_CLKCR &= ~0xFF;
    SDIO_CLKCR |= 0x00;  // 48 MHz / (0+2) = 24 MHz (adjust for your clock)

    return HAL_OK;
}
```

## Common Use Cases

### 1. Wireless Communication Modules

**WiFi (ESP32, Broadcom, etc.)**
- High-bandwidth data transfer (multiple MB/s)
- Interrupt-driven packet notification
- Ideal for IoT devices and embedded systems
- Typically uses 4-bit mode for maximum throughput

**Bluetooth Modules**
- Lower bandwidth than WiFi but still benefits from SDIO
- Interrupt support for HCI events
- Power-efficient compared to UART

### 2. GPS Receivers

- SDIO provides faster NMEA data streaming than UART
- Interrupt support for time-critical position updates
- Suitable for high-update-rate applications (10 Hz+)

### 3. Camera Interfaces

- High-speed image data transfer
- DMA support essential for real-time video
- 4-bit mode maximizes frame rate
- Common in smartphone camera modules

### 4. Storage Devices

**SD/SDHC/SDXC Cards**
- Originally the primary use case for SDIO
- 25 MB/s (HS), 50 MB/s (SDR50), 104 MB/s (SDR104)
- Hot-pluggable storage solution

**eMMC (Embedded MultiMediaCard)**
- Non-removable SDIO-based storage
- Higher reliability than SD cards
- Used in smartphones, tablets, embedded systems

### 5. IoT and Sensor Integration

- Multi-sensor aggregation over single interface
- Lower pin count than SPI for multiple devices
- Standardized protocol simplifies integration

## SDIO vs SPI vs SD Comparison

| Feature | SDIO | SPI | SD (Memory Mode) |
|---------|------|-----|------------------|
| **Maximum Speed** | 200 MB/s (UHS-II) | 6-25 MB/s typically | 200 MB/s (UHS-II) |
| **Data Lines** | 1, 4, or 8 | 2 (MOSI, MISO) | 1 or 4 |
| **Command Line** | Dedicated CMD line | Shares with data (CS) | Dedicated CMD line |
| **Pins Required** | 6-10 | 4 | 6-10 |
| **Hot Pluggable** | Yes | Sometimes | Yes |
| **Interrupt Support** | Built-in (DAT1) | External GPIO needed | N/A |
| **Protocol Complexity** | Moderate | Simple | Moderate |
| **Use Cases** | WiFi, BT, GPS, storage | Sensors, displays, flash | Storage only |
| **Power Consumption** | Low-Moderate | Low | Low-Moderate |
| **Standardization** | SD Association | De facto (Motorola) | SD Association |

**When to Choose SDIO:**
- High-bandwidth I/O devices (WiFi, cameras)
- Need for hardware interrupt support
- Standardized interface requirement
- Hot-plug capability needed

**When to Choose SPI:**
- Simple sensors and displays
- Lower bandwidth requirements
- More GPIO pins available
- Simpler protocol preferred

## Best Practices

### 1. Initialization Sequence

Always follow the proper initialization sequence:

```c
// Correct initialization order
void sdio_proper_init(void) {
    // 1. Power on with low clock (400 kHz)
    sdio_power_on();
    sdio_set_clock(400000);  // 400 kHz

    // 2. Send CMD0 (reset)
    sdio_send_command(CMD0_GO_IDLE_STATE, 0, 0);
    delay_ms(10);

    // 3. Send CMD5 (identify SDIO)
    uint32_t ocr = sdio_send_command(CMD5_IO_SEND_OP_COND, 0, 1);

    // 4. Wait for card ready
    do {
        ocr = sdio_send_command(CMD5_IO_SEND_OP_COND, 0x00FF8000, 1);
    } while (!(ocr & 0x80000000));

    // 5. Get RCA
    uint32_t rca = sdio_send_command(CMD3_SEND_RELATIVE_ADDR, 0, 1);

    // 6. Select card
    sdio_send_command(CMD7_SELECT_CARD, rca, 1);

    // 7. Switch to 4-bit mode if supported
    switch_to_4bit_mode();

    // 8. Increase clock to high speed
    sdio_set_clock(25000000);  // 25 MHz or 50 MHz
}
```

### 2. Error Handling

```c
// Robust command execution with timeout and retries
HAL_StatusTypeDef sdio_command_with_retry(uint8_t cmd, uint32_t arg,
                                          uint8_t resp_type, int retries) {
    HAL_StatusTypeDef status;

    for (int i = 0; i < retries; i++) {
        status = sdio_send_command(cmd, arg, resp_type);

        if (status == HAL_OK) {
            return HAL_OK;
        }

        if (status == HAL_TIMEOUT) {
            // Reset command path
            SDIO->ICR = 0x7FF;
            delay_ms(10);
        } else if (status == HAL_ERROR) {
            // CRC error - may indicate signal integrity issue
            // Consider reducing clock speed
            break;
        }
    }

    return status;
}
```

### 3. Power Management

```c
// Efficient power management for battery devices
void sdio_enter_low_power(void) {
    // Notify card of low power mode
    sdio_write_byte(0, SDIO_POWER_CONTROL, 0x02);  // Low power mode

    // Reduce clock frequency
    sdio_set_clock(1000000);  // 1 MHz

    // Disable unused functions
    uint8_t io_enable = sdio_read_byte(0, SDIO_IO_ENABLE);
    io_enable &= 0x01;  // Keep only function 0
    sdio_write_byte(0, SDIO_IO_ENABLE, io_enable);
}

void sdio_exit_low_power(void) {
    // Re-enable functions
    sdio_write_byte(0, SDIO_IO_ENABLE, 0x02);  // Enable function 1

    // Restore clock frequency
    sdio_set_clock(25000000);

    // Exit low power mode
    sdio_write_byte(0, SDIO_POWER_CONTROL, 0x00);
}
```

### 4. Signal Integrity

```
PCB Design Checklist for SDIO:
☑ Controlled impedance traces (50Ω)
☑ Match DAT0-3 trace lengths within 5mm
☑ Keep traces under 100mm for high-speed mode
☑ Continuous ground plane under SDIO signals
☑ Decoupling: 0.1µF + 10µF at VDD pin
☑ Series resistors on CLK (22-33Ω) for edge control
☑ Pull-ups on CMD and DAT lines (10-50kΩ)
☑ Avoid routing under/near switching regulators
```

### 5. Block Size Optimization

```c
// Optimize block size for performance
void sdio_optimize_block_size(uint32_t transfer_size) {
    uint16_t block_size;

    if (transfer_size >= 512) {
        block_size = 512;  // Maximum efficiency
    } else if (transfer_size >= 256) {
        block_size = 256;
    } else if (transfer_size >= 128) {
        block_size = 128;
    } else {
        block_size = 64;  // Minimum practical size
    }

    sdio_set_block_size(1, block_size);
}
```

## Common Issues and Debugging

### Problem: Card Not Detected

**Symptoms:**
- No response to CMD5
- Timeout on initialization commands

**Solutions:**
1. Check power supply voltage (3.3V nominal)
2. Verify pull-up resistors on CMD and DAT lines (10-50kΩ)
3. Ensure clock frequency starts at 400 kHz
4. Check card insertion detect mechanism
5. Verify card is SDIO-capable (not just SD memory)

```c
// Debug initialization
void debug_card_detection(void) {
    printf("Sending CMD0...\n");
    sdio_send_command(CMD0_GO_IDLE_STATE, 0, 0);

    printf("Sending CMD5 (OCR request)...\n");
    uint32_t ocr = sdio_send_command(CMD5_IO_SEND_OP_COND, 0, 1);

    if (ocr == 0) {
        printf("ERROR: No response to CMD5\n");
        printf("Check: Power, clock, pull-ups, card type\n");
    } else {
        printf("OCR: 0x%08X\n", ocr);
        printf("Voltage: %s\n", (ocr & 0x00FF8000) ? "OK" : "MISMATCH");
        printf("Card Ready: %s\n", (ocr & 0x80000000) ? "YES" : "NO");
    }
}
```

### Problem: CRC Errors

**Symptoms:**
- Frequent CRC failures on data or commands
- Intermittent communication

**Solutions:**
1. Reduce clock frequency
2. Check trace routing and length matching
3. Add/adjust series termination resistors
4. Verify power supply stability
5. Check for EMI sources nearby

```c
// Adaptive clock speed on CRC errors
void handle_crc_errors(void) {
    static int crc_error_count = 0;
    static uint32_t current_clock = 25000000;

    crc_error_count++;

    if (crc_error_count > 10) {
        // Reduce clock by 25%
        current_clock = current_clock * 3 / 4;
        sdio_set_clock(current_clock);

        printf("Reduced SDIO clock to %d Hz due to CRC errors\n", current_clock);
        crc_error_count = 0;
    }
}
```

### Problem: Data Corruption

**Symptoms:**
- Data read differs from written data
- Random bit flips

**Solutions:**
1. Ensure proper DMA buffer alignment (word-aligned)
2. Disable cache or ensure cache coherency
3. Verify voltage levels match between host and card
4. Check for inadequate decoupling capacitors
5. Reduce clock speed

```c
// Check DMA buffer alignment
void verify_buffer_alignment(uint8_t *buffer, size_t size) {
    if ((uint32_t)buffer % 4 != 0) {
        printf("WARNING: Buffer not word-aligned!\n");
        printf("Address: 0x%08X\n", (uint32_t)buffer);
    }

    if (size % 4 != 0) {
        printf("WARNING: Size not multiple of 4!\n");
        printf("Size: %d bytes\n", size);
    }
}
```

### Problem: Interrupts Not Working

**Symptoms:**
- No interrupt received from SDIO device
- Polling works but interrupt doesn't

**Solutions:**
1. Enable interrupt in card (CCCR register)
2. Enable interrupt in host controller
3. Configure DAT1 line properly for interrupts
4. Check that 4-bit mode isn't interfering with DAT1 interrupt

```c
// Debug interrupt configuration
void debug_sdio_interrupts(void) {
    // Check card interrupt enable
    uint8_t int_enable = sdio_read_byte(0, SDIO_INT_ENABLE);
    printf("Card INT Enable: 0x%02X (should be 0x03)\n", int_enable);

    // Check interrupt pending
    uint8_t int_pending = sdio_read_byte(0, SDIO_INT_PENDING);
    printf("INT Pending: 0x%02X\n", int_pending);

    // Check host controller interrupt enable
    printf("Host INT Mask: 0x%08X\n", SDIO->MASK);
    printf("Host Status: 0x%08X\n", SDIO->STA);
}
```

### Problem: 4-Bit Mode Fails

**Symptoms:**
- 1-bit mode works, 4-bit mode fails
- Errors when switching to 4-bit mode

**Solutions:**
1. Verify all DAT lines are connected properly
2. Check DAT line pull-up resistors
3. Ensure trace length matching
4. Verify card supports 4-bit mode (check capabilities)

```c
// Safe 4-bit mode switching with fallback
HAL_StatusTypeDef safe_switch_4bit_mode(void) {
    // Check card capabilities first
    uint8_t card_cap = sdio_read_byte(0, 0x08);  // Card Capability

    if (!(card_cap & 0x80)) {
        printf("Card does not support 4-bit mode\n");
        return HAL_ERROR;
    }

    // Attempt to switch
    if (switch_to_4bit_mode() != HAL_OK) {
        printf("4-bit mode switch failed, reverting to 1-bit\n");

        // Revert to 1-bit mode
        uint8_t bus_width = sdio_read_byte(0, SDIO_BUS_IF_CTRL);
        bus_width &= ~0x03;
        sdio_write_byte(0, SDIO_BUS_IF_CTRL, bus_width);

        HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_1B);
        return HAL_ERROR;
    }

    // Test 4-bit mode with a read operation
    uint8_t test_data;
    if (sdio_read_byte(0, 0x00) == 0xFF) {  // Invalid response
        printf("4-bit mode verification failed\n");
        // Revert to 1-bit
        return HAL_ERROR;
    }

    printf("4-bit mode enabled successfully\n");
    return HAL_OK;
}
```

## ELI10 (Explain Like I'm 10)

Imagine you're passing notes to multiple friends in class, but instead of one note at a time, you have four note-passing lanes:

- **CLK (Clock)** is like the teacher's metronome - it keeps everyone in sync, so you all pass notes at the same beat
- **CMD (Command)** is like the special instruction note that tells your friend what to do: "send me your homework," "receive this message," etc.
- **DAT0-3 (Data Lines)** are like four different note-passing lanes. In "1-bit mode" you only use one lane (DAT0), but in "4-bit mode" you use all four lanes at once - so you can pass 4 notes per beat instead of just 1! This makes it four times faster!
- **Interrupts** are like your friend tapping your shoulder when they have something urgent to tell you, instead of you constantly asking "do you have anything for me?"

The cool part about SDIO is that it's **standardized** - like everyone agreeing to use the same size paper and folding method. This means different devices (WiFi chips, GPS modules, cameras) can all talk to your computer the same way, even though they do totally different things!

And unlike SPI (where you need a separate "tap on the shoulder" line for each friend), SDIO has interrupts built right in, so your WiFi module can let you know immediately when a new message arrives!

## Further Resources

### Official Specifications
- [SD Association](https://www.sdcard.org/) - Official SDIO specifications and documentation
- [SDIO Simplified Specification](https://www.sdcard.org/downloads/pls/) - Free simplified specification documents

### Tutorials and Guides
- [SD Association Technical Resources](https://www.sdcard.org/developers/sd-standard-overview/)
- [ESP32 SDIO Documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/sdmmc_host.html)
- [STM32 SDIO Application Notes](https://www.st.com/resource/en/application_note/cd00261381-stm32f2xx-stm32f4xx-and-stm32f7xx-series-sdio-sd-card-host-interface-stmicroelectronics.pdf)

### Development Tools
- [SD Card Formatter](https://www.sdcard.org/downloads/formatter/) - Official SD formatting tool
- Logic Analyzers with SDIO protocol decoders
- [Saleae Logic](https://www.saleae.com/) - Popular logic analyzer with SDIO support

### Hardware Resources
- Application notes from SoC manufacturers (STM32, ESP32, NXP, etc.)
- WiFi module datasheets (Broadcom, Qualcomm, Espressif)
- [SD Card Pinout Reference](https://pinoutguide.com/DigitalCameras/sd_card_pinout.shtml)

### Community Resources
- [ESP32 Forums](https://www.esp32.com/) - Active community for ESP32 SDIO applications
- [STM32 Community](https://community.st.com/) - STM32-specific SDIO discussions
- [Linux Kernel SDIO Documentation](https://www.kernel.org/doc/html/latest/driver-api/mmc/mmc-dev-parts.html)

### Books and Academic Papers
- "SD Card Projects Using the PIC Microcontroller" by Dogan Ibrahim
- "Embedded Systems Design with Platform FPGAs" - Chapter on SDIO interfaces
- Research papers on SDIO protocol optimization and analysis
