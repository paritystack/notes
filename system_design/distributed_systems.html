<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Distributed Systems - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-aabda7aa.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-8fce9580.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="distributed-systems"><a class="header" href="#distributed-systems">Distributed Systems</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A distributed system is a collection of independent computers that appear to its users as a single coherent system. These systems work together to achieve a common goal by communicating and coordinating their actions through message passing.</p>
<h2 id="distributed-systems-fundamentals"><a class="header" href="#distributed-systems-fundamentals">Distributed Systems Fundamentals</a></h2>
<h3 id="core-challenges"><a class="header" href="#core-challenges">Core Challenges</a></h3>
<h4 id="1-network-failures"><a class="header" href="#1-network-failures">1. Network Failures</a></h4>
<ul>
<li><strong>Packet loss</strong>: Messages can be dropped in transit</li>
<li><strong>Network partitions</strong>: Parts of the system become isolated from each other</li>
<li><strong>Asymmetric failures</strong>: Node A can reach B, but B cannot reach A</li>
<li><strong>Message reordering</strong>: Messages may arrive out of order</li>
<li><strong>Byzantine failures</strong>: Nodes may behave arbitrarily or maliciously</li>
</ul>
<h4 id="2-latency-and-performance"><a class="header" href="#2-latency-and-performance">2. Latency and Performance</a></h4>
<ul>
<li><strong>Variable latency</strong>: Network delays are unpredictable</li>
<li><strong>Geographic distribution</strong>: Physical distance increases communication time</li>
<li><strong>Bandwidth limitations</strong>: Network capacity constraints</li>
<li><strong>Synchronous vs asynchronous</strong>: Trade-offs between consistency and performance</li>
</ul>
<h4 id="3-partial-failures"><a class="header" href="#3-partial-failures">3. Partial Failures</a></h4>
<ul>
<li><strong>Individual component failures</strong>: Single nodes can fail while others continue</li>
<li><strong>Cascading failures</strong>: One failure triggers others</li>
<li><strong>Gray failures</strong>: Components function partially, making detection difficult</li>
<li><strong>Fail-stop vs fail-slow</strong>: Different failure modes require different handling</li>
</ul>
<h3 id="the-eight-fallacies-of-distributed-computing"><a class="header" href="#the-eight-fallacies-of-distributed-computing">The Eight Fallacies of Distributed Computing</a></h3>
<p>Originally identified by L. Peter Deutsch and others at Sun Microsystems:</p>
<ol>
<li><strong>The network is reliable</strong>: Networks fail, packets get lost, connections drop</li>
<li><strong>Latency is zero</strong>: Communication takes time, and that time varies</li>
<li><strong>Bandwidth is infinite</strong>: Network capacity is limited and shared</li>
<li><strong>The network is secure</strong>: Security must be designed in, not assumed</li>
<li><strong>Topology doesn’t change</strong>: Network paths and configurations change dynamically</li>
<li><strong>There is one administrator</strong>: Multiple organizations and teams manage different parts</li>
<li><strong>Transport cost is zero</strong>: Serialization, network usage, and infrastructure have real costs</li>
<li><strong>The network is homogeneous</strong>: Different protocols, formats, and systems must interoperate</li>
</ol>
<h3 id="time-and-ordering"><a class="header" href="#time-and-ordering">Time and Ordering</a></h3>
<h4 id="physical-clocks"><a class="header" href="#physical-clocks">Physical Clocks</a></h4>
<ul>
<li><strong>Clock drift</strong>: Hardware clocks run at slightly different rates</li>
<li><strong>Clock skew</strong>: Difference between clock values at a point in time</li>
<li><strong>NTP (Network Time Protocol)</strong>: Synchronizes clocks across network
<ul>
<li>Accuracy: typically 1-50ms on internet, &lt;1ms on LAN</li>
<li>Cannot guarantee perfect synchronization</li>
</ul>
</li>
</ul>
<h4 id="logical-clocks"><a class="header" href="#logical-clocks">Logical Clocks</a></h4>
<h5 id="lamport-timestamps"><a class="header" href="#lamport-timestamps">Lamport Timestamps</a></h5>
<ul>
<li>Provides partial ordering of events</li>
<li>Each process maintains a counter</li>
<li>Algorithm:
<ol>
<li>Increment counter before each event</li>
<li>When sending message, include timestamp</li>
<li>On receiving message: counter = max(local_counter, message_timestamp) + 1</li>
</ol>
</li>
<li><strong>Limitation</strong>: Cannot distinguish concurrent events</li>
</ul>
<h5 id="vector-clocks"><a class="header" href="#vector-clocks">Vector Clocks</a></h5>
<ul>
<li>Provides causal ordering</li>
<li>Each process maintains vector of counters (one per process)</li>
<li>Can determine if events are concurrent or causally related</li>
<li>Algorithm:
<ol>
<li>Increment own position in vector before event</li>
<li>Send entire vector with message</li>
<li>On receive: merge vectors element-wise (take max) and increment own position</li>
</ol>
</li>
<li><strong>Use cases</strong>: Conflict detection in replicated systems (Riak, Voldemort)</li>
</ul>
<h5 id="hybrid-logical-clocks-hlc"><a class="header" href="#hybrid-logical-clocks-hlc">Hybrid Logical Clocks (HLC)</a></h5>
<ul>
<li>Combines physical and logical clocks</li>
<li>Maintains causality like vector clocks</li>
<li>Bounded by physical time</li>
<li>More compact than vector clocks</li>
<li>Used in: CockroachDB, MongoDB</li>
</ul>
<h4 id="happens-before-relationship"><a class="header" href="#happens-before-relationship">Happens-Before Relationship</a></h4>
<ul>
<li>Event A happens-before event B if:
<ol>
<li>A and B occur on same process and A occurs before B, OR</li>
<li>A is sending a message and B is receiving that message, OR</li>
<li>Transitive: A → C and C → B, then A → B</li>
</ol>
</li>
<li>Events are concurrent if neither happens-before the other</li>
</ul>
<h2 id="cap-theorem"><a class="header" href="#cap-theorem">CAP Theorem</a></h2>
<h3 id="the-theorem"><a class="header" href="#the-theorem">The Theorem</a></h3>
<p>Proven by Seth Gilbert and Nancy Lynch (2002), based on Eric Brewer’s conjecture (2000):</p>
<p>A distributed system can only guarantee <strong>two out of three</strong> properties simultaneously:</p>
<ul>
<li><strong>Consistency (C)</strong>: All nodes see the same data at the same time (linearizability)</li>
<li><strong>Availability (A)</strong>: Every request receives a response (success or failure), without guarantee of most recent write</li>
<li><strong>Partition Tolerance (P)</strong>: System continues to operate despite network partitions</li>
</ul>
<h3 id="understanding-the-trade-offs"><a class="header" href="#understanding-the-trade-offs">Understanding the Trade-offs</a></h3>
<p>Since <strong>network partitions are inevitable</strong> in real-world systems, the practical choice is:</p>
<h4 id="cp-systems-consistency--partition-tolerance"><a class="header" href="#cp-systems-consistency--partition-tolerance">CP Systems (Consistency + Partition Tolerance)</a></h4>
<p><strong>Choose consistency over availability during partitions</strong></p>
<ul>
<li>System refuses to respond or returns errors during partition</li>
<li>Ensures all clients see the same data</li>
<li>May sacrifice uptime</li>
</ul>
<p><strong>Real-world CP systems:</strong></p>
<ul>
<li><strong>HBase</strong>: Returns errors if cannot reach required replicas</li>
<li><strong>MongoDB</strong> (with strong consistency settings): Primary election during partition causes unavailability</li>
<li><strong>Redis</strong> (with wait command): Blocks until replication confirmed</li>
<li><strong>ZooKeeper</strong>: Refuses writes if cannot reach quorum</li>
<li><strong>Consul</strong>: CP for service configuration</li>
<li><strong>Google Spanner</strong>: Sacrifices availability for strong consistency across regions</li>
<li><strong>etcd</strong>: Raft-based consensus, unavailable during leader election</li>
</ul>
<p><strong>Use cases:</strong></p>
<ul>
<li>Financial transactions</li>
<li>Inventory management</li>
<li>Systems requiring strong guarantees</li>
</ul>
<h4 id="ap-systems-availability--partition-tolerance"><a class="header" href="#ap-systems-availability--partition-tolerance">AP Systems (Availability + Partition Tolerance)</a></h4>
<p><strong>Choose availability over consistency during partitions</strong></p>
<ul>
<li>System always responds, even if data might be stale</li>
<li>Different nodes may return different values temporarily</li>
<li>Eventual consistency when partition heals</li>
</ul>
<p><strong>Real-world AP systems:</strong></p>
<ul>
<li><strong>Cassandra</strong>: Always available, tunable consistency</li>
<li><strong>DynamoDB</strong>: Eventually consistent reads by default</li>
<li><strong>Riak</strong>: Highly available, uses vector clocks for conflict resolution</li>
<li><strong>CouchDB</strong>: Multi-master replication, conflict resolution</li>
<li><strong>Voldemort</strong>: Shopping cart always writable (Amazon design)</li>
<li><strong>DNS</strong>: Availability critical, stale data acceptable</li>
</ul>
<p><strong>Use cases:</strong></p>
<ul>
<li>Social media feeds</li>
<li>Product catalogs</li>
<li>User profiles</li>
<li>Shopping carts</li>
</ul>
<h3 id="pacelc-theorem"><a class="header" href="#pacelc-theorem">PACELC Theorem</a></h3>
<p>Extension by Daniel Abadi - describes behavior both during and without partitions:</p>
<ul>
<li><strong>If Partition (P)</strong>: choose between Availability (A) and Consistency (C)</li>
<li><strong>Else (E)</strong>: choose between Latency (L) and Consistency (C)</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><strong>PA/EL systems</strong>: Cassandra, Riak (Available during partition, Low latency otherwise)</li>
<li><strong>PC/EC systems</strong>: HBase, MongoDB (Consistent during partition, Consistent otherwise)</li>
<li><strong>PA/EC systems</strong>: DynamoDB (Available during partition, Consistent for normal ops)</li>
<li><strong>PC/EL systems</strong>: Rare, but some MySQL cluster configurations</li>
</ul>
<h2 id="consistency-models"><a class="header" href="#consistency-models">Consistency Models</a></h2>
<p>Consistency models define guarantees about when and how updates become visible.</p>
<h3 id="1-strong-consistency-linearizability"><a class="header" href="#1-strong-consistency-linearizability">1. Strong Consistency (Linearizability)</a></h3>
<p><strong>Guarantee</strong>: All operations appear to occur atomically in some total order consistent with real-time ordering</p>
<ul>
<li>Strongest consistency model</li>
<li>After write completes, all subsequent reads see that value or newer</li>
<li>Operations appear instantaneous</li>
<li>Expensive: requires coordination</li>
</ul>
<p><strong>Implementation approaches:</strong></p>
<ul>
<li>Consensus algorithms (Paxos, Raft)</li>
<li>Two-phase commit</li>
<li>Primary-copy replication with synchronous replication</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>Google Spanner</li>
<li>CockroachDB</li>
<li>etcd</li>
<li>ZooKeeper</li>
</ul>
<h3 id="2-sequential-consistency"><a class="header" href="#2-sequential-consistency">2. Sequential Consistency</a></h3>
<p><strong>Guarantee</strong>: Operations appear to take effect in some sequential order, consistent with program order on each process</p>
<ul>
<li>Weaker than linearizability (no real-time constraint)</li>
<li>All processes see operations in same order</li>
<li>Each process’s operations stay in order</li>
</ul>
<p><strong>Use cases:</strong></p>
<ul>
<li>Multi-processor memory models</li>
<li>Some distributed databases</li>
</ul>
<h3 id="3-causal-consistency"><a class="header" href="#3-causal-consistency">3. Causal Consistency</a></h3>
<p><strong>Guarantee</strong>: Causally related operations are seen in the same order by all processes</p>
<ul>
<li>Concurrent (non-causal) operations may be seen in different orders</li>
<li>Preserves happens-before relationships</li>
<li>More available than sequential consistency</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li>Vector clocks</li>
<li>Dependency tracking</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>COPS (Clusters of Order-Preserving Servers)</li>
<li>Bolt-on Causal Consistency (Facebook)</li>
</ul>
<h3 id="4-eventual-consistency"><a class="header" href="#4-eventual-consistency">4. Eventual Consistency</a></h3>
<p><strong>Guarantee</strong>: If no new updates, all replicas eventually converge to the same value</p>
<ul>
<li>Most available model</li>
<li>No guarantees about intermediate states</li>
<li>Convergence time unbounded (in theory)</li>
</ul>
<p><strong>Variants:</strong></p>
<h4 id="4a-read-your-writes-consistency"><a class="header" href="#4a-read-your-writes-consistency">4a. Read-Your-Writes Consistency</a></h4>
<ul>
<li>Process always sees its own writes</li>
<li>Other processes may see stale data</li>
<li>Implementation: read from same replica you wrote to, or track write version</li>
</ul>
<h4 id="4b-monotonic-reads"><a class="header" href="#4b-monotonic-reads">4b. Monotonic Reads</a></h4>
<ul>
<li>If process reads value X, subsequent reads never return older values</li>
<li>Prevents “going back in time”</li>
<li>Implementation: sticky sessions, or track last-read version</li>
</ul>
<h4 id="4c-monotonic-writes"><a class="header" href="#4c-monotonic-writes">4c. Monotonic Writes</a></h4>
<ul>
<li>Process’s writes are applied in order they were submitted</li>
<li>Implementation: serialize writes from same client</li>
</ul>
<h4 id="4d-writes-follow-reads"><a class="header" href="#4d-writes-follow-reads">4d. Writes-Follow-Reads</a></h4>
<ul>
<li>Write after reading value is guaranteed to see that read value or newer</li>
<li>Implementation: include read version with write</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>DynamoDB (default mode)</li>
<li>Cassandra (with eventual consistency level)</li>
<li>Riak</li>
<li>DNS</li>
</ul>
<h3 id="5-session-consistency"><a class="header" href="#5-session-consistency">5. Session Consistency</a></h3>
<p><strong>Guarantee</strong>: Strong consistency within a session, eventual consistency across sessions</p>
<ul>
<li>Combines read-your-writes, monotonic reads, and writes-follow-reads</li>
<li>Common in practice</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>Azure CosmosDB session consistency</li>
<li>Many web applications with sticky sessions</li>
</ul>
<h2 id="consensus-algorithms"><a class="header" href="#consensus-algorithms">Consensus Algorithms</a></h2>
<p>Consensus allows multiple nodes to agree on a single value or sequence of values, even in the presence of failures.</p>
<h3 id="paxos"><a class="header" href="#paxos">Paxos</a></h3>
<p>Developed by Leslie Lamport (1989), published 1998.</p>
<h4 id="roles"><a class="header" href="#roles">Roles</a></h4>
<ol>
<li><strong>Proposers</strong>: Propose values</li>
<li><strong>Acceptors</strong>: Vote on proposals (typically 2f+1 to tolerate f failures)</li>
<li><strong>Learners</strong>: Learn chosen value</li>
</ol>
<h4 id="algorithm-phases"><a class="header" href="#algorithm-phases">Algorithm Phases</a></h4>
<p><strong>Phase 1: Prepare</strong></p>
<ol>
<li>Proposer selects proposal number n, sends PREPARE(n) to acceptors</li>
<li>Acceptor receives PREPARE(n):
<ul>
<li>If n &gt; any previous proposal, promise not to accept proposals &lt; n</li>
<li>Return highest-numbered proposal already accepted (if any)</li>
</ul>
</li>
</ol>
<p><strong>Phase 2: Accept</strong></p>
<ol>
<li>If proposer receives responses from majority:
<ul>
<li>If any acceptor already accepted value, use highest-numbered one</li>
<li>Otherwise, use own value</li>
<li>Send ACCEPT(n, value) to acceptors</li>
</ul>
</li>
<li>Acceptor receives ACCEPT(n, value):
<ul>
<li>If n ≥ any promised proposal number, accept it</li>
<li>Notify learners</li>
</ul>
</li>
</ol>
<h4 id="challenges"><a class="header" href="#challenges">Challenges</a></h4>
<ul>
<li><strong>Livelock</strong>: Competing proposers can prevent progress
<ul>
<li>Solution: Use leader election, or randomized backoff</li>
</ul>
</li>
<li><strong>Complex</strong>: Difficult to understand and implement correctly</li>
<li><strong>Multi-Paxos</strong>: Extension for agreeing on sequence of values (log)</li>
</ul>
<h4 id="usage"><a class="header" href="#usage">Usage</a></h4>
<ul>
<li>Google Chubby lock service</li>
<li>Apache ZooKeeper (variant: ZAB - ZooKeeper Atomic Broadcast)</li>
<li>Cassandra (for lightweight transactions)</li>
</ul>
<h3 id="raft---deep-dive"><a class="header" href="#raft---deep-dive">Raft - Deep Dive</a></h3>
<p>Designed by Diego Ongaro and John Ousterhout (2014) for understandability.</p>
<h4 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h4>
<ul>
<li><strong>Strong leader</strong>: Log entries only flow from leader to followers</li>
<li><strong>Decomposed problem</strong>: Separate leader election, log replication, safety</li>
<li><strong>Simplicity</strong>: Easier to understand and implement than Paxos</li>
</ul>
<h4 id="server-states"><a class="header" href="#server-states">Server States</a></h4>
<ol>
<li><strong>Leader</strong>: Handles all client requests, sends heartbeats</li>
<li><strong>Follower</strong>: Passive, responds to RPCs from leader and candidates</li>
<li><strong>Candidate</strong>: Used to elect new leader</li>
</ol>
<h4 id="terms"><a class="header" href="#terms">Terms</a></h4>
<ul>
<li>Logical clock numbered with consecutive integers</li>
<li>Each term has at most one leader</li>
<li>Servers maintain current term number</li>
<li>Term advances when:
<ul>
<li>Follower times out and becomes candidate</li>
<li>Server discovers higher term</li>
</ul>
</li>
</ul>
<h4 id="leader-election"><a class="header" href="#leader-election">Leader Election</a></h4>
<p><strong>Trigger</strong>: Follower doesn’t receive heartbeat within election timeout (randomized: 150-300ms)</p>
<p><strong>Process</strong>:</p>
<ol>
<li>Follower increments term, transitions to candidate</li>
<li>Votes for self</li>
<li>Sends RequestVote RPCs to all servers</li>
<li>Outcomes:
<ul>
<li><strong>Wins election</strong>: Receives votes from majority → becomes leader</li>
<li><strong>Another server wins</strong>: Receives heartbeat with ≥ term → becomes follower</li>
<li><strong>Timeout</strong>: Split vote, nobody wins → start new election (increment term, retry)</li>
</ul>
</li>
</ol>
<p><strong>Vote granting</strong>:</p>
<ul>
<li>One vote per term, first-come-first-served</li>
<li>Candidate’s log must be at least as up-to-date:
<ul>
<li>Last log entry has higher term, OR</li>
<li>Same term but log is at least as long</li>
</ul>
</li>
</ul>
<p><strong>Election timeout randomization</strong>: Prevents split votes</p>
<h4 id="log-replication"><a class="header" href="#log-replication">Log Replication</a></h4>
<p><strong>Normal operation</strong>:</p>
<ol>
<li>Client sends command to leader</li>
<li>Leader appends entry to local log</li>
<li>Leader sends AppendEntries RPCs to followers</li>
<li>Once replicated on majority: entry is <strong>committed</strong></li>
<li>Leader applies entry to state machine, returns result to client</li>
<li>Leader includes commit index in heartbeats</li>
<li>Followers apply committed entries to their state machines</li>
</ol>
<p><strong>Log matching property</strong>:</p>
<ul>
<li>If two logs contain entry with same index and term:
<ul>
<li>They store the same command</li>
<li>All preceding entries are identical</li>
</ul>
</li>
</ul>
<p><strong>Consistency check</strong>:</p>
<ul>
<li>AppendEntries includes index and term of immediately preceding entry</li>
<li>Follower rejects if it doesn’t have matching entry</li>
<li>Leader decrements nextIndex and retries</li>
<li>Eventually finds point where logs match, overwrites follower’s inconsistent entries</li>
</ul>
<h4 id="safety-properties"><a class="header" href="#safety-properties">Safety Properties</a></h4>
<p><strong>Election restriction</strong>: Leader must contain all committed entries</p>
<ul>
<li>Ensured by vote granting rule (candidate’s log must be up-to-date)</li>
</ul>
<p><strong>Commitment rule</strong>: Leader never overwrites or deletes entries in its log</p>
<ul>
<li>Only appends new entries</li>
</ul>
<p><strong>State machine safety</strong>: If server has applied log entry at index i, no other server applies different entry at index i</p>
<h4 id="log-compaction-snapshotting"><a class="header" href="#log-compaction-snapshotting">Log Compaction (Snapshotting)</a></h4>
<ul>
<li>Snapshot includes:
<ul>
<li>State machine state</li>
<li>Last included index and term</li>
</ul>
</li>
<li>Discard log entries before snapshot</li>
<li>Send InstallSnapshot RPC to slow followers</li>
</ul>
<h4 id="cluster-membership-changes"><a class="header" href="#cluster-membership-changes">Cluster Membership Changes</a></h4>
<ul>
<li><strong>Joint consensus</strong>: Two configurations overlap during transition</li>
<li>Prevents split-brain during reconfiguration</li>
</ul>
<h4 id="key-advantages"><a class="header" href="#key-advantages">Key Advantages</a></h4>
<ol>
<li><strong>Understandability</strong>: Clear separation of concerns</li>
<li><strong>Strong leader</strong>: Simplifies log replication</li>
<li><strong>Randomized timeouts</strong>: Solves split vote problem elegantly</li>
<li><strong>Membership changes</strong>: Safe reconfiguration protocol</li>
</ol>
<p><strong>Implementations</strong>:</p>
<ul>
<li>etcd (Kubernetes)</li>
<li>Consul (HashiCorp)</li>
<li>CockroachDB</li>
<li>TiKV (TiDB)</li>
</ul>
<h3 id="two-phase-commit-2pc"><a class="header" href="#two-phase-commit-2pc">Two-Phase Commit (2PC)</a></h3>
<p>Atomic commitment protocol for distributed transactions.</p>
<h4 id="roles-1"><a class="header" href="#roles-1">Roles</a></h4>
<ul>
<li><strong>Coordinator</strong>: Orchestrates the commit</li>
<li><strong>Participants</strong>: Resources being committed (databases, services)</li>
</ul>
<h4 id="phases"><a class="header" href="#phases">Phases</a></h4>
<p><strong>Phase 1: Prepare (Voting)</strong></p>
<ol>
<li>Coordinator sends PREPARE message to all participants</li>
<li>Each participant:
<ul>
<li>Prepares transaction (write to redo log, acquire locks)</li>
<li>Votes YES (can commit) or NO (abort)</li>
<li>If YES, enters prepared state (cannot unilaterally abort)</li>
</ul>
</li>
</ol>
<p><strong>Phase 2: Commit/Abort</strong></p>
<ol>
<li>Coordinator collects votes:
<ul>
<li>If all YES: sends COMMIT to all participants</li>
<li>If any NO or timeout: sends ABORT to all participants</li>
</ul>
</li>
<li>Participants execute command and acknowledge</li>
<li>Coordinator completes when all acknowledgments received</li>
</ol>
<h4 id="problems"><a class="header" href="#problems">Problems</a></h4>
<p><strong>Blocking protocol</strong>:</p>
<ul>
<li>If coordinator crashes after PREPARE, participants are blocked</li>
<li>Cannot commit or abort without coordinator decision</li>
<li>Locks held until coordinator recovers</li>
</ul>
<p><strong>No progress guarantee</strong>:</p>
<ul>
<li>Single point of failure (coordinator)</li>
<li>Participant failures also block progress</li>
</ul>
<p><strong>Performance</strong>:</p>
<ul>
<li>Multiple round-trips</li>
<li>Synchronous blocking</li>
<li>High latency</li>
</ul>
<p><strong>Usage</strong>: Traditional distributed databases (Oracle, DB2, MySQL XA)</p>
<h3 id="three-phase-commit-3pc"><a class="header" href="#three-phase-commit-3pc">Three-Phase Commit (3PC)</a></h3>
<p>Non-blocking extension of 2PC.</p>
<h4 id="additional-phase-pre-commit"><a class="header" href="#additional-phase-pre-commit">Additional Phase: Pre-Commit</a></h4>
<p><strong>Phase 1: CanCommit</strong></p>
<ul>
<li>Like 2PC prepare phase</li>
</ul>
<p><strong>Phase 2: PreCommit</strong></p>
<ul>
<li>Coordinator sends PRECOMMIT if all voted YES</li>
<li>Participants acknowledge</li>
<li><strong>Key property</strong>: If participant receives PRECOMMIT, it knows all voted YES</li>
</ul>
<p><strong>Phase 3: DoCommit</strong></p>
<ul>
<li>Coordinator sends COMMIT</li>
<li>Participants commit and acknowledge</li>
</ul>
<h4 id="advantages"><a class="header" href="#advantages">Advantages</a></h4>
<ul>
<li><strong>Non-blocking</strong>: Participants can make progress using timeout + state machine</li>
<li>If participant times out in pre-commit state, it knows all voted YES → can commit</li>
</ul>
<h4 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h4>
<ul>
<li><strong>Network partitions</strong>: Can lead to inconsistency if partition occurs between phases</li>
<li><strong>More latency</strong>: Additional round-trip</li>
<li><strong>Rarely used in practice</strong>: Complexity outweighs benefits; partition tolerance is critical</li>
</ul>
<h2 id="distributed-transactions"><a class="header" href="#distributed-transactions">Distributed Transactions</a></h2>
<h3 id="acid-in-distributed-systems"><a class="header" href="#acid-in-distributed-systems">ACID in Distributed Systems</a></h3>
<p>Traditional ACID properties are challenging in distributed environments:</p>
<h4 id="atomicity"><a class="header" href="#atomicity">Atomicity</a></h4>
<ul>
<li><strong>Challenge</strong>: Partial failures across multiple nodes</li>
<li><strong>Solutions</strong>:
<ul>
<li>Two-phase commit (2PC)</li>
<li>Saga pattern with compensating transactions</li>
<li>Consensus-based approaches (Raft, Paxos)</li>
</ul>
</li>
</ul>
<h4 id="consistency"><a class="header" href="#consistency">Consistency</a></h4>
<ul>
<li><strong>Challenge</strong>: Maintaining invariants across distributed data</li>
<li><strong>Solutions</strong>:
<ul>
<li>Application-level validation</li>
<li>Distributed constraints checking</li>
<li>Eventual consistency with conflict resolution</li>
</ul>
</li>
</ul>
<h4 id="isolation"><a class="header" href="#isolation">Isolation</a></h4>
<ul>
<li><strong>Challenge</strong>: Coordinating concurrent access across nodes</li>
<li><strong>Solutions</strong>:
<ul>
<li>Distributed locking (pessimistic)</li>
<li>Optimistic concurrency control</li>
<li>Snapshot isolation (Google Spanner)</li>
<li>Serializable Snapshot Isolation (SSI)</li>
</ul>
</li>
</ul>
<h4 id="durability"><a class="header" href="#durability">Durability</a></h4>
<ul>
<li><strong>Challenge</strong>: Ensuring writes survive failures</li>
<li><strong>Solutions</strong>:
<ul>
<li>Replication (synchronous or asynchronous)</li>
<li>Write-ahead logging</li>
<li>Quorum-based writes</li>
</ul>
</li>
</ul>
<h3 id="saga-pattern"><a class="header" href="#saga-pattern">Saga Pattern</a></h3>
<p>Long-lived transactions broken into sequence of local transactions, each with compensating action.</p>
<h4 id="choreography"><a class="header" href="#choreography">Choreography</a></h4>
<p><strong>Decentralized coordination</strong>: Each service produces and listens to events</p>
<p><strong>Example</strong>: Order placement</p>
<pre><code>1. Order Service: Create order → Emit OrderCreated event
2. Inventory Service: Reserve items → Emit ItemsReserved (or ReservationFailed)
3. Payment Service: Charge customer → Emit PaymentSucceeded (or PaymentFailed)
4. Shipping Service: Schedule shipment → Emit ShipmentScheduled

If any step fails:
- Emit failure event
- Previous services listen and execute compensating transactions
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>No central coordination</li>
<li>Loose coupling</li>
<li>Good for simple workflows</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Hard to understand and debug</li>
<li>Difficult to track overall state</li>
<li>Complex error handling</li>
<li>Cyclic dependencies possible</li>
</ul>
<h4 id="orchestration"><a class="header" href="#orchestration">Orchestration</a></h4>
<p><strong>Centralized coordination</strong>: Orchestrator tells services what to do</p>
<p><strong>Example</strong>: Same order placement</p>
<pre><code>Orchestrator:
1. Call Order Service: Create order
2. Call Inventory Service: Reserve items
   - If fails: Call Order Service: Cancel order → END
3. Call Payment Service: Charge customer
   - If fails: Call Inventory: Release items → Call Order: Cancel → END
4. Call Shipping Service: Schedule shipment
   - If fails: Call Payment: Refund → Call Inventory: Release → Call Order: Cancel → END
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Clear workflow logic in one place</li>
<li>Easier to understand and debug</li>
<li>Centralized monitoring</li>
<li>Timeout management simplified</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Orchestrator is potential bottleneck</li>
<li>Additional infrastructure required</li>
<li>Tighter coupling to orchestrator</li>
</ul>
<h3 id="compensating-transactions"><a class="header" href="#compensating-transactions">Compensating Transactions</a></h3>
<p><strong>Semantic undo</strong>: Logically reverse a transaction (not physical undo)</p>
<p><strong>Examples</strong>:</p>
<ul>
<li>Order placement → Order cancellation</li>
<li>Money debit → Money credit</li>
<li>Item reservation → Item release</li>
<li>Email sent → Correction email (cannot “unsend”)</li>
</ul>
<p><strong>Key properties</strong>:</p>
<ul>
<li><strong>Idempotent</strong>: Safe to retry</li>
<li><strong>Commutative</strong> (ideally): Order shouldn’t matter</li>
<li><strong>Semantically correct</strong>: Achieves business goal of reversal</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Some actions cannot be compensated (sent email, published data)</li>
<li>Timing issues (compensate before user sees original effect?)</li>
<li>Partial compensations</li>
<li>Compensation failures (need retries, dead letter queues)</li>
</ul>
<p><strong>Best practices</strong>:</p>
<ol>
<li>Design compensating actions upfront</li>
<li>Make them idempotent</li>
<li>Log all actions for audit trail</li>
<li>Monitor saga execution</li>
<li>Alert on compensation failures</li>
<li>Consider time windows for compensation</li>
</ol>
<h2 id="event-sourcing"><a class="header" href="#event-sourcing">Event Sourcing</a></h2>
<h3 id="core-concept"><a class="header" href="#core-concept">Core Concept</a></h3>
<p><strong>Event log as source of truth</strong>: Store all changes as immutable sequence of events, rather than storing current state.</p>
<p><strong>Traditional approach</strong>:</p>
<pre><code>User account table: { id: 1, name: "Alice", email: "alice@example.com", balance: 1000 }
Update balance → Overwrite value
</code></pre>
<p><strong>Event sourcing</strong>:</p>
<pre><code>Events:
1. UserCreated(id=1, name="Alice", email="alice@example.com")
2. DepositMade(id=1, amount=1000)
3. WithdrawalMade(id=1, amount=200)
4. DepositMade(id=1, amount=200)

Current state = replay all events
Balance = 0 + 1000 - 200 + 200 = 1000
</code></pre>
<h3 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h3>
<ol>
<li><strong>Audit trail</strong>: Complete history of what happened</li>
<li><strong>Time travel</strong>: Reconstruct state at any point in time</li>
<li><strong>Event replay</strong>: Fix bugs by replaying with corrected logic</li>
<li><strong>Multiple projections</strong>: Build different views from same events</li>
<li><strong>Debug and analysis</strong>: Understand how system reached current state</li>
<li><strong>Event notifications</strong>: Other systems subscribe to events</li>
</ol>
<h3 id="event-store"><a class="header" href="#event-store">Event Store</a></h3>
<p><strong>Append-only log</strong> of events:</p>
<ul>
<li>Events are immutable</li>
<li>Only append new events, never modify or delete</li>
<li>Events ordered (typically per aggregate)</li>
</ul>
<p><strong>Operations</strong>:</p>
<ul>
<li><strong>Append</strong>: Add new event</li>
<li><strong>Read</strong>: Get events for aggregate or time range</li>
<li><strong>Subscribe</strong>: Listen for new events</li>
</ul>
<p><strong>Implementations</strong>:</p>
<ul>
<li>Event Store DB</li>
<li>Apache Kafka</li>
<li>Custom database tables</li>
<li>AWS DynamoDB Streams</li>
</ul>
<h3 id="event-replay"><a class="header" href="#event-replay">Event Replay</a></h3>
<p><strong>Rebuild state</strong> by replaying events:</p>
<pre><code>Initial state: empty
Apply UserCreated → { id: 1, name: "Alice", email: "alice@example.com", balance: 0 }
Apply DepositMade → { balance: 1000 }
Apply WithdrawalMade → { balance: 800 }
Apply DepositMade → { balance: 1000 }
</code></pre>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Rebuild read models after schema change</li>
<li>Fix bugs in event handlers</li>
<li>Create new projections</li>
<li>Audit and compliance</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Slow for large event streams</li>
<li>Schema evolution (old events with old format)</li>
<li>Solution: Snapshots</li>
</ul>
<h3 id="snapshotting"><a class="header" href="#snapshotting">Snapshotting</a></h3>
<p><strong>Periodic state snapshots</strong> to avoid replaying all events.</p>
<p><strong>Process</strong>:</p>
<ol>
<li>Replay events up to snapshot point</li>
<li>Save snapshot with version/event number</li>
<li>To rebuild: Load snapshot + replay subsequent events</li>
</ol>
<p><strong>Example</strong>:</p>
<pre><code>Events 1-1000: Snapshot at event 1000 (balance = 5000)
Events 1001-1500: Current state
To get current state: Load snapshot + replay events 1001-1500
</code></pre>
<p><strong>Snapshot strategies</strong>:</p>
<ul>
<li><strong>Periodic</strong>: Every N events or time interval</li>
<li><strong>On-demand</strong>: When loading latest snapshot + replaying is still fast enough</li>
<li><strong>Per aggregate</strong>: Different aggregates snapshot independently</li>
</ul>
<p><strong>Storage</strong>:</p>
<ul>
<li>Same event store</li>
<li>Separate snapshot store</li>
<li>Cache (Redis, Memcached)</li>
</ul>
<h3 id="cqrs-integration"><a class="header" href="#cqrs-integration">CQRS Integration</a></h3>
<p><strong>Command Query Responsibility Segregation</strong>: Separate models for reads and writes.</p>
<p><strong>Event sourcing + CQRS</strong>:</p>
<p><strong>Write side (Command)</strong>:</p>
<ul>
<li>Commands validate and generate events</li>
<li>Events appended to event store</li>
<li>No read operations on write model</li>
</ul>
<p><strong>Read side (Query)</strong>:</p>
<ul>
<li>Event handlers build projections (read models)</li>
<li>Optimized for queries (denormalized, indexed)</li>
<li>Can have multiple projections for different use cases</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code>Commands (Write):
- CreateOrder
- AddOrderItem
- PlaceOrder
→ Generate events: OrderCreated, ItemAdded, OrderPlaced
→ Store in event log

Events published →

Read Models (Query):
1. Order details view: Relational table with current order state
2. Order history view: Timeline of order changes
3. Analytics view: Aggregated sales data
4. Search index: Elasticsearch for order search
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Independent scaling of reads and writes</li>
<li>Optimize each side for its purpose</li>
<li>Multiple specialized read models</li>
<li>Eventual consistency acceptable</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Eventual consistency between write and read</li>
<li>More complex architecture</li>
<li>Data duplication across projections</li>
<li>Need to handle projection rebuilds</li>
</ul>
<h3 id="event-schema-evolution"><a class="header" href="#event-schema-evolution">Event Schema Evolution</a></h3>
<p><strong>Problem</strong>: Old events with old schema, new code expects new schema</p>
<p><strong>Strategies</strong>:</p>
<ol>
<li><strong>Upcasting</strong>: Convert old events to new format when reading</li>
<li><strong>Versioned events</strong>: Include version number, handle each version</li>
<li><strong>Weak schema</strong>: Use flexible formats (JSON) with optional fields</li>
<li><strong>Event migration</strong>: Background process to rewrite old events (rare)</li>
</ol>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ol>
<li><strong>Events are facts</strong>: Past tense (UserRegistered, OrderPlaced, not RegisterUser)</li>
<li><strong>Events are immutable</strong>: Never change or delete events</li>
<li><strong>Domain events</strong>: Model business events, not CRUD operations</li>
<li><strong>Idempotency</strong>: Handle duplicate events gracefully</li>
<li><strong>Event size</strong>: Keep events small and focused</li>
<li><strong>Correlation IDs</strong>: Track related events across aggregates</li>
<li><strong>Metadata</strong>: Timestamp, user, causation ID, correlation ID</li>
<li><strong>Testing</strong>: Verify state transitions via event replay</li>
</ol>
<h2 id="replication"><a class="header" href="#replication">Replication</a></h2>
<p>Keeping copies of data on multiple nodes for fault tolerance and performance.</p>
<h3 id="leader-follower-replication-master-slave"><a class="header" href="#leader-follower-replication-master-slave">Leader-Follower Replication (Master-Slave)</a></h3>
<p><strong>One leader</strong> accepts writes, <strong>followers</strong> replicate and serve reads.</p>
<h4 id="synchronous-replication"><a class="header" href="#synchronous-replication">Synchronous Replication</a></h4>
<ul>
<li>Leader waits for follower acknowledgment before confirming write</li>
<li><strong>Pros</strong>: Follower guaranteed to have up-to-date copy</li>
<li><strong>Cons</strong>: Write latency increases, unavailable if follower down</li>
<li><strong>Semi-synchronous</strong>: Wait for one follower, others async</li>
</ul>
<h4 id="asynchronous-replication"><a class="header" href="#asynchronous-replication">Asynchronous Replication</a></h4>
<ul>
<li>Leader confirms write immediately, replicates in background</li>
<li><strong>Pros</strong>: Low latency, high availability</li>
<li><strong>Cons</strong>: Data loss if leader fails before replication</li>
<li><strong>Most common</strong> in practice</li>
</ul>
<h4 id="follower-failure-and-catch-up"><a class="header" href="#follower-failure-and-catch-up">Follower Failure and Catch-up</a></h4>
<ul>
<li>Follower keeps log of processed transactions</li>
<li>On reconnect, requests all changes since last processed</li>
<li>Applies changes to catch up</li>
</ul>
<h4 id="leader-failure-failover"><a class="header" href="#leader-failure-failover">Leader Failure (Failover)</a></h4>
<p><strong>Detection</strong>: Heartbeat timeout (typically 30s)</p>
<p><strong>New leader election</strong>:</p>
<ol>
<li>Promote follower (often most up-to-date)</li>
<li>Reconfigure clients to send writes to new leader</li>
<li>Old leader becomes follower when it recovers</li>
</ol>
<p><strong>Challenges</strong>:</p>
<ul>
<li><strong>Data loss</strong>: If async replication, some writes lost</li>
<li><strong>Split brain</strong>: Two nodes think they’re leader</li>
<li><strong>Timeout tuning</strong>: Too short → unnecessary failovers, too long → longer downtime</li>
</ul>
<h4 id="replication-log-implementation"><a class="header" href="#replication-log-implementation">Replication Log Implementation</a></h4>
<p><strong>Statement-based</strong>: Ship SQL statements</p>
<ul>
<li><strong>Problem</strong>: Non-deterministic functions (NOW(), RAND())</li>
</ul>
<p><strong>Write-ahead log (WAL) shipping</strong>: Ship low-level disk writes</p>
<ul>
<li><strong>Problem</strong>: Tightly coupled to storage engine</li>
</ul>
<p><strong>Logical (row-based) log</strong>: Ship logical row changes</p>
<ul>
<li><strong>Most common</strong>: Decoupled from storage, supports different versions</li>
</ul>
<p><strong>Trigger-based</strong>: Application-level triggers</p>
<ul>
<li><strong>Flexibility</strong>: Custom logic, but higher overhead</li>
</ul>
<h3 id="multi-leader-replication-multi-master"><a class="header" href="#multi-leader-replication-multi-master">Multi-Leader Replication (Multi-Master)</a></h3>
<p><strong>Multiple nodes</strong> accept writes, replicate to each other.</p>
<h4 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h4>
<ul>
<li><strong>Multi-datacenter</strong>: Leader in each datacenter</li>
<li><strong>Offline clients</strong>: Each device is a leader (mobile apps)</li>
<li><strong>Collaborative editing</strong>: Each user’s edits are writes</li>
</ul>
<h4 id="advantages-1"><a class="header" href="#advantages-1">Advantages</a></h4>
<ul>
<li><strong>Performance</strong>: Lower latency (write to nearest leader)</li>
<li><strong>Fault tolerance</strong>: Continue operating if datacenter fails</li>
<li><strong>Availability</strong>: Each datacenter operates independently</li>
</ul>
<h4 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h4>
<p><strong>Conflicts inevitable</strong>: Same key modified concurrently at different leaders</p>
<p><strong>Example</strong>:</p>
<pre><code>User A (DC1): Update title = "Distributed Systems"
User B (DC2): Update title = "Distributed Computing"
Both writes succeed locally, then replicate to each other
→ Conflict!
</code></pre>
<p><strong>Resolution strategies</strong>:</p>
<ol>
<li>
<p><strong>Last-write-wins (LWW)</strong>:</p>
<ul>
<li>Use timestamp or version number</li>
<li><strong>Problem</strong>: Data loss, timestamp synchronization issues</li>
<li><strong>Use</strong>: Cassandra, Riak (with client-side timestamps)</li>
</ul>
</li>
<li>
<p><strong>Application-level resolution</strong>:</p>
<ul>
<li>Application provides conflict handler</li>
<li><strong>Example</strong>: Merge function for collaborative editing</li>
<li><strong>Use</strong>: CouchDB</li>
</ul>
</li>
<li>
<p><strong>Multi-value (version vectors)</strong>:</p>
<ul>
<li>Keep all conflicting versions</li>
<li>Application reads all versions and resolves</li>
<li><strong>Use</strong>: Riak, Voldemort</li>
</ul>
</li>
<li>
<p><strong>CRDT (Conflict-free Replicated Data Types)</strong>:</p>
<ul>
<li>Data structures with built-in conflict resolution</li>
<li>Mathematically proven to converge</li>
<li><strong>Examples</strong>: Counters, sets, maps</li>
<li><strong>Use</strong>: Riak (maps), Redis (CRDTs)</li>
</ul>
</li>
<li>
<p><strong>Operational Transform</strong>:</p>
<ul>
<li>Transform concurrent operations so they can be applied in any order</li>
<li><strong>Use</strong>: Google Docs, collaborative editing</li>
</ul>
</li>
</ol>
<p><strong>Custom topologies</strong>:</p>
<ul>
<li><strong>Circular</strong>: Each leader replicates to next in ring</li>
<li><strong>Star</strong>: One designated root, others replicate through it</li>
<li><strong>All-to-all</strong>: Every leader replicates to every other (most common)</li>
</ul>
<h3 id="leaderless-replication-dynamo-style"><a class="header" href="#leaderless-replication-dynamo-style">Leaderless Replication (Dynamo-style)</a></h3>
<p><strong>No leader</strong>: Client writes to multiple replicas directly.</p>
<h4 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h4>
<p><strong>Quorum reads and writes</strong>:</p>
<ul>
<li>N = total replicas</li>
<li>W = write quorum (replicas that must acknowledge write)</li>
<li>R = read quorum (replicas that must respond to read)</li>
<li><strong>Rule</strong>: W + R &gt; N ensures reads see recent writes</li>
</ul>
<p><strong>Example</strong>: N=3, W=2, R=2</p>
<ul>
<li>Write succeeds when 2 of 3 replicas acknowledge</li>
<li>Read queries 2 of 3 replicas, takes newest value</li>
</ul>
<h4 id="read-repair"><a class="header" href="#read-repair">Read Repair</a></h4>
<ul>
<li>Read queries multiple replicas</li>
<li>If stale data detected, write newer value back</li>
<li>Ensures eventually all replicas converge</li>
</ul>
<h4 id="anti-entropy-process"><a class="header" href="#anti-entropy-process">Anti-Entropy Process</a></h4>
<ul>
<li>Background process compares replicas</li>
<li>Synchronizes differences</li>
<li>Uses Merkle trees for efficient comparison</li>
</ul>
<h4 id="sloppy-quorums-and-hinted-handoff"><a class="header" href="#sloppy-quorums-and-hinted-handoff">Sloppy Quorums and Hinted Handoff</a></h4>
<p><strong>Problem</strong>: W replicas unavailable, write would fail</p>
<p><strong>Sloppy quorum</strong>: Accept writes to any W available nodes, even if not “home” replicas</p>
<p><strong>Hinted handoff</strong>: When home replica recovers, temporary replica forwards writes</p>
<p><strong>Trade-off</strong>: Higher availability, but W + R &gt; N doesn’t guarantee latest value</p>
<h4 id="conflict-resolution-1"><a class="header" href="#conflict-resolution-1">Conflict Resolution</a></h4>
<ul>
<li>Same strategies as multi-leader (LWW, version vectors, CRDTs)</li>
<li><strong>Siblings</strong>: Multiple conflicting values returned to client</li>
<li><strong>Application resolves</strong>: Client merges conflicts</li>
</ul>
<p><strong>Examples</strong>:</p>
<ul>
<li>Amazon DynamoDB</li>
<li>Apache Cassandra</li>
<li>Riak</li>
<li>Voldemort</li>
</ul>
<h3 id="conflict-resolution-strategies-detailed"><a class="header" href="#conflict-resolution-strategies-detailed">Conflict Resolution Strategies (Detailed)</a></h3>
<h4 id="1-version-vectors-vector-clocks"><a class="header" href="#1-version-vectors-vector-clocks">1. Version Vectors (Vector Clocks)</a></h4>
<p>Track causality to detect conflicts:</p>
<pre><code>Initial: {}
Write A: {A:1} value="Alice"
Write B: {B:1} value="Bob"
Replicate A→B: {A:1, B:1} (conflict detected!)
Replicate B→A: {A:1, B:1} (conflict detected!)
→ Application resolves: {A:1, B:1} value="Alice, Bob"
</code></pre>
<h4 id="2-crdts-conflict-free-replicated-data-types"><a class="header" href="#2-crdts-conflict-free-replicated-data-types">2. CRDTs (Conflict-free Replicated Data Types)</a></h4>
<p><strong>Grow-only Counter (G-Counter)</strong>:</p>
<ul>
<li>Each replica maintains counter per node</li>
<li>Increment local counter</li>
<li>Merge: take max of each position</li>
<li>Value = sum of all counters</li>
</ul>
<p><strong>PN-Counter (Positive-Negative Counter)</strong>:</p>
<ul>
<li>Two G-Counters: increments and decrements</li>
<li>Value = increments - decrements</li>
</ul>
<p><strong>G-Set (Grow-only Set)</strong>:</p>
<ul>
<li>Add-only set</li>
<li>Merge: union</li>
</ul>
<p><strong>OR-Set (Observed-Remove Set)</strong>:</p>
<ul>
<li>Add includes unique tag</li>
<li>Remove based on observed tags</li>
<li>Merge: union adds, remove only if tag in removed set</li>
</ul>
<p><strong>LWW-Register (Last-Write-Wins Register)</strong>:</p>
<ul>
<li>Each write includes timestamp</li>
<li>Merge: keep value with latest timestamp</li>
</ul>
<h4 id="3-operational-transform"><a class="header" href="#3-operational-transform">3. Operational Transform</a></h4>
<p>Transform concurrent operations to maintain consistency:</p>
<pre><code>Initial: "Hello"
Op1: Insert("World", position=5)  → "HelloWorld"
Op2: Delete(position=0, length=1) → "ello"

Transform Op1 for Op2: Insert("World", position=4)  → "elloWorld"
Both paths converge to same result
</code></pre>
<h2 id="partitioning-sharding"><a class="header" href="#partitioning-sharding">Partitioning (Sharding)</a></h2>
<p>Splitting data across multiple nodes to scale beyond single machine capacity.</p>
<h3 id="horizontal-vs-vertical-partitioning"><a class="header" href="#horizontal-vs-vertical-partitioning">Horizontal vs Vertical Partitioning</a></h3>
<h4 id="vertical-partitioning"><a class="header" href="#vertical-partitioning">Vertical Partitioning</a></h4>
<ul>
<li>Split <strong>columns</strong> into separate tables/databases</li>
<li><strong>Example</strong>: User table → (UserProfile, UserActivity, UserSettings)</li>
<li><strong>Use case</strong>: Different access patterns, separate hot/cold data</li>
<li><strong>Limit</strong>: Still limited by single-entity scale</li>
</ul>
<h4 id="horizontal-partitioning-sharding"><a class="header" href="#horizontal-partitioning-sharding">Horizontal Partitioning (Sharding)</a></h4>
<ul>
<li>Split <strong>rows</strong> across multiple nodes</li>
<li><strong>Example</strong>: Users 1-1000 → Node A, Users 1001-2000 → Node B</li>
<li><strong>Use case</strong>: True scalability, no single-node bottleneck</li>
</ul>
<h3 id="sharding-strategies"><a class="header" href="#sharding-strategies">Sharding Strategies</a></h3>
<h4 id="1-range-based-sharding"><a class="header" href="#1-range-based-sharding">1. Range-Based Sharding</a></h4>
<p><strong>Partition by key ranges</strong>:</p>
<pre><code>A-F → Shard 1
G-M → Shard 2
N-Z → Shard 3
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Range queries efficient</li>
<li>Easy to understand</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li><strong>Hotspots</strong>: Uneven distribution (many names start with S, few with Q)</li>
<li>Load imbalance</li>
<li>Requires understanding of data distribution</li>
</ul>
<p><strong>Example</strong>: HBase, MongoDB (with range-based shard keys)</p>
<h4 id="2-hash-based-sharding"><a class="header" href="#2-hash-based-sharding">2. Hash-Based Sharding</a></h4>
<p><strong>Hash key to determine partition</strong>:</p>
<pre><code>hash(user_id) % num_shards → shard_id
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Even distribution</li>
<li>No hotspots (if good hash function)</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Range queries require querying all shards</li>
<li>Rebalancing requires moving data</li>
</ul>
<p><strong>Example</strong>: Cassandra, Redis Cluster</p>
<h4 id="3-directory-based-sharding"><a class="header" href="#3-directory-based-sharding">3. Directory-Based Sharding</a></h4>
<p><strong>Lookup table</strong> maps keys to shards:</p>
<pre><code>Lookup table:
user_id=1 → Shard A
user_id=2 → Shard A
user_id=3 → Shard B
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Flexible placement</li>
<li>Easy to rebalance (update directory)</li>
<li>Can use any partitioning logic</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Lookup table is bottleneck and single point of failure</li>
<li>Additional latency</li>
</ul>
<p><strong>Example</strong>: Some MySQL sharding solutions</p>
<h3 id="consistent-hashing"><a class="header" href="#consistent-hashing">Consistent Hashing</a></h3>
<p>Minimizes data movement when nodes added/removed.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Hash nodes and keys to same hash space (e.g., 0-2^32)</li>
<li>Arrange nodes on hash ring</li>
<li>Key belongs to first node clockwise from key position</li>
</ol>
<p><strong>Example</strong>:</p>
<pre><code>Ring: [Node A at 0, Node B at 1000, Node C at 2000]
Key X hashes to 1500 → belongs to Node C
</code></pre>
<p><strong>Adding node D at 500</strong>:</p>
<ul>
<li>Only keys between Node A (0) and Node D (500) move to Node D</li>
<li>~1/4 of keys move (not all keys like in modulo hashing)</li>
</ul>
<p><strong>Virtual nodes</strong>:</p>
<ul>
<li>Each physical node represented by multiple virtual nodes</li>
<li>Better load distribution</li>
<li>Smoother scaling</li>
</ul>
<p><strong>Usage</strong>:</p>
<ul>
<li>Cassandra</li>
<li>DynamoDB</li>
<li>Riak</li>
<li>Chord DHT</li>
<li>Memcached (client-side)</li>
</ul>
<h3 id="rebalancing"><a class="header" href="#rebalancing">Rebalancing</a></h3>
<p><strong>Goal</strong>: Move data when adding/removing nodes while minimizing disruption</p>
<h4 id="strategies"><a class="header" href="#strategies">Strategies</a></h4>
<p><strong>1. Don’t use hash % num_nodes</strong>:</p>
<ul>
<li>Problem: Changing num_nodes moves almost all keys</li>
<li>Solution: Use consistent hashing or fixed number of partitions</li>
</ul>
<p><strong>2. Fixed number of partitions</strong>:</p>
<ul>
<li>Create many partitions upfront (e.g., 1000)</li>
<li>Assign partitions to nodes</li>
<li>When adding node, move some partitions to new node</li>
<li><strong>Example</strong>: Riak, Elasticsearch, Couchbase</li>
</ul>
<p><strong>3. Dynamic partitioning</strong>:</p>
<ul>
<li>Split partitions when they grow too large</li>
<li>Merge when too small</li>
<li><strong>Example</strong>: HBase, MongoDB</li>
</ul>
<p><strong>4. Proportional to nodes</strong>:</p>
<ul>
<li>Fixed number of partitions per node</li>
<li>When node added, steal partitions from existing nodes</li>
<li><strong>Example</strong>: Cassandra (virtual nodes)</li>
</ul>
<h4 id="rebalancing-process"><a class="header" href="#rebalancing-process">Rebalancing Process</a></h4>
<p><strong>Manual vs Automatic</strong>:</p>
<ul>
<li><strong>Manual</strong>: Administrator triggers rebalancing
<ul>
<li>More control, prevents cascading failures</li>
</ul>
</li>
<li><strong>Automatic</strong>: System rebalances automatically
<ul>
<li>Convenient, but can cause issues during partial failures</li>
</ul>
</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li><strong>Network load</strong>: Rebalancing moves lots of data</li>
<li><strong>Performance impact</strong>: Resources diverted from serving requests</li>
<li><strong>Consistency</strong>: Ensure availability during rebalancing</li>
</ul>
<h3 id="partitioning-and-secondary-indexes"><a class="header" href="#partitioning-and-secondary-indexes">Partitioning and Secondary Indexes</a></h3>
<p><strong>Problem</strong>: How to handle queries by non-partition key?</p>
<h4 id="document-based-partitioning-local-index"><a class="header" href="#document-based-partitioning-local-index">Document-based Partitioning (Local Index)</a></h4>
<p>Each partition maintains index for its own data only.</p>
<p><strong>Query process</strong>: Scatter-gather across all partitions</p>
<p><strong>Example</strong>:</p>
<pre><code>Partition 1: Users A-M, index on age for users A-M
Partition 2: Users N-Z, index on age for users N-Z

Query "age=25": Query both partitions, merge results
</code></pre>
<p><strong>Pros</strong>: Writes only affect one partition
<strong>Cons</strong>: Reads are expensive (query all partitions)</p>
<p><strong>Use</strong>: MongoDB, Cassandra</p>
<h4 id="term-based-partitioning-global-index"><a class="header" href="#term-based-partitioning-global-index">Term-based Partitioning (Global Index)</a></h4>
<p>Index itself is partitioned separately from data.</p>
<p><strong>Example</strong>:</p>
<pre><code>Data partitions: by user_id
Index partition 1: age 0-25
Index partition 2: age 26-50
Index partition 3: age 51+

Query "age=25": Query index partition 1 only, then fetch data
</code></pre>
<p><strong>Pros</strong>: Reads are efficient
<strong>Cons</strong>: Writes slower (update data partition and index partition), eventual consistency</p>
<p><strong>Use</strong>: DynamoDB (Global Secondary Indexes), Riak Search</p>
<h2 id="distributed-caching"><a class="header" href="#distributed-caching">Distributed Caching</a></h2>
<h3 id="cache-invalidation-strategies"><a class="header" href="#cache-invalidation-strategies">Cache Invalidation Strategies</a></h3>
<h4 id="1-time-to-live-ttl"><a class="header" href="#1-time-to-live-ttl">1. Time-to-Live (TTL)</a></h4>
<ul>
<li>Entry expires after fixed duration</li>
<li><strong>Pros</strong>: Simple, prevents stale data</li>
<li><strong>Cons</strong>: May serve stale data before TTL, cache miss on expiry</li>
</ul>
<h4 id="2-write-through"><a class="header" href="#2-write-through">2. Write-Through</a></h4>
<ul>
<li>Write to cache and database simultaneously</li>
<li><strong>Pros</strong>: Cache always consistent with database</li>
<li><strong>Cons</strong>: Higher write latency, wasted cache space for rarely-read data</li>
</ul>
<h4 id="3-write-behind-write-back"><a class="header" href="#3-write-behind-write-back">3. Write-Behind (Write-Back)</a></h4>
<ul>
<li>Write to cache, asynchronously write to database</li>
<li><strong>Pros</strong>: Low write latency</li>
<li><strong>Cons</strong>: Risk of data loss, complexity</li>
</ul>
<h4 id="4-cache-aside-lazy-loading"><a class="header" href="#4-cache-aside-lazy-loading">4. Cache-Aside (Lazy Loading)</a></h4>
<pre><code>1. Check cache
2. If miss: Read from database, write to cache, return data
3. If hit: Return data from cache
On write: Invalidate cache (or update)
</code></pre>
<ul>
<li><strong>Pros</strong>: Only caches requested data</li>
<li><strong>Cons</strong>: Cache miss penalty, potential for stale data</li>
</ul>
<h4 id="5-refresh-ahead"><a class="header" href="#5-refresh-ahead">5. Refresh-Ahead</a></h4>
<ul>
<li>Automatically refresh hot entries before expiration</li>
<li><strong>Pros</strong>: Reduces cache misses for popular items</li>
<li><strong>Cons</strong>: Difficult to predict what to refresh</li>
</ul>
<h3 id="cache-coherence"><a class="header" href="#cache-coherence">Cache Coherence</a></h3>
<p><strong>Problem</strong>: Keeping multiple cache copies consistent</p>
<h4 id="strategies-1"><a class="header" href="#strategies-1">Strategies</a></h4>
<p><strong>1. Invalidation-based</strong>:</p>
<ul>
<li>When data changes, invalidate all cached copies</li>
<li>Next access fetches fresh data</li>
<li><strong>Use</strong>: Most distributed caches (Redis, Memcached)</li>
</ul>
<p><strong>2. Update-based</strong>:</p>
<ul>
<li>When data changes, push updates to all caches</li>
<li><strong>Pros</strong>: No stale reads</li>
<li><strong>Cons</strong>: More network traffic</li>
</ul>
<p><strong>3. Lease-based</strong>:</p>
<ul>
<li>Cache entries have leases (time-limited)</li>
<li>Source can revoke leases to invalidate</li>
<li><strong>Use</strong>: Some CDNs</li>
</ul>
<p><strong>4. Version-based</strong>:</p>
<ul>
<li>Include version with cached data</li>
<li>Check version on read</li>
<li><strong>Use</strong>: HTTP ETags</li>
</ul>
<h4 id="thundering-herd-problem"><a class="header" href="#thundering-herd-problem">Thundering Herd Problem</a></h4>
<p><strong>Problem</strong>: Cache expires, many requests simultaneously query database</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Request coalescing</strong>: Only one request fetches, others wait</li>
<li><strong>Probabilistic early expiration</strong>: Refresh before TTL with probability</li>
<li><strong>Lock-based</strong>: First request acquires lock, others wait or use stale data</li>
<li><strong>Sentinel values</strong>: Placeholder while refreshing</li>
</ol>
<h3 id="distributed-cache-architectures"><a class="header" href="#distributed-cache-architectures">Distributed Cache Architectures</a></h3>
<h4 id="1-client-side-caching"><a class="header" href="#1-client-side-caching">1. Client-Side Caching</a></h4>
<ul>
<li>Each client has local cache</li>
<li><strong>Pros</strong>: Lowest latency</li>
<li><strong>Cons</strong>: Coherence challenges, memory usage</li>
</ul>
<h4 id="2-server-side-caching"><a class="header" href="#2-server-side-caching">2. Server-Side Caching</a></h4>
<ul>
<li>Cache layer between clients and database</li>
<li><strong>Pros</strong>: Centralized control</li>
<li><strong>Cons</strong>: Network hop</li>
</ul>
<h4 id="3-cdn-content-delivery-network"><a class="header" href="#3-cdn-content-delivery-network">3. CDN (Content Delivery Network)</a></h4>
<ul>
<li>Geographically distributed caches</li>
<li><strong>Use</strong>: Static assets, media</li>
<li><strong>Examples</strong>: Cloudflare, Akamai, CloudFront</li>
</ul>
<h3 id="cache-replacement-policies"><a class="header" href="#cache-replacement-policies">Cache Replacement Policies</a></h3>
<ul>
<li><strong>LRU (Least Recently Used)</strong>: Evict least recently accessed</li>
<li><strong>LFU (Least Frequently Used)</strong>: Evict least frequently accessed</li>
<li><strong>FIFO (First In First Out)</strong>: Evict oldest</li>
<li><strong>Random</strong>: Evict random entry</li>
<li><strong>ARC (Adaptive Replacement Cache)</strong>: Balances recency and frequency</li>
</ul>
<h2 id="real-world-distributed-systems"><a class="header" href="#real-world-distributed-systems">Real-World Distributed Systems</a></h2>
<h3 id="google"><a class="header" href="#google">Google</a></h3>
<h4 id="bigtable"><a class="header" href="#bigtable">Bigtable</a></h4>
<ul>
<li><strong>Type</strong>: Wide-column store (column-family database)</li>
<li><strong>Architecture</strong>:
<ul>
<li>Data stored in tablets (row ranges)</li>
<li>Tablet servers serve read/write requests</li>
<li>Master assigns tablets to servers</li>
<li>GFS (Google File System) for storage</li>
<li>Chubby for coordination and master election</li>
</ul>
</li>
<li><strong>Data model</strong>: (row key, column key, timestamp) → value</li>
<li><strong>Features</strong>:
<ul>
<li>Sorted by row key</li>
<li>Strong consistency for single-row transactions</li>
<li>Atomic row operations</li>
<li>Bloom filters for efficient lookups</li>
</ul>
</li>
<li><strong>Use cases</strong>: Google Search, Maps, Gmail</li>
<li><strong>Inspired</strong>: HBase, Cassandra, Hypertable</li>
</ul>
<h4 id="spanner"><a class="header" href="#spanner">Spanner</a></h4>
<ul>
<li><strong>Type</strong>: Globally distributed SQL database</li>
<li><strong>Architecture</strong>:
<ul>
<li>Paxos groups for replication</li>
<li>TrueTime API for global consistency</li>
<li>Two-phase commit for distributed transactions</li>
</ul>
</li>
<li><strong>TrueTime</strong>:
<ul>
<li>GPS and atomic clocks in each datacenter</li>
<li>Returns time interval with guaranteed bounds</li>
<li>Enables serializable transactions globally</li>
</ul>
</li>
<li><strong>Features</strong>:
<ul>
<li>Linearizability across data centers</li>
<li>ACID transactions</li>
<li>SQL queries</li>
<li>Schema changes without downtime</li>
</ul>
</li>
<li><strong>Trade-offs</strong>:
<ul>
<li>Write latency (cross-datacenter commits)</li>
<li>Requires specialized hardware (TrueTime)</li>
</ul>
</li>
<li><strong>Use cases</strong>: Google AdWords, Play</li>
<li><strong>Inspired</strong>: CockroachDB, YugabyteDB</li>
</ul>
<h4 id="other-google-systems"><a class="header" href="#other-google-systems">Other Google Systems</a></h4>
<ul>
<li><strong>GFS/Colossus</strong>: Distributed file system</li>
<li><strong>MapReduce/Dataflow</strong>: Distributed computation</li>
<li><strong>Chubby</strong>: Distributed lock service</li>
<li><strong>Megastore</strong>: Semi-relational database (predecessor to Spanner)</li>
</ul>
<h3 id="amazon"><a class="header" href="#amazon">Amazon</a></h3>
<h4 id="dynamodb"><a class="header" href="#dynamodb">DynamoDB</a></h4>
<ul>
<li><strong>Type</strong>: Key-value and document database</li>
<li><strong>Architecture</strong>:
<ul>
<li>Consistent hashing for partitioning</li>
<li>Leaderless replication (Dynamo-style)</li>
<li>Multi-datacenter replication</li>
</ul>
</li>
<li><strong>Consistency models</strong>:
<ul>
<li>Eventually consistent reads (default)</li>
<li>Strongly consistent reads (optional)</li>
<li>Transactions (ACID for multiple items)</li>
</ul>
</li>
<li><strong>Features</strong>:
<ul>
<li>Automatic partitioning and rebalancing</li>
<li>Global tables (multi-region)</li>
<li>Streams (change data capture)</li>
<li>On-demand and provisioned capacity</li>
</ul>
</li>
<li><strong>Quorums</strong>: W=2, R=2, N=3 (configurable via read consistency)</li>
<li><strong>Conflict resolution</strong>: Last-write-wins (LWW) by default</li>
<li><strong>Use cases</strong>: Amazon.com, Alexa, gaming leaderboards</li>
<li><strong>Inspired</strong>: Cassandra, Riak, Voldemort</li>
</ul>
<h4 id="other-amazon-systems"><a class="header" href="#other-amazon-systems">Other Amazon Systems</a></h4>
<ul>
<li><strong>S3</strong>: Object storage (eventual consistency → strong consistency as of 2020)</li>
<li><strong>Aurora</strong>: MySQL/PostgreSQL-compatible relational database
<ul>
<li>Replicates storage across 3 AZs (6 copies)</li>
<li>Quorum: W=4, R=3, N=6</li>
</ul>
</li>
<li><strong>EBS</strong>: Block storage with replication</li>
</ul>
<h3 id="facebook-meta"><a class="header" href="#facebook-meta">Facebook (Meta)</a></h3>
<h4 id="cassandra"><a class="header" href="#cassandra">Cassandra</a></h4>
<ul>
<li><strong>Origin</strong>: Developed at Facebook, open-sourced 2008</li>
<li><strong>Type</strong>: Wide-column store</li>
<li><strong>Architecture</strong>:
<ul>
<li>Dynamo-style partitioning (consistent hashing)</li>
<li>Bigtable-style data model</li>
<li>Leaderless replication</li>
<li>Gossip protocol for cluster membership</li>
</ul>
</li>
<li><strong>Consistency levels</strong>: ONE, QUORUM, ALL (per-query tunable)</li>
<li><strong>Features</strong>:
<ul>
<li>Linear scalability</li>
<li>Multi-datacenter replication</li>
<li>Lightweight transactions (Paxos-based)</li>
<li>CQL (Cassandra Query Language)</li>
</ul>
</li>
<li><strong>Write path</strong>: MemTable → SSTable</li>
<li><strong>Read path</strong>: Bloom filters → SSTables → compaction</li>
<li><strong>Use cases</strong>: Originally for Facebook inbox search, now widely used (Netflix, Apple, Instagram)</li>
</ul>
<h4 id="tao-the-associations-and-objects"><a class="header" href="#tao-the-associations-and-objects">TAO (The Associations and Objects)</a></h4>
<ul>
<li><strong>Type</strong>: Distributed data store for social graph</li>
<li><strong>Architecture</strong>:
<ul>
<li>Graph database on top of MySQL</li>
<li>Read-optimized, heavily cached</li>
<li>Write-through cache</li>
</ul>
</li>
<li><strong>Features</strong>:
<ul>
<li>Optimized for social graph queries (friends, likes, comments)</li>
<li>Eventually consistent reads</li>
<li>Asynchronous replication across datacenters</li>
</ul>
</li>
<li><strong>Scale</strong>: Billions of nodes, trillions of edges</li>
</ul>
<h4 id="other-facebook-systems"><a class="header" href="#other-facebook-systems">Other Facebook Systems</a></h4>
<ul>
<li><strong>Haystack</strong>: Photo storage</li>
<li><strong>Memcache</strong>: Massive distributed cache layer</li>
<li><strong>RocksDB</strong>: Embedded key-value store (based on LevelDB)</li>
<li><strong>Presto</strong>: Distributed SQL query engine</li>
</ul>
<h3 id="other-notable-systems"><a class="header" href="#other-notable-systems">Other Notable Systems</a></h3>
<h4 id="apache-kafka-linkedin"><a class="header" href="#apache-kafka-linkedin">Apache Kafka (LinkedIn)</a></h4>
<ul>
<li><strong>Type</strong>: Distributed event streaming platform</li>
<li><strong>Architecture</strong>:
<ul>
<li>Topics partitioned across brokers</li>
<li>ZooKeeper for coordination (moving to KRaft)</li>
<li>Replication with leader-follower</li>
</ul>
</li>
<li><strong>Features</strong>:
<ul>
<li>High throughput (millions msgs/sec)</li>
<li>Persistent log</li>
<li>At-least-once, exactly-once semantics</li>
<li>Consumer groups for parallel processing</li>
</ul>
</li>
</ul>
<h4 id="redis"><a class="header" href="#redis">Redis</a></h4>
<ul>
<li><strong>Type</strong>: In-memory data structure store</li>
<li><strong>Features</strong>:
<ul>
<li>Replication (leader-follower)</li>
<li>Sentinel for high availability</li>
<li>Cluster mode for partitioning</li>
<li>Persistence (RDB snapshots, AOF log)</li>
<li>CRDTs support</li>
</ul>
</li>
<li><strong>Use cases</strong>: Caching, session store, leaderboards, pub/sub</li>
</ul>
<h4 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h4>
<ul>
<li><strong>Type</strong>: Distributed search and analytics</li>
<li><strong>Architecture</strong>:
<ul>
<li>Built on Lucene</li>
<li>Sharding and replication</li>
<li>Master-eligible nodes elect leader</li>
</ul>
</li>
<li><strong>Features</strong>:
<ul>
<li>Full-text search</li>
<li>Real-time indexing</li>
<li>Aggregations for analytics</li>
<li>RESTful API</li>
</ul>
</li>
</ul>
<h2 id="patterns-and-anti-patterns"><a class="header" href="#patterns-and-anti-patterns">Patterns and Anti-Patterns</a></h2>
<h3 id="distributed-system-patterns"><a class="header" href="#distributed-system-patterns">Distributed System Patterns</a></h3>
<h4 id="1-circuit-breaker"><a class="header" href="#1-circuit-breaker">1. Circuit Breaker</a></h4>
<ul>
<li><strong>Purpose</strong>: Prevent cascading failures</li>
<li><strong>How</strong>: Track failure rate, open circuit if threshold exceeded</li>
<li><strong>States</strong>: Closed (normal), Open (failing), Half-Open (testing)</li>
<li><strong>Example</strong>: Hystrix, Resilience4j</li>
</ul>
<h4 id="2-bulkhead"><a class="header" href="#2-bulkhead">2. Bulkhead</a></h4>
<ul>
<li><strong>Purpose</strong>: Isolate resources to limit blast radius</li>
<li><strong>How</strong>: Separate thread pools/connection pools per service</li>
<li><strong>Example</strong>: 100 threads total → 30 for service A, 30 for B, 40 for C</li>
</ul>
<h4 id="3-retry-with-exponential-backoff"><a class="header" href="#3-retry-with-exponential-backoff">3. Retry with Exponential Backoff</a></h4>
<ul>
<li><strong>Purpose</strong>: Handle transient failures</li>
<li><strong>How</strong>: Retry with increasing delays (1s, 2s, 4s, 8s)</li>
<li><strong>Enhancement</strong>: Add jitter to prevent thundering herd</li>
</ul>
<h4 id="4-idempotency"><a class="header" href="#4-idempotency">4. Idempotency</a></h4>
<ul>
<li><strong>Purpose</strong>: Safe retry of operations</li>
<li><strong>How</strong>: Same request produces same result, no side effects on retry</li>
<li><strong>Implementation</strong>: Idempotency keys, deterministic UUIDs</li>
</ul>
<h4 id="5-timeout"><a class="header" href="#5-timeout">5. Timeout</a></h4>
<ul>
<li><strong>Purpose</strong>: Prevent indefinite waiting</li>
<li><strong>How</strong>: Set maximum wait time for operations</li>
<li><strong>Challenge</strong>: Choosing right timeout value</li>
</ul>
<h4 id="6-rate-limiting--throttling"><a class="header" href="#6-rate-limiting--throttling">6. Rate Limiting / Throttling</a></h4>
<ul>
<li><strong>Purpose</strong>: Protect system from overload</li>
<li><strong>Algorithms</strong>: Token bucket, leaky bucket, fixed/sliding window</li>
<li><strong>Example</strong>: Max 100 requests/second per user</li>
</ul>
<h4 id="7-load-shedding"><a class="header" href="#7-load-shedding">7. Load Shedding</a></h4>
<ul>
<li><strong>Purpose</strong>: Gracefully degrade under extreme load</li>
<li><strong>How</strong>: Reject low-priority requests, serve high-priority only</li>
<li><strong>Example</strong>: Serve logged-in users, reject anonymous</li>
</ul>
<h4 id="8-health-checks"><a class="header" href="#8-health-checks">8. Health Checks</a></h4>
<ul>
<li><strong>Purpose</strong>: Detect unhealthy instances</li>
<li><strong>Types</strong>: Liveness (is it running?), Readiness (can it serve traffic?)</li>
<li><strong>Implementation</strong>: HTTP endpoint (/health), regular probing</li>
</ul>
<h4 id="9-service-discovery"><a class="header" href="#9-service-discovery">9. Service Discovery</a></h4>
<ul>
<li><strong>Purpose</strong>: Dynamic service location</li>
<li><strong>Patterns</strong>: Client-side (Eureka), Server-side (Consul), DNS-based</li>
<li><strong>Example</strong>: Service registers with Consul, client queries Consul</li>
</ul>
<h4 id="10-api-gateway"><a class="header" href="#10-api-gateway">10. API Gateway</a></h4>
<ul>
<li><strong>Purpose</strong>: Single entry point for clients</li>
<li><strong>Functions</strong>: Routing, authentication, rate limiting, load balancing</li>
<li><strong>Example</strong>: Kong, Ambassador, AWS API Gateway</li>
</ul>
<h4 id="11-sidecar-pattern"><a class="header" href="#11-sidecar-pattern">11. Sidecar Pattern</a></h4>
<ul>
<li><strong>Purpose</strong>: Augment service with additional capabilities</li>
<li><strong>How</strong>: Deploy helper container alongside main container</li>
<li><strong>Use cases</strong>: Logging, monitoring, service mesh proxy (Envoy)</li>
</ul>
<h4 id="12-strangler-fig-pattern"><a class="header" href="#12-strangler-fig-pattern">12. Strangler Fig Pattern</a></h4>
<ul>
<li><strong>Purpose</strong>: Incrementally migrate legacy system</li>
<li><strong>How</strong>: Route requests to new system, fall back to legacy</li>
<li><strong>Process</strong>: Gradually replace pieces until legacy retired</li>
</ul>
<h3 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-Patterns</a></h3>
<h4 id="1-distributed-monolith"><a class="header" href="#1-distributed-monolith">1. Distributed Monolith</a></h4>
<ul>
<li><strong>Problem</strong>: Microservices with tight coupling</li>
<li><strong>Symptoms</strong>: Must deploy all services together, shared database</li>
<li><strong>Solution</strong>: Proper service boundaries, loose coupling</li>
</ul>
<h4 id="2-chatty-services"><a class="header" href="#2-chatty-services">2. Chatty Services</a></h4>
<ul>
<li><strong>Problem</strong>: Excessive inter-service communication</li>
<li><strong>Symptoms</strong>: N+1 queries, high latency, network saturation</li>
<li><strong>Solution</strong>: Batch requests, caching, coarser-grained APIs</li>
</ul>
<h4 id="3-mega-service"><a class="header" href="#3-mega-service">3. Mega Service</a></h4>
<ul>
<li><strong>Problem</strong>: Service doing too much</li>
<li><strong>Symptoms</strong>: Hard to scale, deploy, understand</li>
<li><strong>Solution</strong>: Split into smaller services with clear boundaries</li>
</ul>
<h4 id="4-shared-database"><a class="header" href="#4-shared-database">4. Shared Database</a></h4>
<ul>
<li><strong>Problem</strong>: Multiple services accessing same database</li>
<li><strong>Symptoms</strong>: Tight coupling, hard to evolve schema</li>
<li><strong>Solution</strong>: Database per service, async replication</li>
</ul>
<h4 id="5-ignoring-network-failures"><a class="header" href="#5-ignoring-network-failures">5. Ignoring Network Failures</a></h4>
<ul>
<li><strong>Problem</strong>: Not handling network issues</li>
<li><strong>Symptoms</strong>: Hangs, cascading failures, poor UX</li>
<li><strong>Solution</strong>: Timeouts, retries, circuit breakers, fallbacks</li>
</ul>
<h4 id="6-synchronous-coupling"><a class="header" href="#6-synchronous-coupling">6. Synchronous Coupling</a></h4>
<ul>
<li><strong>Problem</strong>: Over-reliance on synchronous calls</li>
<li><strong>Symptoms</strong>: Tight coupling, cascading failures, high latency</li>
<li><strong>Solution</strong>: Async messaging, event-driven architecture</li>
</ul>
<h4 id="7-missing-observability"><a class="header" href="#7-missing-observability">7. Missing Observability</a></h4>
<ul>
<li><strong>Problem</strong>: Can’t understand system behavior</li>
<li><strong>Symptoms</strong>: Hard to debug, slow to detect issues</li>
<li><strong>Solution</strong>: Logging, metrics, distributed tracing</li>
</ul>
<h4 id="8-no-idempotency"><a class="header" href="#8-no-idempotency">8. No Idempotency</a></h4>
<ul>
<li><strong>Problem</strong>: Retries cause duplicate side effects</li>
<li><strong>Symptoms</strong>: Double charges, duplicate records</li>
<li><strong>Solution</strong>: Idempotency keys, idempotent operations</li>
</ul>
<h4 id="9-single-point-of-failure"><a class="header" href="#9-single-point-of-failure">9. Single Point of Failure</a></h4>
<ul>
<li><strong>Problem</strong>: One component failure brings down entire system</li>
<li><strong>Symptoms</strong>: System outages from single failure</li>
<li><strong>Solution</strong>: Redundancy, replication, failover</li>
</ul>
<h4 id="10-ignoring-cap-theorem"><a class="header" href="#10-ignoring-cap-theorem">10. Ignoring CAP Theorem</a></h4>
<ul>
<li><strong>Problem</strong>: Expecting strong consistency AND high availability during partitions</li>
<li><strong>Symptoms</strong>: Surprised by eventual consistency, data loss</li>
<li><strong>Solution</strong>: Understand trade-offs, choose appropriate model</li>
</ul>
<h4 id="11-premature-optimization"><a class="header" href="#11-premature-optimization">11. Premature Optimization</a></h4>
<ul>
<li><strong>Problem</strong>: Over-engineering for scale not yet needed</li>
<li><strong>Symptoms</strong>: Complex architecture, high costs, slow development</li>
<li><strong>Solution</strong>: Start simple, scale when needed</li>
</ul>
<h4 id="12-death-by-a-thousand-microservices"><a class="header" href="#12-death-by-a-thousand-microservices">12. Death by a Thousand Microservices</a></h4>
<ul>
<li><strong>Problem</strong>: Too many small services</li>
<li><strong>Symptoms</strong>: High operational overhead, complex deployments, hard to trace</li>
<li><strong>Solution</strong>: Right-size services, group related functionality</li>
</ul>
<h2 id="service-mesh"><a class="header" href="#service-mesh">Service Mesh</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<p><strong>Service mesh</strong>: Infrastructure layer for service-to-service communication, handling cross-cutting concerns.</p>
<h4 id="core-capabilities"><a class="header" href="#core-capabilities">Core Capabilities</a></h4>
<ol>
<li><strong>Traffic Management</strong>: Load balancing, routing, failover</li>
<li><strong>Security</strong>: mTLS, authentication, authorization</li>
<li><strong>Observability</strong>: Metrics, logs, traces</li>
<li><strong>Resilience</strong>: Retries, timeouts, circuit breakers</li>
</ol>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<h4 id="data-plane"><a class="header" href="#data-plane">Data Plane</a></h4>
<ul>
<li><strong>Sidecar proxies</strong>: Deployed alongside each service instance</li>
<li><strong>Intercept traffic</strong>: All service communication flows through proxy</li>
<li><strong>Popular proxies</strong>: Envoy, Linkerd-proxy, NGINX</li>
</ul>
<h4 id="control-plane"><a class="header" href="#control-plane">Control Plane</a></h4>
<ul>
<li><strong>Configuration</strong>: Push config to data plane proxies</li>
<li><strong>Service discovery</strong>: Track service instances</li>
<li><strong>Certificate management</strong>: Issue and rotate certificates</li>
<li><strong>Telemetry aggregation</strong>: Collect metrics and traces</li>
</ul>
<h3 id="popular-service-meshes"><a class="header" href="#popular-service-meshes">Popular Service Meshes</a></h3>
<h4 id="istio"><a class="header" href="#istio">Istio</a></h4>
<ul>
<li><strong>Data plane</strong>: Envoy proxy</li>
<li><strong>Control plane</strong>: istiod (unified control plane)</li>
<li><strong>Features</strong>:
<ul>
<li>Rich traffic management (canary, A/B testing)</li>
<li>Strong security (mutual TLS by default)</li>
<li>Extensive observability</li>
<li>Multi-cluster support</li>
</ul>
</li>
<li><strong>Complexity</strong>: Feature-rich but complex to operate</li>
<li><strong>Use cases</strong>: Large enterprises, complex traffic patterns</li>
</ul>
<h4 id="linkerd"><a class="header" href="#linkerd">Linkerd</a></h4>
<ul>
<li><strong>Data plane</strong>: Custom Rust-based proxy (linkerd2-proxy)</li>
<li><strong>Control plane</strong>: Simplified architecture</li>
<li><strong>Features</strong>:
<ul>
<li>Lightweight and fast</li>
<li>Automatic mTLS</li>
<li>Service profiles for per-route metrics</li>
<li>Multi-cluster support</li>
</ul>
</li>
<li><strong>Simplicity</strong>: Easier to adopt and operate than Istio</li>
<li><strong>Use cases</strong>: Teams wanting simplicity with core features</li>
</ul>
<h4 id="consul-connect"><a class="header" href="#consul-connect">Consul Connect</a></h4>
<ul>
<li><strong>Data plane</strong>: Envoy or built-in proxy</li>
<li><strong>Control plane</strong>: HashiCorp Consul</li>
<li><strong>Features</strong>:
<ul>
<li>Integrated service discovery</li>
<li>Multi-datacenter support</li>
<li>Intention-based security</li>
<li>Works with VMs and Kubernetes</li>
</ul>
</li>
<li><strong>Use cases</strong>: Hybrid cloud, VM + container environments</li>
</ul>
<h3 id="traffic-management-patterns"><a class="header" href="#traffic-management-patterns">Traffic Management Patterns</a></h3>
<h4 id="canary-deployments"><a class="header" href="#canary-deployments">Canary Deployments</a></h4>
<pre><code>Traffic split:
- 95% to v1 (stable)
- 5% to v2 (canary)

Monitor metrics, gradually increase v2 traffic
</code></pre>
<h4 id="blue-green-deployments"><a class="header" href="#blue-green-deployments">Blue-Green Deployments</a></h4>
<pre><code>- Blue: Current production version
- Green: New version
- Switch traffic instantly: 100% Blue → 100% Green
- Quick rollback if issues
</code></pre>
<h4 id="ab-testing"><a class="header" href="#ab-testing">A/B Testing</a></h4>
<pre><code>Route based on user attributes:
- Premium users → v2 (new features)
- Regular users → v1 (stable)
</code></pre>
<h4 id="traffic-mirroring-shadowing"><a class="header" href="#traffic-mirroring-shadowing">Traffic Mirroring (Shadowing)</a></h4>
<pre><code>Send production traffic to:
- Primary: v1 (serves responses)
- Shadow: v2 (responses discarded)

Test v2 with real traffic, no user impact
</code></pre>
<h3 id="security-features"><a class="header" href="#security-features">Security Features</a></h3>
<h4 id="mutual-tls-mtls"><a class="header" href="#mutual-tls-mtls">Mutual TLS (mTLS)</a></h4>
<ul>
<li><strong>Automatic</strong>: Service mesh handles certificate issuance and rotation</li>
<li><strong>Strong identity</strong>: Each service has cryptographic identity</li>
<li><strong>Encryption</strong>: All service-to-service traffic encrypted</li>
<li><strong>Zero-trust</strong>: Verify identity on every request</li>
</ul>
<h4 id="authorization-policies"><a class="header" href="#authorization-policies">Authorization Policies</a></h4>
<pre><code>Example (Istio):
- Allow service A to call service B on /api/data
- Deny all other access to service B
- Require JWT token for external traffic
</code></pre>
<h3 id="observability-integration"><a class="header" href="#observability-integration">Observability Integration</a></h3>
<p><strong>Automatic metrics</strong>:</p>
<ul>
<li>Request rate, latency (p50, p95, p99)</li>
<li>Success rate, error rate</li>
<li>Connection pools, retries</li>
</ul>
<p><strong>Distributed tracing</strong>:</p>
<ul>
<li>Automatic span creation</li>
<li>Context propagation</li>
<li>Integration with Jaeger, Zipkin</li>
</ul>
<p><strong>Topology visualization</strong>:</p>
<ul>
<li>Service dependency graphs</li>
<li>Traffic flow visualization</li>
<li>Error tracking</li>
</ul>
<h3 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Uniform traffic management across services</li>
<li>Security without application changes</li>
<li>Rich observability out of the box</li>
<li>Multi-language support</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li><strong>Complexity</strong>: Additional infrastructure to manage</li>
<li><strong>Performance</strong>: Proxy adds latency (typically 1-5ms)</li>
<li><strong>Resource overhead</strong>: Sidecar per pod increases resource usage</li>
<li><strong>Learning curve</strong>: New concepts and tools</li>
</ul>
<h2 id="message-queuing-and-stream-processing"><a class="header" href="#message-queuing-and-stream-processing">Message Queuing and Stream Processing</a></h2>
<h3 id="message-queue-patterns"><a class="header" href="#message-queue-patterns">Message Queue Patterns</a></h3>
<h4 id="point-to-point-queue"><a class="header" href="#point-to-point-queue">Point-to-Point (Queue)</a></h4>
<ul>
<li><strong>Model</strong>: One message, one consumer</li>
<li><strong>Delivery</strong>: Message removed after consumption</li>
<li><strong>Use cases</strong>: Task distribution, job queues</li>
<li><strong>Example</strong>: Worker pool processing jobs</li>
</ul>
<h4 id="publish-subscribe-topic"><a class="header" href="#publish-subscribe-topic">Publish-Subscribe (Topic)</a></h4>
<ul>
<li><strong>Model</strong>: One message, multiple consumers</li>
<li><strong>Delivery</strong>: All subscribers receive copy</li>
<li><strong>Use cases</strong>: Event broadcasting, notifications</li>
<li><strong>Example</strong>: Order placed → notify inventory, shipping, analytics</li>
</ul>
<h4 id="request-reply"><a class="header" href="#request-reply">Request-Reply</a></h4>
<ul>
<li><strong>Model</strong>: Synchronous-like communication over async messaging</li>
<li><strong>How</strong>: Sender includes reply queue, waits for response</li>
<li><strong>Use cases</strong>: RPC over messaging, distributed API calls</li>
</ul>
<h3 id="message-delivery-guarantees"><a class="header" href="#message-delivery-guarantees">Message Delivery Guarantees</a></h3>
<h4 id="at-most-once"><a class="header" href="#at-most-once">At-Most-Once</a></h4>
<ul>
<li><strong>Guarantee</strong>: Message delivered 0 or 1 times</li>
<li><strong>Mechanism</strong>: Send and forget, no acknowledgment</li>
<li><strong>Use cases</strong>: Metrics, logs (where loss acceptable)</li>
<li><strong>Pros</strong>: Highest performance</li>
<li><strong>Cons</strong>: Possible message loss</li>
</ul>
<h4 id="at-least-once"><a class="header" href="#at-least-once">At-Least-Once</a></h4>
<ul>
<li><strong>Guarantee</strong>: Message delivered 1 or more times</li>
<li><strong>Mechanism</strong>: Retry until acknowledged</li>
<li><strong>Use cases</strong>: Most common, when duplicates tolerable</li>
<li><strong>Pros</strong>: No message loss</li>
<li><strong>Cons</strong>: Possible duplicates</li>
<li><strong>Requirement</strong>: Idempotent consumers</li>
</ul>
<h4 id="exactly-once"><a class="header" href="#exactly-once">Exactly-Once</a></h4>
<ul>
<li><strong>Guarantee</strong>: Message processed exactly once</li>
<li><strong>Mechanism</strong>: Deduplication + transactional processing</li>
<li><strong>Use cases</strong>: Financial transactions, critical updates</li>
<li><strong>Complexity</strong>: Hard to achieve, requires coordination</li>
<li><strong>Approaches</strong>:
<ul>
<li>Idempotency keys</li>
<li>Transactional outbox pattern</li>
<li>Two-phase commit</li>
<li>Kafka transactions (producer-consumer)</li>
</ul>
</li>
</ul>
<h3 id="apache-kafka---deep-dive"><a class="header" href="#apache-kafka---deep-dive">Apache Kafka - Deep Dive</a></h3>
<h4 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h4>
<p><strong>Topics</strong>: Logical channels for messages</p>
<ul>
<li>Partitioned for parallelism</li>
<li>Replicated for fault tolerance</li>
</ul>
<p><strong>Partitions</strong>: Ordered, immutable sequence of messages</p>
<ul>
<li>Messages appended to end (log)</li>
<li>Each message has offset (position)</li>
<li>Distributed across brokers</li>
</ul>
<p><strong>Brokers</strong>: Kafka servers storing partitions</p>
<ul>
<li>Leader: Handles reads/writes for partition</li>
<li>Followers: Replicate leader’s data</li>
</ul>
<p><strong>Producers</strong>: Write messages to topics</p>
<ul>
<li>Choose partition (round-robin, key-based, custom)</li>
<li>Batching for efficiency</li>
</ul>
<p><strong>Consumers</strong>: Read messages from topics</p>
<ul>
<li>Consumer groups for parallel processing</li>
<li>Each partition consumed by one consumer in group</li>
</ul>
<p><strong>ZooKeeper</strong> (legacy) / <strong>KRaft</strong> (new): Cluster coordination</p>
<ul>
<li>Leader election</li>
<li>Configuration management</li>
<li>KRaft removes ZooKeeper dependency</li>
</ul>
<h4 id="key-features"><a class="header" href="#key-features">Key Features</a></h4>
<p><strong>1. Persistence</strong></p>
<ul>
<li>All messages written to disk</li>
<li>Retention configurable (time or size-based)</li>
<li>Enables replay and multiple consumers</li>
</ul>
<p><strong>2. Ordering Guarantees</strong></p>
<ul>
<li>Total order within partition</li>
<li>Key-based partitioning for related messages</li>
<li>No global ordering across partitions</li>
</ul>
<p><strong>3. Scalability</strong></p>
<ul>
<li>Add brokers to scale storage and throughput</li>
<li>Add partitions to scale parallel processing</li>
<li>Consumer groups for load distribution</li>
</ul>
<p><strong>4. Fault Tolerance</strong></p>
<ul>
<li>Replication factor (typically 3)</li>
<li>In-sync replicas (ISR) for durability</li>
<li>Automatic leader election on failure</li>
</ul>
<p><strong>5. Performance</strong></p>
<ul>
<li>Sequential disk I/O (fast)</li>
<li>Zero-copy transfer to consumers</li>
<li>Batching and compression</li>
<li>Millions of messages per second</li>
</ul>
<h4 id="producer-configuration"><a class="header" href="#producer-configuration">Producer Configuration</a></h4>
<p><strong>Acknowledgment levels</strong>:</p>
<ul>
<li><code>acks=0</code>: No acknowledgment (fire and forget)</li>
<li><code>acks=1</code>: Leader acknowledges (fast, some risk)</li>
<li><code>acks=all</code>: All in-sync replicas acknowledge (durable, slower)</li>
</ul>
<p><strong>Idempotent producer</strong>:</p>
<pre><code>enable.idempotence=true
- Prevents duplicate messages on retry
- Maintains ordering per partition
</code></pre>
<p><strong>Transactions</strong>:</p>
<pre><code>Atomic writes to multiple partitions
Exactly-once semantics (with transactional consumers)
</code></pre>
<h4 id="consumer-configuration"><a class="header" href="#consumer-configuration">Consumer Configuration</a></h4>
<p><strong>Offset management</strong>:</p>
<ul>
<li><code>auto.offset.reset</code>: What to do when no offset (earliest, latest)</li>
<li><code>enable.auto.commit</code>: Automatic vs manual commit</li>
<li>Manual commit provides more control</li>
</ul>
<p><strong>Consumer groups</strong>:</p>
<ul>
<li>Partition assignment strategies (range, round-robin, sticky)</li>
<li>Rebalancing when consumers added/removed</li>
</ul>
<p><strong>Exactly-once consumption</strong>:</p>
<pre><code>1. Read messages
2. Process messages
3. Save results + commit offsets in transaction
</code></pre>
<h4 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h4>
<p><strong>1. Event Sourcing</strong>: Kafka as event store
<strong>2. Stream Processing</strong>: Kafka Streams, ksqlDB
<strong>3. Log Aggregation</strong>: Centralized logging
<strong>4. Metrics Collection</strong>: Time-series data
<strong>5. CDC (Change Data Capture)</strong>: Database change events
<strong>6. Microservices Communication</strong>: Event-driven architecture</p>
<h3 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h3>
<h4 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h4>
<p><strong>1. Flexible Routing</strong></p>
<ul>
<li>Direct exchange: Route by routing key</li>
<li>Fanout exchange: Broadcast to all queues</li>
<li>Topic exchange: Pattern matching (e.g., <code>orders.*.created</code>)</li>
<li>Headers exchange: Route by message headers</li>
</ul>
<p><strong>2. Message Priority</strong>: Prioritize urgent messages</p>
<p><strong>3. Dead Letter Queues</strong>: Failed messages routed to DLQ</p>
<p><strong>4. Message TTL</strong>: Automatic expiration</p>
<p><strong>5. Federation</strong>: Connect multiple RabbitMQ clusters</p>
<h4 id="vs-kafka"><a class="header" href="#vs-kafka">vs Kafka</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Kafka</th><th>RabbitMQ</th></tr>
</thead>
<tbody>
<tr><td><strong>Model</strong></td><td>Log-based, persistent</td><td>Traditional message queue</td></tr>
<tr><td><strong>Throughput</strong></td><td>Very high (millions/sec)</td><td>High (tens of thousands/sec)</td></tr>
<tr><td><strong>Retention</strong></td><td>Long-term (days/weeks)</td><td>Short-term (until consumed)</td></tr>
<tr><td><strong>Ordering</strong></td><td>Per-partition</td><td>Per-queue (with single consumer)</td></tr>
<tr><td><strong>Replay</strong></td><td>Yes (messages persisted)</td><td>No (consumed messages deleted)</td></tr>
<tr><td><strong>Use case</strong></td><td>Event streaming, logs, analytics</td><td>Task queues, RPC, complex routing</td></tr>
</tbody>
</table>
</div>
<h3 id="stream-processing"><a class="header" href="#stream-processing">Stream Processing</a></h3>
<h4 id="apache-kafka-streams"><a class="header" href="#apache-kafka-streams">Apache Kafka Streams</a></h4>
<p><strong>Library</strong>: Embedded in your application (no separate cluster)</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Stateful processing (joins, aggregations, windowing)</li>
<li>Exactly-once semantics</li>
<li>Interactive queries (query local state)</li>
<li>Fault-tolerant state stores (RocksDB)</li>
</ul>
<p><strong>Example use cases</strong>:</p>
<ul>
<li>Real-time analytics</li>
<li>Fraud detection</li>
<li>Anomaly detection</li>
<li>Stream enrichment</li>
</ul>
<h4 id="apache-flink"><a class="header" href="#apache-flink">Apache Flink</a></h4>
<p><strong>Framework</strong>: Separate cluster for stream processing</p>
<p><strong>Features</strong>:</p>
<ul>
<li>True streaming (not micro-batching)</li>
<li>Event time processing (handle late data)</li>
<li>Exactly-once state consistency</li>
<li>Complex event processing (CEP)</li>
<li>SQL support</li>
</ul>
<p><strong>Advantages over Spark Streaming</strong>:</p>
<ul>
<li>Lower latency (milliseconds vs seconds)</li>
<li>Better for event-time processing</li>
<li>Native streaming (not batching)</li>
</ul>
<h4 id="apache-spark-streaming"><a class="header" href="#apache-spark-streaming">Apache Spark Streaming</a></h4>
<p><strong>Model</strong>: Micro-batching (Structured Streaming)</p>
<p><strong>Features</strong>:</p>
<ul>
<li>Unified batch and streaming</li>
<li>Integration with Spark ecosystem (MLlib, SQL)</li>
<li>Scalable and fault-tolerant</li>
</ul>
<p><strong>Use cases</strong>:</p>
<ul>
<li>ETL pipelines</li>
<li>Real-time analytics</li>
<li>ML model serving</li>
</ul>
<h2 id="cloud-native-patterns"><a class="header" href="#cloud-native-patterns">Cloud-Native Patterns</a></h2>
<h3 id="twelve-factor-app-principles"><a class="header" href="#twelve-factor-app-principles">Twelve-Factor App Principles</a></h3>
<ol>
<li><strong>Codebase</strong>: One codebase tracked in version control, many deploys</li>
<li><strong>Dependencies</strong>: Explicitly declare and isolate dependencies</li>
<li><strong>Config</strong>: Store config in environment variables</li>
<li><strong>Backing Services</strong>: Treat backing services as attached resources</li>
<li><strong>Build, Release, Run</strong>: Strictly separate build and run stages</li>
<li><strong>Processes</strong>: Execute app as one or more stateless processes</li>
<li><strong>Port Binding</strong>: Export services via port binding</li>
<li><strong>Concurrency</strong>: Scale out via the process model</li>
<li><strong>Disposability</strong>: Maximize robustness with fast startup and graceful shutdown</li>
<li><strong>Dev/Prod Parity</strong>: Keep development, staging, and production similar</li>
<li><strong>Logs</strong>: Treat logs as event streams</li>
<li><strong>Admin Processes</strong>: Run admin/management tasks as one-off processes</li>
</ol>
<h3 id="container-orchestration-with-kubernetes"><a class="header" href="#container-orchestration-with-kubernetes">Container Orchestration with Kubernetes</a></h3>
<h4 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h4>
<p><strong>Pod</strong>: Smallest deployable unit</p>
<ul>
<li>One or more containers</li>
<li>Shared network namespace</li>
<li>Shared storage volumes</li>
<li>Co-located, co-scheduled</li>
</ul>
<p><strong>ReplicaSet</strong>: Maintains desired number of pod replicas</p>
<ul>
<li>Self-healing (replaces failed pods)</li>
<li>Scaling (horizontal pod autoscaler)</li>
</ul>
<p><strong>Deployment</strong>: Declarative updates for pods</p>
<ul>
<li>Rolling updates</li>
<li>Rollback capability</li>
<li>Version history</li>
</ul>
<p><strong>Service</strong>: Stable network endpoint for pods</p>
<ul>
<li>Load balancing across pod replicas</li>
<li>Service discovery (DNS)</li>
<li>Types: ClusterIP, NodePort, LoadBalancer</li>
</ul>
<p><strong>ConfigMap</strong>: Configuration data</p>
<ul>
<li>Decoupled from container images</li>
<li>Injected as environment variables or volumes</li>
</ul>
<p><strong>Secret</strong>: Sensitive data (passwords, tokens)</p>
<ul>
<li>Base64 encoded</li>
<li>Can be encrypted at rest</li>
<li>Mounted as volumes or env vars</li>
</ul>
<h4 id="kubernetes-patterns"><a class="header" href="#kubernetes-patterns">Kubernetes Patterns</a></h4>
<h5 id="1-sidecar-pattern"><a class="header" href="#1-sidecar-pattern">1. Sidecar Pattern</a></h5>
<pre><code>Pod:
- Main container: Application
- Sidecar: Log collector, metrics exporter, proxy
</code></pre>
<p><strong>Examples</strong>: Istio proxy, Fluentd log shipper, Consul agent</p>
<h5 id="2-ambassador-pattern"><a class="header" href="#2-ambassador-pattern">2. Ambassador Pattern</a></h5>
<pre><code>Sidecar acts as proxy for external services
- Main container: Connects to localhost
- Ambassador: Handles connection pooling, retry logic, circuit breaking
</code></pre>
<h5 id="3-adapter-pattern"><a class="header" href="#3-adapter-pattern">3. Adapter Pattern</a></h5>
<pre><code>Sidecar standardizes and normalizes output
- Main container: Legacy app with custom log format
- Adapter: Converts logs to standard format
</code></pre>
<h5 id="4-init-container"><a class="header" href="#4-init-container">4. Init Container</a></h5>
<pre><code>Runs before main containers
- Setup tasks (download files, wait for dependencies)
- Security (set permissions, scan for vulnerabilities)
</code></pre>
<h5 id="5-jobs-and-cronjobs"><a class="header" href="#5-jobs-and-cronjobs">5. Jobs and CronJobs</a></h5>
<pre><code>Job: Run to completion (batch processing)
CronJob: Scheduled execution (backups, reports)
</code></pre>
<h4 id="scaling-patterns"><a class="header" href="#scaling-patterns">Scaling Patterns</a></h4>
<p><strong>Horizontal Pod Autoscaler (HPA)</strong>:</p>
<ul>
<li>Scale based on CPU, memory, or custom metrics</li>
<li>Min/max replica bounds</li>
</ul>
<pre><code>If CPU &gt; 80%: Add pods
If CPU &lt; 20%: Remove pods
</code></pre>
<p><strong>Vertical Pod Autoscaler (VPA)</strong>:</p>
<ul>
<li>Adjust resource requests/limits</li>
<li>Rightsizing for efficiency</li>
</ul>
<p><strong>Cluster Autoscaler</strong>:</p>
<ul>
<li>Add/remove nodes based on pod resource requests</li>
<li>Integrates with cloud providers (AWS, GCP, Azure)</li>
</ul>
<h4 id="advanced-scheduling"><a class="header" href="#advanced-scheduling">Advanced Scheduling</a></h4>
<p><strong>Node Affinity</strong>: Schedule pods on specific nodes</p>
<pre><code>Example: GPU workloads on GPU nodes
</code></pre>
<p><strong>Pod Affinity/Anti-Affinity</strong>: Co-locate or separate pods</p>
<pre><code>Anti-affinity: Spread replicas across availability zones
Affinity: Place cache pods near compute pods
</code></pre>
<p><strong>Taints and Tolerations</strong>: Prevent pods from scheduling on certain nodes</p>
<pre><code>Taint node for dedicated workloads
Only pods with matching toleration can schedule
</code></pre>
<h2 id="security-in-distributed-systems"><a class="header" href="#security-in-distributed-systems">Security in Distributed Systems</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<h4 id="mutual-tls-mtls-1"><a class="header" href="#mutual-tls-mtls-1">Mutual TLS (mTLS)</a></h4>
<ul>
<li>Both client and server present certificates</li>
<li>Cryptographic identity verification</li>
<li>Prevents impersonation</li>
<li><strong>Implementation</strong>: Service mesh, application-level</li>
</ul>
<h4 id="oauth-20--openid-connect"><a class="header" href="#oauth-20--openid-connect">OAuth 2.0 / OpenID Connect</a></h4>
<ul>
<li><strong>OAuth 2.0</strong>: Authorization framework</li>
<li><strong>OpenID Connect</strong>: Authentication layer on OAuth 2.0</li>
<li><strong>Flow</strong>: Client → Authorization Server → Resource Server</li>
<li><strong>Tokens</strong>: Access tokens, refresh tokens, ID tokens (JWT)</li>
<li><strong>Use cases</strong>: User authentication, API authorization</li>
</ul>
<h4 id="json-web-tokens-jwt"><a class="header" href="#json-web-tokens-jwt">JSON Web Tokens (JWT)</a></h4>
<ul>
<li><strong>Structure</strong>: Header.Payload.Signature</li>
<li><strong>Stateless</strong>: No server-side session storage</li>
<li><strong>Claims</strong>: User info, permissions, expiration</li>
<li><strong>Verification</strong>: Signature validates authenticity</li>
<li><strong>Challenges</strong>: Token revocation (use short expiration + refresh tokens)</li>
</ul>
<h3 id="authorization"><a class="header" href="#authorization">Authorization</a></h3>
<h4 id="role-based-access-control-rbac"><a class="header" href="#role-based-access-control-rbac">Role-Based Access Control (RBAC)</a></h4>
<ul>
<li>Users assigned to roles</li>
<li>Roles have permissions</li>
<li>Check user’s roles for access decision</li>
<li><strong>Example</strong>: Admin, Editor, Viewer</li>
</ul>
<h4 id="attribute-based-access-control-abac"><a class="header" href="#attribute-based-access-control-abac">Attribute-Based Access Control (ABAC)</a></h4>
<ul>
<li>Policies based on attributes (user, resource, environment)</li>
<li>More flexible than RBAC</li>
<li><strong>Example</strong>: “Allow if user.department == resource.department AND time.hour &gt;= 9 AND time.hour &lt;= 17”</li>
</ul>
<h4 id="policy-engines"><a class="header" href="#policy-engines">Policy Engines</a></h4>
<ul>
<li><strong>Open Policy Agent (OPA)</strong>: General-purpose policy engine
<ul>
<li>Rego policy language</li>
<li>Decoupled authorization</li>
<li>Used in Kubernetes, microservices</li>
</ul>
</li>
<li><strong>Casbin</strong>: Authorization library
<ul>
<li>Multiple models (ACL, RBAC, ABAC)</li>
<li>Multiple languages</li>
</ul>
</li>
</ul>
<h3 id="data-security"><a class="header" href="#data-security">Data Security</a></h3>
<h4 id="encryption-at-rest"><a class="header" href="#encryption-at-rest">Encryption at Rest</a></h4>
<ul>
<li>Encrypt data stored on disk</li>
<li><strong>Methods</strong>: Full-disk encryption, database-level encryption, application-level</li>
<li><strong>Key management</strong>: KMS (AWS KMS, Google Cloud KMS, Azure Key Vault)</li>
</ul>
<h4 id="encryption-in-transit"><a class="header" href="#encryption-in-transit">Encryption in Transit</a></h4>
<ul>
<li>TLS/SSL for network communication</li>
<li>Certificate management (Let’s Encrypt, cert-manager)</li>
<li>Perfect Forward Secrecy (PFS)</li>
</ul>
<h4 id="secrets-management"><a class="header" href="#secrets-management">Secrets Management</a></h4>
<ul>
<li><strong>HashiCorp Vault</strong>: Dynamic secrets, encryption as a service, lease management</li>
<li><strong>AWS Secrets Manager</strong>: Rotation, access control</li>
<li><strong>Kubernetes Secrets</strong>: Base64 encoding, encryption with KMS</li>
<li><strong>Sealed Secrets</strong>: Encrypted secrets in Git (GitOps)</li>
</ul>
<h3 id="network-security"><a class="header" href="#network-security">Network Security</a></h3>
<h4 id="zero-trust-architecture"><a class="header" href="#zero-trust-architecture">Zero Trust Architecture</a></h4>
<ul>
<li><strong>Principle</strong>: Never trust, always verify</li>
<li><strong>Implementation</strong>:
<ul>
<li>Verify every request (even internal)</li>
<li>Micro-segmentation</li>
<li>Least privilege access</li>
<li>Continuous monitoring</li>
</ul>
</li>
</ul>
<h4 id="network-policies-kubernetes"><a class="header" href="#network-policies-kubernetes">Network Policies (Kubernetes)</a></h4>
<ul>
<li>Control traffic flow between pods</li>
<li>Default deny, explicit allow</li>
</ul>
<pre><code>Example:
- Allow frontend pods to call backend pods on port 8080
- Deny all other traffic to backend
</code></pre>
<h4 id="api-gateway-security"><a class="header" href="#api-gateway-security">API Gateway Security</a></h4>
<ul>
<li><strong>Rate limiting</strong>: Prevent abuse</li>
<li><strong>Authentication</strong>: Verify client identity</li>
<li><strong>Authorization</strong>: Check permissions</li>
<li><strong>Input validation</strong>: Prevent injection attacks</li>
<li><strong>DDoS protection</strong>: Throttling, IP blocking</li>
</ul>
<h3 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h3>
<ol>
<li><strong>Principle of Least Privilege</strong>: Minimal permissions necessary</li>
<li><strong>Defense in Depth</strong>: Multiple layers of security</li>
<li><strong>Secure by Default</strong>: Security enabled out of the box</li>
<li><strong>Immutable Infrastructure</strong>: Replace, don’t patch</li>
<li><strong>Audit Logging</strong>: Track all access and changes</li>
<li><strong>Vulnerability Scanning</strong>: Regular image and dependency scans</li>
<li><strong>Secret Rotation</strong>: Regularly rotate credentials</li>
<li><strong>Network Segmentation</strong>: Isolate services and data</li>
<li><strong>Input Validation</strong>: Sanitize all inputs</li>
<li><strong>Security Testing</strong>: Penetration testing, chaos engineering</li>
</ol>
<h2 id="disaster-recovery-and-multi-region"><a class="header" href="#disaster-recovery-and-multi-region">Disaster Recovery and Multi-Region</a></h2>
<h3 id="recovery-objectives"><a class="header" href="#recovery-objectives">Recovery Objectives</a></h3>
<p><strong>RTO (Recovery Time Objective)</strong>: Maximum acceptable downtime</p>
<ul>
<li>Example: RTO = 1 hour (system must be restored within 1 hour)</li>
</ul>
<p><strong>RPO (Recovery Point Objective)</strong>: Maximum acceptable data loss</p>
<ul>
<li>Example: RPO = 15 minutes (can lose max 15 minutes of data)</li>
</ul>
<h3 id="multi-region-architectures"><a class="header" href="#multi-region-architectures">Multi-Region Architectures</a></h3>
<h4 id="active-passive-disaster-recovery"><a class="header" href="#active-passive-disaster-recovery">Active-Passive (Disaster Recovery)</a></h4>
<p><strong>Setup</strong>:</p>
<ul>
<li><strong>Active region</strong>: Serves all traffic</li>
<li><strong>Passive region</strong>: Standby, ready to take over</li>
<li>Data replication: Active → Passive</li>
</ul>
<p><strong>Failover</strong>:</p>
<ol>
<li>Detect failure in active region</li>
<li>Promote passive region to active</li>
<li>Redirect traffic (DNS update, load balancer)</li>
<li>RPO: Replication lag (seconds to minutes)</li>
<li>RTO: Failover time (minutes to hours)</li>
</ol>
<p><strong>Use cases</strong>: Cost-conscious DR, acceptable downtime</p>
<h4 id="active-active-multi-region"><a class="header" href="#active-active-multi-region">Active-Active (Multi-Region)</a></h4>
<p><strong>Setup</strong>:</p>
<ul>
<li>Multiple regions serve traffic simultaneously</li>
<li>Data replicated between regions</li>
<li>Global load balancer distributes traffic</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Lower latency (users routed to nearest region)</li>
<li>Higher availability (region failure transparent)</li>
<li>Better resource utilization</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Data consistency (cross-region writes)</li>
<li>Conflict resolution</li>
<li>Increased cost</li>
</ul>
<p><strong>Patterns</strong>:</p>
<p><strong>1. Read-Local, Write-Global</strong>:</p>
<ul>
<li>Reads from nearest region</li>
<li>Writes to primary region, replicated globally</li>
<li><strong>Trade-off</strong>: Write latency, but consistent</li>
</ul>
<p><strong>2. Write-Local, Async Replication</strong>:</p>
<ul>
<li>Writes to local region, async replication</li>
<li><strong>Trade-off</strong>: Low latency, eventual consistency, conflicts</li>
</ul>
<p><strong>3. Multi-Master with CRDT</strong>:</p>
<ul>
<li>Writes to any region</li>
<li>CRDTs ensure convergence</li>
<li><strong>Trade-off</strong>: Complex, but no conflicts</li>
</ul>
<h3 id="database-replication-strategies"><a class="header" href="#database-replication-strategies">Database Replication Strategies</a></h3>
<h4 id="cross-region-replication"><a class="header" href="#cross-region-replication">Cross-Region Replication</a></h4>
<p><strong>Synchronous</strong>:</p>
<ul>
<li>Wait for remote region acknowledgment</li>
<li><strong>Pros</strong>: No data loss (RPO = 0)</li>
<li><strong>Cons</strong>: High latency (limited by speed of light)</li>
</ul>
<p><strong>Asynchronous</strong>:</p>
<ul>
<li>Replicate in background</li>
<li><strong>Pros</strong>: Low latency</li>
<li><strong>Cons</strong>: Data loss on failure (RPO &gt; 0)</li>
</ul>
<p><strong>Semi-synchronous</strong>:</p>
<ul>
<li>Wait for one local replica, async to remote</li>
<li><strong>Balance</strong>: Durability + performance</li>
</ul>
<h4 id="global-databases"><a class="header" href="#global-databases">Global Databases</a></h4>
<p><strong>Google Spanner</strong>:</p>
<ul>
<li>Globally distributed, strongly consistent</li>
<li>TrueTime for global ordering</li>
<li>Multi-region ACID transactions</li>
</ul>
<p><strong>CockroachDB</strong>:</p>
<ul>
<li>Distributed SQL, Spanner-inspired</li>
<li>Raft consensus per range</li>
<li>Geo-partitioning for data locality</li>
</ul>
<p><strong>AWS Aurora Global Database</strong>:</p>
<ul>
<li>Primary region + up to 5 secondary regions</li>
<li>&lt; 1 second replication lag</li>
<li>Cross-region failover</li>
</ul>
<p><strong>DynamoDB Global Tables</strong>:</p>
<ul>
<li>Multi-region, multi-master</li>
<li>Last-write-wins conflict resolution</li>
<li>Active-active replication</li>
</ul>
<h3 id="backup-strategies"><a class="header" href="#backup-strategies">Backup Strategies</a></h3>
<h4 id="backup-types"><a class="header" href="#backup-types">Backup Types</a></h4>
<p><strong>Full Backup</strong>: Complete copy of all data</p>
<ul>
<li><strong>Pros</strong>: Simple restore</li>
<li><strong>Cons</strong>: Large storage, slow</li>
</ul>
<p><strong>Incremental Backup</strong>: Only changes since last backup</p>
<ul>
<li><strong>Pros</strong>: Fast, efficient storage</li>
<li><strong>Cons</strong>: Complex restore (need full + all incrementals)</li>
</ul>
<p><strong>Differential Backup</strong>: Changes since last full backup</p>
<ul>
<li><strong>Pros</strong>: Faster restore than incremental</li>
<li><strong>Cons</strong>: Larger than incremental</li>
</ul>
<h4 id="backup-best-practices"><a class="header" href="#backup-best-practices">Backup Best Practices</a></h4>
<ol>
<li><strong>3-2-1 Rule</strong>: 3 copies, 2 different media, 1 offsite</li>
<li><strong>Automated Backups</strong>: Scheduled, no manual intervention</li>
<li><strong>Test Restores</strong>: Regularly verify backups work</li>
<li><strong>Encryption</strong>: Encrypt backups at rest and in transit</li>
<li><strong>Retention Policy</strong>: Balance cost and compliance</li>
<li><strong>Immutable Backups</strong>: Prevent ransomware deletion</li>
<li><strong>Cross-Region</strong>: Store backups in different region</li>
</ol>
<h3 id="chaos-engineering"><a class="header" href="#chaos-engineering">Chaos Engineering</a></h3>
<p><strong>Purpose</strong>: Proactively find weaknesses before they cause outages</p>
<h4 id="principles"><a class="header" href="#principles">Principles</a></h4>
<ol>
<li><strong>Define steady state</strong>: Normal behavior metrics</li>
<li><strong>Hypothesize</strong>: Predict impact of failure</li>
<li><strong>Inject failure</strong>: Controlled experiments</li>
<li><strong>Observe</strong>: Monitor impact on steady state</li>
<li><strong>Learn and improve</strong>: Fix weaknesses</li>
</ol>
<h4 id="failure-scenarios"><a class="header" href="#failure-scenarios">Failure Scenarios</a></h4>
<ul>
<li><strong>Network</strong>: Latency injection, packet loss, partition</li>
<li><strong>Compute</strong>: Kill instances, CPU/memory pressure</li>
<li><strong>Storage</strong>: Disk failures, corruption</li>
<li><strong>Dependencies</strong>: Service failures, degraded performance</li>
</ul>
<h4 id="tools"><a class="header" href="#tools">Tools</a></h4>
<ul>
<li><strong>Chaos Monkey</strong> (Netflix): Randomly kills instances</li>
<li><strong>Chaos Toolkit</strong>: Generic chaos engineering platform</li>
<li><strong>Gremlin</strong>: Chaos engineering as a service</li>
<li><strong>Litmus</strong> (Kubernetes): Chaos experiments for K8s</li>
</ul>
<h2 id="edge-computing-and-cdn"><a class="header" href="#edge-computing-and-cdn">Edge Computing and CDN</a></h2>
<h3 id="edge-computing"><a class="header" href="#edge-computing">Edge Computing</a></h3>
<p><strong>Definition</strong>: Computation and data storage closer to users/devices</p>
<h4 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h4>
<p><strong>1. Low Latency Applications</strong>:</p>
<ul>
<li>Gaming (real-time multiplayer)</li>
<li>AR/VR (motion-to-photon latency)</li>
<li>Video streaming (adaptive bitrate)</li>
</ul>
<p><strong>2. Bandwidth Optimization</strong>:</p>
<ul>
<li>Process data locally, send only results</li>
<li>IoT devices (process sensor data at edge)</li>
</ul>
<p><strong>3. Privacy and Compliance</strong>:</p>
<ul>
<li>Keep data within geographic boundaries</li>
<li>Process sensitive data locally</li>
</ul>
<p><strong>4. Offline Capability</strong>:</p>
<ul>
<li>Continue operation without cloud connectivity</li>
<li>Sync when connection restored</li>
</ul>
<h4 id="edge-architectures"><a class="header" href="#edge-architectures">Edge Architectures</a></h4>
<p><strong>1. CDN with Edge Computing</strong> (Cloudflare Workers, AWS Lambda@Edge):</p>
<ul>
<li>Run code at CDN edge locations</li>
<li>Modify requests/responses</li>
<li>A/B testing, personalization, auth</li>
</ul>
<p><strong>2. Mobile Edge Computing (MEC)</strong>:</p>
<ul>
<li>Compute at cellular network edge (5G)</li>
<li>Ultra-low latency (&lt;10ms)</li>
<li>Use cases: Autonomous vehicles, smart cities</li>
</ul>
<p><strong>3. IoT Edge</strong>:</p>
<ul>
<li>Gateways aggregate and process IoT data</li>
<li>Machine learning inference at edge</li>
<li>Examples: AWS IoT Greengrass, Azure IoT Edge</li>
</ul>
<h3 id="content-delivery-networks-cdn"><a class="header" href="#content-delivery-networks-cdn">Content Delivery Networks (CDN)</a></h3>
<h4 id="how-cdns-work"><a class="header" href="#how-cdns-work">How CDNs Work</a></h4>
<ol>
<li><strong>Origin server</strong>: Original content source</li>
<li><strong>Edge servers</strong>: Cached content near users</li>
<li><strong>Request flow</strong>:
<ul>
<li>User requests content</li>
<li>DNS routes to nearest edge server</li>
<li>Edge server serves from cache (cache hit)</li>
<li>Or fetches from origin (cache miss), caches, serves</li>
</ul>
</li>
</ol>
<h4 id="cache-strategies"><a class="header" href="#cache-strategies">Cache Strategies</a></h4>
<p><strong>1. Cache-Control Headers</strong>:</p>
<pre><code>Cache-Control: public, max-age=3600
- Public: Can be cached by CDN
- max-age: Cache for 1 hour
</code></pre>
<p><strong>2. Cache Invalidation</strong>:</p>
<ul>
<li><strong>Purge</strong>: Remove from all edge servers</li>
<li><strong>Time-based</strong>: Expire after TTL</li>
<li><strong>Version-based</strong>: Include version in URL (e.g., /app.v2.js)</li>
</ul>
<p><strong>3. Cache Key</strong>:</p>
<ul>
<li>Default: URL</li>
<li>Custom: URL + headers (User-Agent, Accept-Language)</li>
</ul>
<h4 id="cdn-features"><a class="header" href="#cdn-features">CDN Features</a></h4>
<p><strong>1. Geographic Distribution</strong>: Servers in multiple regions
<strong>2. DDoS Protection</strong>: Absorb attack traffic
<strong>3. SSL/TLS Termination</strong>: Offload encryption from origin
<strong>4. Compression</strong>: Gzip, Brotli
<strong>5. Image Optimization</strong>: Resize, format conversion (WebP)
<strong>6. Streaming</strong>: HLS, DASH for video</p>
<h4 id="popular-cdns"><a class="header" href="#popular-cdns">Popular CDNs</a></h4>
<ul>
<li><strong>Cloudflare</strong>: Global network, DDoS protection, Workers (edge compute)</li>
<li><strong>Akamai</strong>: Largest CDN, enterprise focus</li>
<li><strong>Fastly</strong>: Real-time purging, edge compute (Compute@Edge)</li>
<li><strong>AWS CloudFront</strong>: Integrated with AWS, Lambda@Edge</li>
<li><strong>Google Cloud CDN</strong>: Integrated with GCP</li>
</ul>
<h2 id="serverless-architectures"><a class="header" href="#serverless-architectures">Serverless Architectures</a></h2>
<h3 id="function-as-a-service-faas"><a class="header" href="#function-as-a-service-faas">Function as a Service (FaaS)</a></h3>
<h4 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h4>
<ol>
<li><strong>Event-driven</strong>: Functions triggered by events</li>
<li><strong>Stateless</strong>: No persistent state between invocations</li>
<li><strong>Ephemeral</strong>: Short-lived execution (seconds to minutes)</li>
<li><strong>Auto-scaling</strong>: Scale to zero, scale to thousands</li>
<li><strong>Pay-per-use</strong>: Charged for execution time, not idle time</li>
</ol>
<h4 id="popular-faas-platforms"><a class="header" href="#popular-faas-platforms">Popular FaaS Platforms</a></h4>
<p><strong>AWS Lambda</strong>:</p>
<ul>
<li>Multiple runtimes (Node.js, Python, Java, Go, .NET, Ruby)</li>
<li>15-minute max execution</li>
<li>Event sources: S3, DynamoDB, API Gateway, SQS, etc.</li>
<li>Provisioned concurrency for low latency</li>
</ul>
<p><strong>Google Cloud Functions</strong>:</p>
<ul>
<li>HTTP and event-driven</li>
<li>Auto-scaling</li>
<li>Integration with GCP services</li>
</ul>
<p><strong>Azure Functions</strong>:</p>
<ul>
<li>Multiple triggers (HTTP, timer, queue, blob)</li>
<li>Durable Functions (stateful workflows)</li>
<li>Integration with Azure services</li>
</ul>
<p><strong>Cloudflare Workers</strong>:</p>
<ul>
<li>Edge compute (runs at CDN edge)</li>
<li>V8 isolates (not containers)</li>
<li>Sub-millisecond startup</li>
<li>JavaScript/WebAssembly</li>
</ul>
<h4 id="serverless-patterns"><a class="header" href="#serverless-patterns">Serverless Patterns</a></h4>
<h5 id="1-api-backend"><a class="header" href="#1-api-backend">1. API Backend</a></h5>
<pre><code>API Gateway → Lambda → DynamoDB
- Scalable REST API
- No server management
</code></pre>
<h5 id="2-stream-processing"><a class="header" href="#2-stream-processing">2. Stream Processing</a></h5>
<pre><code>Kinesis/Kafka → Lambda → S3/Database
- Real-time data processing
- Auto-scaling with stream shards
</code></pre>
<h5 id="3-scheduled-jobs"><a class="header" href="#3-scheduled-jobs">3. Scheduled Jobs</a></h5>
<pre><code>CloudWatch Events (cron) → Lambda
- Periodic tasks (cleanup, reports)
</code></pre>
<h5 id="4-file-processing"><a class="header" href="#4-file-processing">4. File Processing</a></h5>
<pre><code>S3 upload → Lambda (resize image) → S3
- Event-driven processing
</code></pre>
<h5 id="5-webhooks"><a class="header" href="#5-webhooks">5. Webhooks</a></h5>
<pre><code>External service → API Gateway → Lambda
- Handle incoming webhooks
</code></pre>
<h3 id="serverless-databases"><a class="header" href="#serverless-databases">Serverless Databases</a></h3>
<p><strong>AWS DynamoDB</strong>:</p>
<ul>
<li>Serverless NoSQL</li>
<li>On-demand or provisioned capacity</li>
<li>Auto-scaling</li>
</ul>
<p><strong>Google Firestore</strong>:</p>
<ul>
<li>Serverless document database</li>
<li>Real-time synchronization</li>
<li>Offline support</li>
</ul>
<p><strong>Azure Cosmos DB</strong> (serverless):</p>
<ul>
<li>Multi-model database</li>
<li>Global distribution</li>
<li>Multiple consistency levels</li>
</ul>
<p><strong>FaunaDB</strong>:</p>
<ul>
<li>Serverless transactional database</li>
<li>GraphQL, FQL query languages</li>
<li>Multi-region, ACID</li>
</ul>
<h3 id="serverless-challenges"><a class="header" href="#serverless-challenges">Serverless Challenges</a></h3>
<h4 id="1-cold-starts"><a class="header" href="#1-cold-starts">1. Cold Starts</a></h4>
<ul>
<li><strong>Problem</strong>: First invocation slow (100ms-10s)</li>
<li><strong>Solutions</strong>:
<ul>
<li>Provisioned concurrency (keep warm)</li>
<li>Minimize function size</li>
<li>Use faster runtimes (Go, Rust)</li>
<li>Edge compute (Cloudflare Workers)</li>
</ul>
</li>
</ul>
<h4 id="2-statelessness"><a class="header" href="#2-statelessness">2. Statelessness</a></h4>
<ul>
<li><strong>Problem</strong>: No persistent memory between invocations</li>
<li><strong>Solutions</strong>:
<ul>
<li>External state stores (Redis, DynamoDB)</li>
<li>Step Functions for workflows</li>
<li>Durable Functions (Azure)</li>
</ul>
</li>
</ul>
<h4 id="3-vendor-lock-in"><a class="header" href="#3-vendor-lock-in">3. Vendor Lock-in</a></h4>
<ul>
<li><strong>Problem</strong>: Tied to specific cloud provider</li>
<li><strong>Solutions</strong>:
<ul>
<li>Abstraction layers (Serverless Framework)</li>
<li>Multi-cloud deployment</li>
<li>Containers (Cloud Run, Fargate)</li>
</ul>
</li>
</ul>
<h4 id="4-debugging-and-monitoring"><a class="header" href="#4-debugging-and-monitoring">4. Debugging and Monitoring</a></h4>
<ul>
<li><strong>Problem</strong>: Distributed, ephemeral environment</li>
<li><strong>Solutions</strong>:
<ul>
<li>Distributed tracing (AWS X-Ray, Datadog)</li>
<li>Structured logging</li>
<li>Local emulators (SAM, LocalStack)</li>
</ul>
</li>
</ul>
<h4 id="5-timeouts-and-limits"><a class="header" href="#5-timeouts-and-limits">5. Timeouts and Limits</a></h4>
<ul>
<li><strong>Problem</strong>: Execution time limits (e.g., 15 min for Lambda)</li>
<li><strong>Solutions</strong>:
<ul>
<li>Break into smaller functions</li>
<li>Use Step Functions for orchestration</li>
<li>Hybrid approach (long tasks on containers)</li>
</ul>
</li>
</ul>
<h3 id="serverless-vs-containers"><a class="header" href="#serverless-vs-containers">Serverless vs Containers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Serverless (FaaS)</th><th>Containers</th></tr>
</thead>
<tbody>
<tr><td><strong>Abstraction</strong></td><td>High (no infra)</td><td>Medium (manage containers)</td></tr>
<tr><td><strong>Scaling</strong></td><td>Automatic, instant</td><td>Auto-scaling with delay</td></tr>
<tr><td><strong>Cold start</strong></td><td>Yes (100ms-10s)</td><td>Minimal (if running)</td></tr>
<tr><td><strong>Cost</strong></td><td>Pay per execution</td><td>Pay for running time</td></tr>
<tr><td><strong>State</strong></td><td>Stateless</td><td>Can be stateful</td></tr>
<tr><td><strong>Execution limit</strong></td><td>15 min (Lambda)</td><td>No limit</td></tr>
<tr><td><strong>Flexibility</strong></td><td>Limited runtimes</td><td>Any language/runtime</td></tr>
<tr><td><strong>Best for</strong></td><td>Event-driven, bursty</td><td>Long-running, stateful</td></tr>
</tbody>
</table>
</div>
<h2 id="graphql-federation"><a class="header" href="#graphql-federation">GraphQL Federation</a></h2>
<h3 id="overview-2"><a class="header" href="#overview-2">Overview</a></h3>
<p><strong>GraphQL Federation</strong>: Compose multiple GraphQL services into single unified graph</p>
<h4 id="traditional-approach"><a class="header" href="#traditional-approach">Traditional Approach</a></h4>
<pre><code>Single GraphQL server
- Monolithic schema
- All resolvers in one codebase
- Doesn't scale for large teams
</code></pre>
<h4 id="federated-approach"><a class="header" href="#federated-approach">Federated Approach</a></h4>
<pre><code>Multiple GraphQL services (subgraphs)
- Each owns part of schema
- Gateway composes and routes queries
- Teams work independently
</code></pre>
<h3 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h3>
<p><strong>Subgraphs</strong>: Individual GraphQL services</p>
<ul>
<li>Own domain-specific types and fields</li>
<li>Extend types from other subgraphs</li>
<li>Independent deployment</li>
</ul>
<p><strong>Gateway</strong>: Composes and executes federated queries</p>
<ul>
<li>Schema composition</li>
<li>Query planning</li>
<li>Request routing</li>
</ul>
<h3 id="apollo-federation"><a class="header" href="#apollo-federation">Apollo Federation</a></h3>
<h4 id="key-concepts-1"><a class="header" href="#key-concepts-1">Key Concepts</a></h4>
<p><strong>1. Entities</strong>: Types shared across subgraphs</p>
<pre><code class="language-graphql"># Products subgraph
type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Float!
}

# Reviews subgraph (extends Product)
extend type Product @key(fields: "id") {
  id: ID! @external
  reviews: [Review!]!
}
</code></pre>
<p><strong>2. @key Directive</strong>: Identifies entity</p>
<ul>
<li>Tells gateway how to uniquely identify object</li>
<li>Enables cross-service joins</li>
</ul>
<p><strong>3. @external</strong>: Field defined in another subgraph</p>
<p><strong>4. @requires</strong>: Field requires other fields to resolve</p>
<p><strong>5. @provides</strong>: Field can provide additional fields</p>
<h4 id="query-planning"><a class="header" href="#query-planning">Query Planning</a></h4>
<p><strong>Example</strong>:</p>
<pre><code class="language-graphql">query {
  product(id: "123") {
    name       # Products subgraph
    price      # Products subgraph
    reviews {  # Reviews subgraph
      rating
      comment
    }
  }
}
</code></pre>
<p><strong>Execution</strong>:</p>
<ol>
<li>Gateway queries Products subgraph for product(id: “123”)</li>
<li>Returns: { id: “123”, name: “Widget”, price: 29.99, __typename: “Product” }</li>
<li>Gateway queries Reviews subgraph with Product entity reference</li>
<li>Returns reviews</li>
<li>Gateway merges results</li>
</ol>
<h3 id="schema-stitching-vs-federation"><a class="header" href="#schema-stitching-vs-federation">Schema Stitching vs Federation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Schema Stitching</th><th>Federation</th></tr>
</thead>
<tbody>
<tr><td><strong>Ownership</strong></td><td>Gateway owns schema</td><td>Subgraphs own schema</td></tr>
<tr><td><strong>Composition</strong></td><td>Manual stitching</td><td>Automatic composition</td></tr>
<tr><td><strong>Type extension</strong></td><td>Limited</td><td>Native support</td></tr>
<tr><td><strong>Performance</strong></td><td>More round trips</td><td>Optimized query plans</td></tr>
<tr><td><strong>Best for</strong></td><td>Combining 3rd party APIs</td><td>Microservices architecture</td></tr>
</tbody>
</table>
</div>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ol>
<li><strong>Team Autonomy</strong>: Teams own their subgraphs</li>
<li><strong>Independent Deployment</strong>: Deploy subgraphs separately</li>
<li><strong>Incremental Adoption</strong>: Gradually migrate to federation</li>
<li><strong>Type Safety</strong>: Shared types across services</li>
<li><strong>Unified API</strong>: Single GraphQL endpoint for clients</li>
</ol>
<h3 id="challenges-1"><a class="header" href="#challenges-1">Challenges</a></h3>
<ol>
<li><strong>Complexity</strong>: More moving parts</li>
<li><strong>Debugging</strong>: Distributed query execution</li>
<li><strong>Schema Coordination</strong>: Avoid breaking changes</li>
<li><strong>Gateway Performance</strong>: Single point of failure</li>
</ol>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Design for Failure</strong>: Assume everything will fail</li>
<li><strong>Loose Coupling</strong>: Services should be independent</li>
<li><strong>Idempotency</strong>: Make operations safe to retry</li>
<li><strong>Asynchronous Communication</strong>: Use message queues when possible</li>
<li><strong>Graceful Degradation</strong>: Partial functionality over complete failure</li>
<li><strong>Monitoring and Alerting</strong>: Comprehensive observability</li>
<li><strong>Automation</strong>: Auto-scaling, self-healing systems</li>
<li><strong>Testing</strong>: Chaos engineering, fault injection</li>
<li><strong>Documentation</strong>: Clear service contracts and APIs</li>
<li><strong>Security</strong>: Authentication, authorization, encryption</li>
<li><strong>Backward Compatibility</strong>: Versioning, graceful upgrades</li>
<li><strong>Distributed Tracing</strong>: Track requests across services</li>
<li><strong>Bulkheads</strong>: Isolate failures</li>
<li><strong>Rate Limiting</strong>: Protect from overload</li>
<li><strong>Caching</strong>: Reduce load, improve performance</li>
<li><strong>Immutable Infrastructure</strong>: Treat servers as disposable</li>
<li><strong>Infrastructure as Code</strong>: Version control infra changes</li>
<li><strong>Zero Trust Security</strong>: Never trust, always verify</li>
<li><strong>Multi-Region</strong>: Plan for regional failures</li>
<li><strong>Cost Optimization</strong>: Right-size resources, use spot instances</li>
</ol>
<h2 id="observability"><a class="header" href="#observability">Observability</a></h2>
<h3 id="the-three-pillars"><a class="header" href="#the-three-pillars">The Three Pillars</a></h3>
<h4 id="1-metrics"><a class="header" href="#1-metrics">1. Metrics</a></h4>
<ul>
<li><strong>Definition</strong>: Numeric measurements over time</li>
<li><strong>Examples</strong>: Request rate, error rate, latency, CPU usage</li>
<li><strong>Tools</strong>: Prometheus, Grafana, Datadog, CloudWatch</li>
<li><strong>Patterns</strong>: RED (Rate, Errors, Duration), USE (Utilization, Saturation, Errors)</li>
</ul>
<h4 id="2-logs"><a class="header" href="#2-logs">2. Logs</a></h4>
<ul>
<li><strong>Definition</strong>: Discrete event records</li>
<li><strong>Structure</strong>: Structured (JSON) vs unstructured (text)</li>
<li><strong>Tools</strong>: ELK Stack (Elasticsearch, Logstash, Kibana), Splunk, Loki</li>
<li><strong>Best practices</strong>: Include correlation IDs, timestamps, context</li>
</ul>
<h4 id="3-traces"><a class="header" href="#3-traces">3. Traces</a></h4>
<ul>
<li><strong>Definition</strong>: End-to-end request path through system</li>
<li><strong>Components</strong>: Spans (single operation), traces (collection of spans)</li>
<li><strong>Tools</strong>: Jaeger, Zipkin, Datadog APM, AWS X-Ray</li>
<li><strong>Context propagation</strong>: Trace ID passed in headers</li>
</ul>
<h3 id="key-metrics"><a class="header" href="#key-metrics">Key Metrics</a></h3>
<ul>
<li><strong>Latency</strong>: Time to process requests (p50, p95, p99)</li>
<li><strong>Throughput</strong>: Requests per second</li>
<li><strong>Error Rate</strong>: Failed requests percentage</li>
<li><strong>Saturation</strong>: Resource utilization (CPU, memory, disk, network)</li>
<li><strong>Availability</strong>: Uptime percentage (SLA)</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<ul>
<li>“Designing Data-Intensive Applications” by Martin Kleppmann</li>
<li>“Distributed Systems” by Maarten van Steen and Andrew S. Tanenbaum</li>
<li>“Building Microservices” by Sam Newman</li>
<li>“Release It!” by Michael Nygard</li>
<li>“Site Reliability Engineering” by Google</li>
</ul>
<h3 id="papers"><a class="header" href="#papers">Papers</a></h3>
<ul>
<li><strong>Consensus</strong>: “Paxos Made Simple” (Lamport), “In Search of an Understandable Consensus Algorithm” (Raft)</li>
<li><strong>Storage</strong>: “Bigtable: A Distributed Storage System for Structured Data” (Google), “Dynamo: Amazon’s Highly Available Key-value Store” (Amazon)</li>
<li><strong>Databases</strong>: “Spanner: Google’s Globally-Distributed Database”, “TAO: Facebook’s Distributed Data Store for the Social Graph”</li>
<li><strong>Theory</strong>: “CAP Twelve Years Later: How the Rules Have Changed” (Brewer), “Impossibility of Distributed Consensus with One Faulty Process” (FLP)</li>
<li><strong>Time</strong>: “Time, Clocks, and the Ordering of Events” (Lamport)</li>
</ul>
<h3 id="online-resources"><a class="header" href="#online-resources">Online Resources</a></h3>
<ul>
<li>AWS Architecture Blog</li>
<li>Google Cloud Architecture Center</li>
<li>Martin Fowler’s blog</li>
<li>The Morning Paper (paper summaries)</li>
<li>Papers We Love</li>
</ul>
<h2 id="common-trade-offs"><a class="header" href="#common-trade-offs">Common Trade-offs</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Trade-off</th></tr>
</thead>
<tbody>
<tr><td>Consistency vs Availability</td><td>Stronger consistency reduces availability during partitions</td></tr>
<tr><td>Latency vs Consistency</td><td>Lower latency may sacrifice consistency</td></tr>
<tr><td>Complexity vs Performance</td><td>More complex systems may be more performant but harder to operate</td></tr>
<tr><td>Cost vs Reliability</td><td>Higher reliability requires more resources (replication, redundancy)</td></tr>
<tr><td>Scalability vs Simplicity</td><td>Horizontal scaling increases complexity</td></tr>
<tr><td>Strong Consistency vs Throughput</td><td>Coordination for consistency reduces throughput</td></tr>
<tr><td>Normalization vs Denormalization</td><td>Normalized reduces storage, denormalized improves read performance</td></tr>
<tr><td>Sync vs Async</td><td>Synchronous simpler but couples services, async more complex but decouples</td></tr>
<tr><td>Monolith vs Microservices</td><td>Monolith simpler initially, microservices better for scale and teams</td></tr>
</tbody>
</table>
</div>
<hr>
<p><em>Note: Distributed systems require careful consideration of requirements, constraints, and trade-offs. There is no one-size-fits-all solution. Choose the right tool and pattern for your specific use case.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../system_design/message_queues.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../system_design/load_balancing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../system_design/message_queues.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../system_design/load_balancing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
