<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Certificates - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="x509-certificates-and-pki"><a class="header" href="#x509-certificates-and-pki">X.509 Certificates and PKI</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>X.509 certificates are digital documents that bind public keys to identities. They enable:</p>
<ul>
<li><strong>Authentication</strong>: Verify identity of servers/users</li>
<li><strong>Encryption</strong>: Establish secure connections</li>
<li><strong>Trust</strong>: Chain of trust through Certificate Authorities</li>
</ul>
<h2 id="x509-certificate-structure"><a class="header" href="#x509-certificate-structure">X.509 Certificate Structure</a></h2>
<h3 id="basic-components"><a class="header" href="#basic-components">Basic Components</a></h3>
<pre><code>Certificate:
  ├── Version (v3)
  ├── Serial Number (unique identifier)
  ├── Signature Algorithm (SHA-256 with RSA)
  ├── Issuer (who issued the certificate)
  ├── Validity Period
  │   ├── Not Before (start date)
  │   └── Not After (expiration date)
  ├── Subject (who the certificate is for)
  ├── Subject Public Key Info
  │   ├── Algorithm (RSA, ECDSA, etc.)
  │   └── Public Key (actual key data)
  ├── Extensions (v3)
  │   ├── Key Usage
  │   ├── Subject Alternative Names (SANs)
  │   ├── Basic Constraints
  │   └── Authority Key Identifier
  └── Signature (CA's signature)
</code></pre>
<h3 id="certificate-fields"><a class="header" href="#certificate-fields">Certificate Fields</a></h3>
<pre><code>Subject: CN=example.com, O=Example Inc, C=US
  CN = Common Name (domain or person name)
  O  = Organization
  OU = Organizational Unit
  C  = Country
  ST = State/Province
  L  = Locality/City

Issuer: CN=Let's Encrypt Authority, O=Let's Encrypt, C=US
  (Who signed this certificate)

Validity:
  Not Before: Jan 1 00:00:00 2024 GMT
  Not After:  Apr 1 23:59:59 2024 GMT
  (Certificate valid period)

Public Key Algorithm: RSA 2048-bit
  (Type and size of public key)

Signature Algorithm: SHA-256 with RSA
  (How CA signed the certificate)
</code></pre>
<h3 id="visual-representation"><a class="header" href="#visual-representation">Visual Representation</a></h3>
<pre><code>┌─────────────────────────────────────┐
│      X.509 Certificate              │
├─────────────────────────────────────┤
│ Version: 3                          │
│ Serial: 04:92:7f:63:ab:02:1e...     │
│                                     │
│ Issuer: CN=Let's Encrypt           │
│ Subject: CN=example.com             │
│                                     │
│ Valid: 2024-01-01 to 2024-04-01    │
│                                     │
│ Public Key: [RSA 2048-bit]         │
│   65537                             │
│   00:b8:7f:4e:91...                │
│                                     │
│ Extensions:                         │
│   - Key Usage: Digital Signature   │
│   - SANs: example.com, *.example.com│
│   - Basic Constraints: CA:FALSE    │
│                                     │
│ Signature Algorithm: sha256RSA     │
│ Signature: [CA's signature]        │
│   3a:7b:8c:9d...                   │
└─────────────────────────────────────┘
</code></pre>
<h2 id="certificate-creation"><a class="header" href="#certificate-creation">Certificate Creation</a></h2>
<h3 id="creating-a-self-signed-certificate"><a class="header" href="#creating-a-self-signed-certificate">Creating a Self-Signed Certificate</a></h3>
<h4 id="openssl-bash"><a class="header" href="#openssl-bash">OpenSSL (Bash)</a></h4>
<pre><code class="language-bash"># Generate private key and self-signed certificate in one command
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes \
  -subj "/C=US/ST=California/L=San Francisco/O=Example Inc/CN=example.com"

# Breakdown:
# -x509: Create self-signed certificate
# -newkey rsa:2048: Generate new 2048-bit RSA key
# -keyout: Output private key file
# -out: Output certificate file
# -days: Certificate validity period
# -nodes: Don't encrypt private key
# -subj: Certificate subject information

# View certificate details
openssl x509 -in cert.pem -text -noout

# Generate key and certificate separately
openssl genrsa -out key.pem 2048
openssl req -new -x509 -key key.pem -out cert.pem -days 365 \
  -subj "/CN=example.com"
</code></pre>
<h4 id="python"><a class="header" href="#python">Python</a></h4>
<pre><code class="language-python">from cryptography import x509
from cryptography.x509.oid import NameOID, ExtensionOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import datetime

# Generate private key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)

# Create subject and issuer (same for self-signed)
subject = issuer = x509.Name([
    x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
    x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "California"),
    x509.NameAttribute(NameOID.LOCALITY_NAME, "San Francisco"),
    x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Example Inc"),
    x509.NameAttribute(NameOID.COMMON_NAME, "example.com"),
])

# Build certificate
cert = x509.CertificateBuilder().subject_name(
    subject
).issuer_name(
    issuer
).public_key(
    private_key.public_key()
).serial_number(
    x509.random_serial_number()
).not_valid_before(
    datetime.datetime.utcnow()
).not_valid_after(
    datetime.datetime.utcnow() + datetime.timedelta(days=365)
).add_extension(
    x509.SubjectAlternativeName([
        x509.DNSName("example.com"),
        x509.DNSName("www.example.com"),
    ]),
    critical=False,
).sign(private_key, hashes.SHA256())

# Save certificate
with open("cert.pem", "wb") as f:
    f.write(cert.public_bytes(serialization.Encoding.PEM))

# Save private key
with open("key.pem", "wb") as f:
    f.write(private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    ))

print("Certificate created successfully!")
</code></pre>
<h3 id="creating-a-certificate-signing-request-csr"><a class="header" href="#creating-a-certificate-signing-request-csr">Creating a Certificate Signing Request (CSR)</a></h3>
<h4 id="openssl"><a class="header" href="#openssl">OpenSSL</a></h4>
<pre><code class="language-bash"># Generate private key
openssl genrsa -out server.key 2048

# Create CSR
openssl req -new -key server.key -out server.csr \
  -subj "/C=US/ST=CA/L=San Francisco/O=Example Inc/CN=example.com"

# View CSR
openssl req -in server.csr -text -noout

# Create CSR with Subject Alternative Names (using config file)
cat &gt; san.cnf &lt;&lt;-END
[req]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn
req_extensions = v3_req

[dn]
C=US
ST=CA
L=San Francisco
O=Example Inc
CN=example.com

[v3_req]
subjectAltName = @alt_names

[alt_names]
DNS.1 = example.com
DNS.2 = www.example.com
DNS.3 = *.example.com
END

openssl req -new -key server.key -out server.csr -config san.cnf

# Verify CSR
openssl req -in server.csr -noout -verify
</code></pre>
<h4 id="python-1"><a class="header" href="#python-1">Python</a></h4>
<pre><code class="language-python">from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Generate private key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)

# Build CSR
csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([
    x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
    x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "California"),
    x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Example Inc"),
    x509.NameAttribute(NameOID.COMMON_NAME, "example.com"),
])).add_extension(
    x509.SubjectAlternativeName([
        x509.DNSName("example.com"),
        x509.DNSName("www.example.com"),
        x509.DNSName("*.example.com"),
    ]),
    critical=False,
).sign(private_key, hashes.SHA256())

# Save CSR
with open("server.csr", "wb") as f:
    f.write(csr.public_bytes(serialization.Encoding.PEM))

print("CSR created successfully!")
</code></pre>
<h2 id="certificate-authorities-cas"><a class="header" href="#certificate-authorities-cas">Certificate Authorities (CAs)</a></h2>
<h3 id="ca-hierarchy"><a class="header" href="#ca-hierarchy">CA Hierarchy</a></h3>
<pre><code>┌────────────────────────────┐
│      Root CA               │
│   (Self-signed)            │
│   Trust Anchor             │
└─────────────┬──────────────┘
              │
    ┌─────────┴─────────┐
    │                   │
┌───▼──────────┐  ┌────▼───────────┐
│ Intermediate │  │ Intermediate   │
│ CA #1        │  │ CA #2          │
└───┬──────────┘  └────┬───────────┘
    │                  │
┌───▼──────┐     ┌────▼──────┐
│ End-User │     │ End-User  │
│ Cert #1  │     │ Cert #2   │
└──────────┘     └───────────┘
</code></pre>
<h3 id="trust-chain"><a class="header" href="#trust-chain">Trust Chain</a></h3>
<pre><code>End-user certificate (example.com)
  ↓ Issued by
Intermediate CA certificate
  ↓ Issued by
Root CA certificate (in browser trust store)
  ✓ Trusted
</code></pre>
<h3 id="setting-up-a-ca"><a class="header" href="#setting-up-a-ca">Setting Up a CA</a></h3>
<h4 id="create-root-ca"><a class="header" href="#create-root-ca">Create Root CA</a></h4>
<pre><code class="language-bash"># Generate Root CA private key
openssl genrsa -aes256 -out rootCA.key 4096

# Create Root CA certificate
openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 3650 \
  -out rootCA.crt \
  -subj "/C=US/ST=CA/O=Example Inc/CN=Example Root CA"

# View Root CA certificate
openssl x509 -in rootCA.crt -text -noout
</code></pre>
<h4 id="sign-certificate-with-ca"><a class="header" href="#sign-certificate-with-ca">Sign Certificate with CA</a></h4>
<pre><code class="language-bash"># You have: server.csr (from earlier)
# You have: rootCA.key and rootCA.crt

# Create extensions configuration
echo "
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = example.com
DNS.2 = www.example.com
DNS.3 = *.example.com
" &gt; server_ext.cnf

# Sign CSR with CA
openssl x509 -req -in server.csr \
  -CA rootCA.crt -CAkey rootCA.key -CAcreateserial \
  -out server.crt -days 365 -sha256 \
  -extfile server_ext.cnf -extensions v3_req

# View signed certificate
openssl x509 -in server.crt -text -noout

# Verify certificate against CA
openssl verify -CAfile rootCA.crt server.crt
</code></pre>
<h4 id="python-ca-implementation"><a class="header" href="#python-ca-implementation">Python CA Implementation</a></h4>
<pre><code class="language-python">from cryptography import x509
from cryptography.x509.oid import NameOID, ExtensionOID
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import datetime

class CertificateAuthority:
    def __init__(self):
        # Generate CA private key
        self.ca_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096,
        )

        # Create CA certificate
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Example Inc"),
            x509.NameAttribute(NameOID.COMMON_NAME, "Example Root CA"),
        ])

        self.ca_cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            self.ca_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.datetime.utcnow()
        ).not_valid_after(
            datetime.datetime.utcnow() + datetime.timedelta(days=3650)
        ).add_extension(
            x509.BasicConstraints(ca=True, path_length=None),
            critical=True,
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                key_cert_sign=True,
                crl_sign=True,
                key_encipherment=False,
                content_commitment=False,
                data_encipherment=False,
                key_agreement=False,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        ).sign(self.ca_key, hashes.SHA256())

    def issue_certificate(self, csr, validity_days=365):
        """Issue a certificate from a CSR"""
        cert = x509.CertificateBuilder().subject_name(
            csr.subject
        ).issuer_name(
            self.ca_cert.subject
        ).public_key(
            csr.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.datetime.utcnow()
        ).not_valid_after(
            datetime.datetime.utcnow() + datetime.timedelta(days=validity_days)
        ).add_extension(
            x509.BasicConstraints(ca=False, path_length=None),
            critical=True,
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                key_encipherment=True,
                key_cert_sign=False,
                crl_sign=False,
                content_commitment=False,
                data_encipherment=False,
                key_agreement=False,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )

        # Copy extensions from CSR
        for extension in csr.extensions:
            cert = cert.add_extension(extension.value, extension.critical)

        # Sign with CA key
        return cert.sign(self.ca_key, hashes.SHA256())

    def save_ca_cert(self, filename):
        with open(filename, "wb") as f:
            f.write(self.ca_cert.public_bytes(serialization.Encoding.PEM))

    def save_ca_key(self, filename, password=None):
        encryption = serialization.NoEncryption()
        if password:
            encryption = serialization.BestAvailableEncryption(password)

        with open(filename, "wb") as f:
            f.write(self.ca_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=encryption
            ))

# Usage
ca = CertificateAuthority()
ca.save_ca_cert("ca.crt")
ca.save_ca_key("ca.key", password=b"secure-password")

# Load and sign a CSR
with open("server.csr", "rb") as f:
    csr = x509.load_pem_x509_csr(f.read())

cert = ca.issue_certificate(csr, validity_days=365)

with open("server.crt", "wb") as f:
    f.write(cert.public_bytes(serialization.Encoding.PEM))

print("Certificate issued successfully!")
</code></pre>
<h2 id="certificate-chains"><a class="header" href="#certificate-chains">Certificate Chains</a></h2>
<h3 id="understanding-certificate-chains"><a class="header" href="#understanding-certificate-chains">Understanding Certificate Chains</a></h3>
<pre><code>┌─────────────────────────────────┐
│  Server Certificate             │
│  Subject: CN=example.com        │
│  Issuer: CN=Intermediate CA     │
│  [Public Key]                   │
│  [Signature by Intermediate]    │
└────────────┬────────────────────┘
             │ Verified by
┌────────────▼────────────────────┐
│  Intermediate Certificate       │
│  Subject: CN=Intermediate CA    │
│  Issuer: CN=Root CA             │
│  [Public Key]                   │
│  [Signature by Root]            │
└────────────┬────────────────────┘
             │ Verified by
┌────────────▼────────────────────┐
│  Root Certificate               │
│  Subject: CN=Root CA            │
│  Issuer: CN=Root CA (self)      │
│  [Public Key]                   │
│  [Self Signature]               │
│  ✓ In Trust Store               │
└─────────────────────────────────┘
</code></pre>
<h3 id="building-certificate-chain"><a class="header" href="#building-certificate-chain">Building Certificate Chain</a></h3>
<pre><code class="language-bash"># Create chain file (server cert + intermediate cert)
cat server.crt intermediate.crt &gt; fullchain.pem

# Or with root CA (not usually needed)
cat server.crt intermediate.crt rootCA.crt &gt; fullchain.pem

# Verify chain
openssl verify -CAfile rootCA.crt -untrusted intermediate.crt server.crt

# Display certificate chain
openssl s_client -connect example.com:443 -showcerts
</code></pre>
<h3 id="verifying-certificate-chain-in-python"><a class="header" href="#verifying-certificate-chain-in-python">Verifying Certificate Chain in Python</a></h3>
<pre><code class="language-python">from cryptography import x509
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
from cryptography.exceptions import InvalidSignature

def verify_certificate_chain(cert_chain):
    """
    Verify a certificate chain
    cert_chain: list of certificates [leaf, intermediate, ..., root]
    """
    for i in range(len(cert_chain) - 1):
        cert = cert_chain[i]
        issuer_cert = cert_chain[i + 1]

        # Verify issuer name matches
        if cert.issuer != issuer_cert.subject:
            return False, f"Issuer mismatch at level {i}"

        # Verify signature
        try:
            issuer_public_key = issuer_cert.public_key()
            issuer_public_key.verify(
                cert.signature,
                cert.tbs_certificate_bytes,
                padding.PKCS1v15(),
                cert.signature_hash_algorithm,
            )
        except InvalidSignature:
            return False, f"Invalid signature at level {i}"

        # Verify validity period
        import datetime
        now = datetime.datetime.utcnow()
        if now &lt; cert.not_valid_before or now &gt; cert.not_valid_after:
            return False, f"Certificate expired or not yet valid at level {i}"

    return True, "Chain verified successfully"

# Load certificates
certs = []
for cert_file in ['server.crt', 'intermediate.crt', 'root.crt']:
    with open(cert_file, 'rb') as f:
        cert = x509.load_pem_x509_certificate(f.read())
        certs.append(cert)

# Verify chain
is_valid, message = verify_certificate_chain(certs)
print(message)
</code></pre>
<h2 id="lets-encrypt"><a class="header" href="#lets-encrypt">Let's Encrypt</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<p>Let's Encrypt is a free, automated Certificate Authority providing:</p>
<ul>
<li>Free SSL/TLS certificates</li>
<li>90-day validity (encourages automation)</li>
<li>Domain Validation (DV) only</li>
<li>Automated renewal</li>
</ul>
<h3 id="acme-protocol"><a class="header" href="#acme-protocol">ACME Protocol</a></h3>
<pre><code>1. Client requests certificate for example.com

2. Let's Encrypt challenges ownership:
   - HTTP-01: Place file at http://example.com/.well-known/acme-challenge/
   - DNS-01: Add TXT record to _acme-challenge.example.com
   - TLS-ALPN-01: Configure TLS server with special certificate

3. Let's Encrypt verifies challenge

4. If successful, issues certificate

5. Client installs certificate

6. Automated renewal before 90-day expiration
</code></pre>
<h3 id="using-certbot"><a class="header" href="#using-certbot">Using Certbot</a></h3>
<pre><code class="language-bash"># Install certbot
sudo apt-get install certbot

# Obtain certificate (standalone)
sudo certbot certonly --standalone -d example.com -d www.example.com

# Obtain certificate (webroot - site already running)
sudo certbot certonly --webroot -w /var/www/html -d example.com

# Obtain certificate (DNS challenge)
sudo certbot certonly --manual --preferred-challenges dns -d example.com

# Obtain certificate (with automatic nginx configuration)
sudo certbot --nginx -d example.com -d www.example.com

# Obtain certificate (with automatic apache configuration)
sudo certbot --apache -d example.com

# List certificates
sudo certbot certificates

# Renew certificates (dry run)
sudo certbot renew --dry-run

# Renew certificates
sudo certbot renew

# Revoke certificate
sudo certbot revoke --cert-path /etc/letsencrypt/live/example.com/cert.pem

# Delete certificate
sudo certbot delete --cert-name example.com
</code></pre>
<h3 id="automated-renewal"><a class="header" href="#automated-renewal">Automated Renewal</a></h3>
<pre><code class="language-bash"># Add to crontab (check renewal twice daily)
0 0,12 * * * certbot renew --quiet

# Systemd timer (if using systemd)
sudo systemctl enable certbot-renew.timer
sudo systemctl start certbot-renew.timer

# Test renewal
sudo certbot renew --dry-run
</code></pre>
<h3 id="using-acmesh-alternative"><a class="header" href="#using-acmesh-alternative">Using acme.sh (Alternative)</a></h3>
<pre><code class="language-bash"># Install acme.sh
curl https://get.acme.sh | sh

# Issue certificate (HTTP validation)
acme.sh --issue -d example.com -w /var/www/html

# Issue certificate (DNS validation with Cloudflare)
export CF_Key="your-cloudflare-api-key"
export CF_Email="your@email.com"
acme.sh --issue --dns dns_cf -d example.com -d *.example.com

# Install certificate
acme.sh --install-cert -d example.com \
  --key-file /etc/nginx/ssl/example.com.key \
  --fullchain-file /etc/nginx/ssl/example.com.crt \
  --reloadcmd "systemctl reload nginx"

# Renew all certificates
acme.sh --renew-all

# Force renew
acme.sh --renew -d example.com --force
</code></pre>
<h2 id="certificate-management"><a class="header" href="#certificate-management">Certificate Management</a></h2>
<h3 id="certificate-inspection"><a class="header" href="#certificate-inspection">Certificate Inspection</a></h3>
<pre><code class="language-bash"># View certificate details
openssl x509 -in cert.pem -text -noout

# View certificate dates
openssl x509 -in cert.pem -noout -dates

# View certificate subject
openssl x509 -in cert.pem -noout -subject

# View certificate issuer
openssl x509 -in cert.pem -noout -issuer

# View certificate fingerprint
openssl x509 -in cert.pem -noout -fingerprint -sha256

# Check certificate and key match
openssl x509 -noout -modulus -in cert.pem | openssl md5
openssl rsa -noout -modulus -in key.pem | openssl md5
# If md5 hashes match, cert and key are paired

# View certificate from server
openssl s_client -connect example.com:443 -showcerts

# Check certificate expiration
echo | openssl s_client -connect example.com:443 2&gt;/dev/null | \
  openssl x509 -noout -dates
</code></pre>
<h3 id="python-certificate-tools"><a class="header" href="#python-certificate-tools">Python Certificate Tools</a></h3>
<pre><code class="language-python">from cryptography import x509
from cryptography.hazmat.primitives import serialization
import datetime

def inspect_certificate(cert_path):
    with open(cert_path, 'rb') as f:
        cert = x509.load_pem_x509_certificate(f.read())

    print("Certificate Information:")
    print(f"Subject: {cert.subject.rfc4514_string()}")
    print(f"Issuer: {cert.issuer.rfc4514_string()}")
    print(f"Serial Number: {cert.serial_number}")
    print(f"Not Valid Before: {cert.not_valid_before}")
    print(f"Not Valid After: {cert.not_valid_after}")
    print(f"Signature Algorithm: {cert.signature_algorithm_oid._name}")

    # Check if expired
    now = datetime.datetime.utcnow()
    days_until_expiry = (cert.not_valid_after - now).days

    if now &gt; cert.not_valid_after:
        print("⚠ Certificate EXPIRED!")
    elif days_until_expiry &lt; 30:
        print(f"⚠ Certificate expires soon ({days_until_expiry} days)")
    else:
        print(f"✓ Certificate valid ({days_until_expiry} days remaining)")

    # Subject Alternative Names
    try:
        san_ext = cert.extensions.get_extension_for_oid(
            x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME
        )
        print(f"SANs: {', '.join([dns.value for dns in san_ext.value])}")
    except x509.ExtensionNotFound:
        print("No SANs found")

    return cert

# Usage
cert = inspect_certificate('cert.pem')
</code></pre>
<h3 id="certificate-monitoring"><a class="header" href="#certificate-monitoring">Certificate Monitoring</a></h3>
<pre><code class="language-python">import ssl
import socket
from datetime import datetime

def check_certificate_expiry(hostname, port=443):
    """Check SSL certificate expiration"""
    context = ssl.create_default_context()

    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()

            # Parse expiration date
            expires = datetime.strptime(
                cert['notAfter'],
                '%b %d %H:%M:%S %Y %GMT'
            )

            days_remaining = (expires - datetime.now()).days

            print(f"Certificate for {hostname}:")
            print(f"  Subject: {dict(x[0] for x in cert['subject'])['commonName']}")
            print(f"  Issuer: {dict(x[0] for x in cert['issuer'])['commonName']}")
            print(f"  Expires: {expires}")
            print(f"  Days remaining: {days_remaining}")

            if days_remaining &lt; 0:
                print("  ⚠ EXPIRED!")
            elif days_remaining &lt; 30:
                print("  ⚠ Expiring soon!")
            else:
                print("  ✓ Valid")

            return days_remaining

# Check multiple sites
sites = ['google.com', 'github.com', 'example.com']
for site in sites:
    try:
        check_certificate_expiry(site)
        print()
    except Exception as e:
        print(f"Error checking {site}: {e}\n")
</code></pre>
<h3 id="certificate-renewal-strategy"><a class="header" href="#certificate-renewal-strategy">Certificate Renewal Strategy</a></h3>
<pre><code class="language-bash">#!/bin/bash
# certificate-renewal.sh

# Check certificate expiration
check_expiry() {
    local domain=$1
    local days_until_expiry=$(echo | openssl s_client -connect $domain:443 2&gt;/dev/null | \
        openssl x509 -noout -checkend 2592000)  # 30 days

    if [ $? -eq 0 ]; then
        echo "$domain: Certificate valid for at least 30 days"
        return 0
    else
        echo "$domain: Certificate expires within 30 days!"
        return 1
    fi
}

# Renew if needed
renew_certificate() {
    local domain=$1

    if ! check_expiry $domain; then
        echo "Renewing certificate for $domain..."
        certbot renew --cert-name $domain

        if [ $? -eq 0 ]; then
            echo "Certificate renewed successfully"
            systemctl reload nginx
        else
            echo "Certificate renewal failed!"
            # Send alert
        fi
    fi
}

# Check all domains
for domain in example.com api.example.com www.example.com; do
    renew_certificate $domain
done
</code></pre>
<h2 id="certificate-revocation"><a class="header" href="#certificate-revocation">Certificate Revocation</a></h2>
<h3 id="certificate-revocation-lists-crl"><a class="header" href="#certificate-revocation-lists-crl">Certificate Revocation Lists (CRL)</a></h3>
<pre><code class="language-bash"># Download CRL
wget http://crl.example.com/example.crl

# View CRL
openssl crl -in example.crl -text -noout

# Check if certificate is revoked
openssl verify -crl_check -CRLfile example.crl -CAfile ca.crt cert.pem
</code></pre>
<h3 id="online-certificate-status-protocol-ocsp"><a class="header" href="#online-certificate-status-protocol-ocsp">Online Certificate Status Protocol (OCSP)</a></h3>
<pre><code class="language-bash"># Get OCSP responder URL from certificate
openssl x509 -in cert.pem -noout -ocsp_uri

# Check certificate status via OCSP
openssl ocsp -issuer ca.crt -cert cert.pem \
  -url http://ocsp.example.com \
  -resp_text

# OCSP stapling check
openssl s_client -connect example.com:443 -status
</code></pre>
<h3 id="revoking-certificate"><a class="header" href="#revoking-certificate">Revoking Certificate</a></h3>
<pre><code class="language-bash"># Revoke with certbot
sudo certbot revoke --cert-path /etc/letsencrypt/live/example.com/cert.pem

# Revoke with reason
sudo certbot revoke --cert-path cert.pem --reason keycompromise

# Revoke with custom CA
openssl ca -config ca.conf -revoke cert.pem -keyfile ca.key -cert ca.crt

# Generate CRL
openssl ca -config ca.conf -gencrl -out crl.pem
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="1-key-size"><a class="header" href="#1-key-size">1. Key Size</a></h3>
<pre><code>RSA:
  Minimum: 2048 bits
  Recommended: 3072-4096 bits

ECDSA:
  Recommended: P-256 (256-bit)
  High security: P-384 (384-bit)

Ed25519:
  Fixed: 256-bit (recommended for new deployments)
</code></pre>
<h3 id="2-certificate-validity-period"><a class="header" href="#2-certificate-validity-period">2. Certificate Validity Period</a></h3>
<pre><code>Modern best practices:
- Maximum: 398 days (13 months) - enforced by browsers
- Recommended: 90 days (Let's Encrypt default)
- Automated renewal: Essential for short validity

Historical:
- Before 2020: Up to 2-3 years
- 2020: 398 days maximum
- Trend: Shorter validity periods
</code></pre>
<h3 id="3-subject-alternative-names-sans"><a class="header" href="#3-subject-alternative-names-sans">3. Subject Alternative Names (SANs)</a></h3>
<pre><code class="language-bash"># Include all domain variants
subjectAltName = DNS:example.com,DNS:www.example.com,DNS:*.example.com

# Don't rely on Common Name (CN) - deprecated
# Always use SANs
</code></pre>
<h3 id="4-certificate-pinning"><a class="header" href="#4-certificate-pinning">4. Certificate Pinning</a></h3>
<pre><code class="language-python">import ssl
import hashlib
import socket

def verify_certificate_pinning(hostname, expected_fingerprints):
    """Verify certificate matches expected fingerprint"""
    context = ssl.create_default_context()

    with socket.create_connection((hostname, 443)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert_der = ssock.getpeercert(binary_form=True)
            fingerprint = hashlib.sha256(cert_der).hexdigest()

            if fingerprint in expected_fingerprints:
                print(f"✓ Certificate pinning verified")
                return True
            else:
                print(f"✗ Certificate pinning failed!")
                print(f"  Expected: {expected_fingerprints}")
                print(f"  Got: {fingerprint}")
                return False

# Usage
expected_pins = [
    'a1b2c3d4e5f6...',  # Primary certificate
    '9a8b7c6d5e4f...',  # Backup certificate
]

verify_certificate_pinning('example.com', expected_pins)
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-automate-certificate-management"><a class="header" href="#1-automate-certificate-management">1. Automate Certificate Management</a></h3>
<pre><code>✓ Use Let's Encrypt for free certificates
✓ Automate renewal (certbot, acme.sh)
✓ Monitor expiration dates
✓ Test renewal process regularly
✓ Use short validity periods (90 days)
</code></pre>
<h3 id="2-secure-private-keys"><a class="header" href="#2-secure-private-keys">2. Secure Private Keys</a></h3>
<pre><code class="language-bash"># Restrict permissions
chmod 600 private.key

# Use hardware security modules (HSM) for critical keys
# Use encrypted private keys
openssl rsa -aes256 -in private.key -out private_encrypted.key

# Never commit to version control
echo "*.key" &gt;&gt; .gitignore
echo "*.pem" &gt;&gt; .gitignore
</code></pre>
<h3 id="3-use-strong-cryptography"><a class="header" href="#3-use-strong-cryptography">3. Use Strong Cryptography</a></h3>
<pre><code>✓ RSA 2048-bit minimum (prefer 3072+)
✓ ECDSA P-256 or better
✓ SHA-256 or SHA-512 for signatures
✗ Avoid MD5, SHA-1
✗ Avoid RSA &lt;2048 bits
</code></pre>
<h3 id="4-implement-certificate-transparency"><a class="header" href="#4-implement-certificate-transparency">4. Implement Certificate Transparency</a></h3>
<pre><code class="language-bash"># Check if certificate is in CT logs
curl https://crt.sh/?q=example.com

# Monitor for unauthorized certificates
# Use tools like certstream, certificate-transparency-go
</code></pre>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<h3 id="1-expired-certificates"><a class="header" href="#1-expired-certificates">1. Expired Certificates</a></h3>
<pre><code>Problem: Certificate expires unexpectedly
Solution: Automate monitoring and renewal
</code></pre>
<h3 id="2-missing-intermediate-certificates"><a class="header" href="#2-missing-intermediate-certificates">2. Missing Intermediate Certificates</a></h3>
<pre><code>Problem: Browser shows untrusted certificate
Solution: Include full chain (server + intermediate certs)

# Correct chain order
cat server.crt intermediate.crt &gt; fullchain.pem
</code></pre>
<h3 id="3-certificate-name-mismatch"><a class="header" href="#3-certificate-name-mismatch">3. Certificate Name Mismatch</a></h3>
<pre><code>Problem: Certificate for wrong domain
Solution: Use proper SANs

# Include all domains
subjectAltName = DNS:example.com,DNS:www.example.com
</code></pre>
<h3 id="4-insecure-private-key"><a class="header" href="#4-insecure-private-key">4. Insecure Private Key</a></h3>
<pre><code>Problem: Private key readable by all users
Solution: Restrict permissions

chmod 600 private.key
chown root:root private.key
</code></pre>
<h2 id="eli10"><a class="header" href="#eli10">ELI10</a></h2>
<p>Certificates are like ID cards for websites:</p>
<p><strong>Without certificates:</strong></p>
<ul>
<li>You visit "bank.com"</li>
<li>How do you know it's really your bank?</li>
<li>Attackers could pretend to be your bank!</li>
</ul>
<p><strong>With certificates:</strong></p>
<ol>
<li>
<p><strong>Website has ID card</strong> (certificate)</p>
<ul>
<li>Says: "I'm bank.com"</li>
<li>Has a special seal (signature)</li>
</ul>
</li>
<li>
<p><strong>Trusted Authority</strong> (CA like Let's Encrypt)</p>
<ul>
<li>Like a government issuing passports</li>
<li>Checks: "Yes, you really own bank.com"</li>
<li>Adds their official seal</li>
</ul>
</li>
<li>
<p><strong>Your browser checks</strong>:</p>
<ul>
<li>Is the ID card real? ✓</li>
<li>Is it expired? ✓</li>
<li>Does it match the website name? ✓</li>
<li>Is the seal from a trusted authority? ✓</li>
</ul>
</li>
<li>
<p><strong>Chain of Trust</strong>:</p>
<pre><code>Browser trusts → Root CA
Root CA trusts → Intermediate CA
Intermediate CA trusts → Website Certificate
Therefore, Browser trusts → Website!
</code></pre>
</li>
</ol>
<p><strong>Let's Encrypt made it:</strong></p>
<ul>
<li>Free (used to cost $$$)</li>
<li>Automatic (renews itself)</li>
<li>Easy (simple commands)</li>
</ul>
<p><strong>Real-world analogy:</strong></p>
<ul>
<li>Certificate = Passport</li>
<li>CA = Government passport office</li>
<li>Browser = Border control checking passports</li>
<li>Expiration date = Passport validity</li>
<li>Renewal = Getting new passport before expiry</li>
</ul>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<ul>
<li><a href="https://letsencrypt.org/docs/">Let's Encrypt Documentation</a></li>
<li><a href="https://tools.ietf.org/html/rfc5280">X.509 Certificate Format (RFC 5280)</a></li>
<li><a href="https://tools.ietf.org/html/rfc8555">ACME Protocol (RFC 8555)</a></li>
<li><a href="https://certificate.transparency.dev/">Certificate Transparency</a></li>
<li><a href="https://www.ssllabs.com/ssltest/">SSL Labs Server Test</a></li>
<li><a href="https://certbot.eff.org/docs/">Certbot Documentation</a></li>
<li><a href="https://www.feistyduck.com/library/openssl-cookbook/">OpenSSL Cookbook</a></li>
<li><a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Public Key Infrastructure (PKI) Guide</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../security/digital_signatures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../security/ssl_tls.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../security/digital_signatures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../security/ssl_tls.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
