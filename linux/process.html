<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Process - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-a5d335fc.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-cda83475.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="linux-process-management"><a class="header" href="#linux-process-management">Linux Process Management</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#process-fundamentals">Process Fundamentals</a></li>
<li><a href="#process-identification">Process Identification</a></li>
<li><a href="#process-memory-layout">Process Memory Layout</a></li>
<li><a href="#stack-management">Stack Management</a></li>
<li><a href="#heap-management">Heap Management</a></li>
<li><a href="#shared-objects-so">Shared Objects (SO)</a></li>
<li><a href="#process-lifecycle">Process Lifecycle</a></li>
<li><a href="#process-operations">Process Operations</a></li>
<li><a href="#process-states">Process States</a></li>
<li><a href="#process-management-tools">Process Management Tools</a></li>
<li><a href="#proc-filesystem">/proc Filesystem</a></li>
<li><a href="#inter-process-communication">Inter-Process Communication</a></li>
<li><a href="#advanced-patterns">Advanced Patterns</a></li>
<li><a href="#practical-examples">Practical Examples</a></li>
</ul>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A <strong>process</strong> is an instance of a running program. It’s the fundamental unit of execution in Unix/Linux systems. Each process has its own:</p>
<ul>
<li>Address space (memory)</li>
<li>Process ID (PID)</li>
<li>File descriptors</li>
<li>Security attributes (UID, GID)</li>
<li>Execution context (registers, PC, stack pointer)</li>
</ul>
<h3 id="process-vs-thread"><a class="header" href="#process-vs-thread">Process vs Thread</a></h3>
<ul>
<li><strong>Process</strong>: Independent execution unit with separate memory space</li>
<li><strong>Thread</strong>: Lightweight execution unit sharing the same memory space within a process</li>
<li>Threads share: text, data, heap, file descriptors</li>
<li>Threads have separate: stack, registers, thread-local storage</li>
</ul>
<hr>
<h2 id="process-fundamentals"><a class="header" href="#process-fundamentals">Process Fundamentals</a></h2>
<h3 id="what-is-a-process"><a class="header" href="#what-is-a-process">What is a Process?</a></h3>
<p>A process consists of:</p>
<ol>
<li><strong>Program code</strong> (text segment)</li>
<li><strong>Current activity</strong> (program counter, register values)</li>
<li><strong>Stack</strong> (temporary data: function parameters, return addresses, local variables)</li>
<li><strong>Data section</strong> (global variables)</li>
<li><strong>Heap</strong> (dynamically allocated memory)</li>
</ol>
<h3 id="process-attributes"><a class="header" href="#process-attributes">Process Attributes</a></h3>
<pre><code class="language-c">struct task_struct {
    pid_t pid;                    // Process ID
    pid_t tgid;                   // Thread group ID
    struct task_struct *parent;   // Parent process
    struct list_head children;    // List of child processes
    struct mm_struct *mm;         // Memory descriptor
    struct files_struct *files;   // Open file descriptors
    // ... hundreds more fields
};
</code></pre>
<hr>
<h2 id="process-identification"><a class="header" href="#process-identification">Process Identification</a></h2>
<h3 id="pid-process-id"><a class="header" href="#pid-process-id">PID (Process ID)</a></h3>
<p>Every process has a unique Process ID:</p>
<pre><code class="language-bash"># Get current process PID
echo $$

# Get PID of a command
pgrep firefox
pidof firefox

# Kill a process by PID
kill -9 12345
</code></pre>
<p><strong>Key PIDs:</strong></p>
<ul>
<li><code>PID 0</code>: Scheduler (kernel space)</li>
<li><code>PID 1</code>: init/systemd (first user space process)</li>
<li><code>PID 2</code>: kthreadd (kernel thread daemon)</li>
</ul>
<h3 id="ppid-parent-process-id"><a class="header" href="#ppid-parent-process-id">PPID (Parent Process ID)</a></h3>
<p>Every process (except PID 1) has a parent:</p>
<pre><code class="language-bash"># View parent-child relationship
ps -ef | grep process_name
pstree -p

# Get PPID programmatically
cat /proc/$$/status | grep PPid
</code></pre>
<p><strong>Orphan Process</strong>: When a parent dies before its child, the child is adopted by init (PID 1).</p>
<p><strong>Zombie Process</strong>: Child process that has terminated but parent hasn’t read its exit status via <code>wait()</code>.</p>
<h3 id="process-group-id-pgid"><a class="header" href="#process-group-id-pgid">Process Group ID (PGID)</a></h3>
<p>Processes can be grouped for signal management:</p>
<pre><code class="language-bash"># Send signal to entire process group
kill -TERM -12345  # Negative PID = process group

# Get process group
ps -o pid,pgid,cmd

# Job control
./long_running_task &amp;  # Background job
jobs                   # List jobs
fg %1                  # Foreground job
</code></pre>
<h3 id="session-id-sid"><a class="header" href="#session-id-sid">Session ID (SID)</a></h3>
<p>A session is a collection of process groups:</p>
<pre><code class="language-bash"># Get session ID
ps -o pid,sid,cmd

# Create new session (daemon pattern)
setsid ./daemon_process
</code></pre>
<h3 id="user-and-group-ids"><a class="header" href="#user-and-group-ids">User and Group IDs</a></h3>
<p>Security context:</p>
<pre><code class="language-bash"># Real, Effective, Saved UIDs
cat /proc/$$/status | grep -E "Uid|Gid"

# UID types:
# - Real UID (RUID): User who started the process
# - Effective UID (EUID): Used for permission checks
# - Saved UID (SUID): Previous EUID (for privilege dropping)
</code></pre>
<hr>
<h2 id="process-memory-layout"><a class="header" href="#process-memory-layout">Process Memory Layout</a></h2>
<p>A Linux process has a well-defined virtual memory layout:</p>
<pre><code>High Address (0xFFFFFFFF / 0x7FFFFFFFFFFF on 64-bit)
┌─────────────────────────────────────┐
│         Kernel Space                │  &lt;- Not accessible from user space
│         (1GB / 128TB)               │
├─────────────────────────────────────┤ 0xC0000000 (32-bit) / 0x00007FFFFFFFFFFF (64-bit)
│                                     │
│         Stack                       │  &lt;- Grows downward (high → low)
│         (Local variables,           │
│          function calls)            │
│              ↓                      │
│                                     │
│         ...                         │
│                                     │
│              ↑                      │
│         Memory Mapping              │  &lt;- mmap(), shared libraries
│         (Shared objects, mmap)      │
│              ↑                      │
│                                     │
│         ...                         │
│                                     │
│              ↑                      │
│         Heap                        │  &lt;- Grows upward (low → high)
│         (Dynamic memory: malloc)    │
│                                     │
├─────────────────────────────────────┤
│         BSS Segment                 │  &lt;- Uninitialized global/static vars
│         (Uninitialized data)        │     Initialized to 0
├─────────────────────────────────────┤
│         Data Segment                │  &lt;- Initialized global/static vars
│         (Initialized data)          │
├─────────────────────────────────────┤
│         Text Segment                │  &lt;- Program code (read-only)
│         (Code)                      │
└─────────────────────────────────────┘ Low Address (0x00000000)
</code></pre>
<h3 id="segments-explained"><a class="header" href="#segments-explained">Segments Explained</a></h3>
<h4 id="1-text-segment-code"><a class="header" href="#1-text-segment-code">1. Text Segment (Code)</a></h4>
<ul>
<li>Contains executable instructions</li>
<li>Read-only and shareable</li>
<li>Multiple processes can share the same text segment</li>
</ul>
<pre><code class="language-bash"># View segments
readelf -l /bin/ls
objdump -h /bin/ls

# Check if text is read-only
cat /proc/$$/maps | grep r-xp
</code></pre>
<h4 id="2-data-segment"><a class="header" href="#2-data-segment">2. Data Segment</a></h4>
<ul>
<li>Initialized global and static variables</li>
<li>Read-write</li>
<li>Size known at compile time</li>
</ul>
<pre><code class="language-c">int global_var = 42;              // Data segment
static int static_var = 100;      // Data segment
const int const_var = 200;        // May be in read-only data or text

int main() {
    // ...
}
</code></pre>
<h4 id="3-bss-segment-block-started-by-symbol"><a class="header" href="#3-bss-segment-block-started-by-symbol">3. BSS Segment (Block Started by Symbol)</a></h4>
<ul>
<li>Uninitialized global and static variables</li>
<li>Automatically initialized to 0</li>
<li>Doesn’t occupy space in executable file</li>
</ul>
<pre><code class="language-c">int global_uninit;                // BSS
static int static_uninit;         // BSS

int main() {
    printf("%d\n", global_uninit); // Prints 0
}
</code></pre>
<p><strong>Why BSS?</strong> Saves disk space. Instead of storing zeros in the executable, the loader allocates and zeros the memory at runtime.</p>
<h4 id="4-heap-segment"><a class="header" href="#4-heap-segment">4. Heap Segment</a></h4>
<ul>
<li>Dynamically allocated memory</li>
<li>Grows upward (toward higher addresses)</li>
<li>Managed by <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, <code>free()</code></li>
<li>See <a href="#heap-management">Heap Management</a> for details</li>
</ul>
<h4 id="5-memory-mapping-segment"><a class="header" href="#5-memory-mapping-segment">5. Memory Mapping Segment</a></h4>
<ul>
<li>Shared libraries (.so files)</li>
<li>Memory-mapped files (<code>mmap()</code>)</li>
<li>Anonymous mappings</li>
<li>Position Independent Code (PIC)</li>
</ul>
<h4 id="6-stack-segment"><a class="header" href="#6-stack-segment">6. Stack Segment</a></h4>
<ul>
<li>Function call frames</li>
<li>Local variables</li>
<li>Function parameters</li>
<li>Return addresses</li>
<li>Grows downward (toward lower addresses)</li>
<li>See <a href="#stack-management">Stack Management</a> for details</li>
</ul>
<h3 id="viewing-memory-layout"><a class="header" href="#viewing-memory-layout">Viewing Memory Layout</a></h3>
<pre><code class="language-bash"># View process memory map
cat /proc/$$/maps

# Example output:
# 00400000-00401000 r-xp ...  /bin/bash     &lt;- Text
# 00600000-00601000 r--p ...  /bin/bash     &lt;- Data
# 00601000-00602000 rw-p ...  /bin/bash     &lt;- Data
# 01a15000-01a36000 rw-p ...  [heap]        &lt;- Heap
# 7fff12345000-...  rw-p ...  [stack]       &lt;- Stack
# 7f1234567000-...  r-xp ...  libc.so.6     &lt;- Shared lib

# Memory usage
pmap -x $$
cat /proc/$$/status | grep -E "VmSize|VmRSS|VmData|VmStk"

# Detailed memory info
smem -p $$
</code></pre>
<hr>
<h2 id="stack-management"><a class="header" href="#stack-management">Stack Management</a></h2>
<h3 id="stack-fundamentals"><a class="header" href="#stack-fundamentals">Stack Fundamentals</a></h3>
<p>The stack is a contiguous region of memory that:</p>
<ul>
<li>Stores local variables</li>
<li>Manages function calls (call stack)</li>
<li>Saves return addresses</li>
<li>Passes function arguments</li>
<li>Grows <strong>downward</strong> (high address → low address)</li>
</ul>
<h3 id="stack-frame"><a class="header" href="#stack-frame">Stack Frame</a></h3>
<p>Each function call creates a <strong>stack frame</strong> (activation record):</p>
<pre><code>High Address
┌──────────────────────┐
│   Previous frame     │
├──────────────────────┤ &lt;- Previous Frame Pointer (FP)
│   Arguments          │
├──────────────────────┤
│   Return Address     │
├──────────────────────┤ &lt;- Frame Pointer (FP/RBP)
│   Saved FP           │
├──────────────────────┤
│   Local Variables    │
├──────────────────────┤
│   Temporary Space    │
├──────────────────────┤ &lt;- Stack Pointer (SP/RSP)
│   (Free space)       │
└──────────────────────┘
Low Address
</code></pre>
<h3 id="stack-operations"><a class="header" href="#stack-operations">Stack Operations</a></h3>
<pre><code class="language-c">void func(int a, int b) {
    int x = 10;        // Local variable on stack
    int arr[100];      // Array on stack (400 bytes)

    // Stack frame contains:
    // - Parameters: a, b
    // - Return address
    // - Saved frame pointer
    // - Local vars: x, arr[100]
}

int main() {
    func(5, 7);
    return 0;
}
</code></pre>
<p><strong>Assembly view (x86-64 simplified):</strong></p>
<pre><code class="language-asm">main:
    push rbp              ; Save old frame pointer
    mov rbp, rsp          ; Set new frame pointer
    mov edi, 5            ; First argument (a)
    mov esi, 7            ; Second argument (b)
    call func             ; Push return address and jump

func:
    push rbp              ; Save caller's frame pointer
    mov rbp, rsp          ; Set new frame pointer
    sub rsp, 416          ; Allocate space for locals (aligned)
    mov DWORD PTR [rbp-4], 10   ; x = 10
    ; ... function body ...
    leave                 ; Restore stack (mov rsp, rbp; pop rbp)
    ret                   ; Pop return address and jump
</code></pre>
<h3 id="stack-size"><a class="header" href="#stack-size">Stack Size</a></h3>
<pre><code class="language-bash"># View stack size limit
ulimit -s              # In KB (typically 8192 KB = 8 MB)

# Set stack size
ulimit -s 16384        # 16 MB

# View thread stack size
cat /proc/$$/limits | grep stack

# In C, check stack size
#include &lt;sys/resource.h&gt;
struct rlimit rl;
getrlimit(RLIMIT_STACK, &amp;rl);
printf("Stack limit: %ld\n", rl.rlim_cur);
</code></pre>
<h3 id="stack-overflow"><a class="header" href="#stack-overflow">Stack Overflow</a></h3>
<p>Occurs when stack grows beyond allocated size:</p>
<pre><code class="language-c">// Causes stack overflow
void recursive() {
    char large[1000000];  // 1 MB local array
    recursive();          // Infinite recursion
}

// Also causes overflow
void deep_recursion(int n) {
    if (n == 0) return;
    deep_recursion(n - 1);  // Deep recursion without base case
}
</code></pre>
<p><strong>Detection:</strong></p>
<pre><code class="language-bash"># Enable stack protection (compile time)
gcc -fstack-protector-all program.c

# Runtime detection
dmesg | grep segfault
</code></pre>
<h3 id="thread-stacks"><a class="header" href="#thread-stacks">Thread Stacks</a></h3>
<p>Each thread has its own stack:</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;

void* thread_func(void* arg) {
    int local = 42;  // Each thread has its own 'local'
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, thread_func, NULL);
    pthread_create(&amp;t2, NULL, thread_func, NULL);

    // Set thread stack size
    pthread_attr_t attr;
    pthread_attr_init(&amp;attr);
    pthread_attr_setstacksize(&amp;attr, 2 * 1024 * 1024); // 2 MB
    pthread_create(&amp;t2, &amp;attr, thread_func, NULL);
}
</code></pre>
<p><strong>View thread stacks:</strong></p>
<pre><code class="language-bash">cat /proc/$$/maps | grep stack
# [stack]           &lt;- Main thread stack
# [stack:1234]      &lt;- Thread 1234's stack
# [stack:1235]      &lt;- Thread 1235's stack
</code></pre>
<h3 id="stack-canaries"><a class="header" href="#stack-canaries">Stack Canaries</a></h3>
<p>Protection against buffer overflows:</p>
<pre><code class="language-c">gcc -fstack-protector-all program.c

// The compiler inserts:
// - Canary value before return address
// - Check before function returns
// - Abort if canary is corrupted

void vulnerable() {
    char buffer[64];
    strcpy(buffer, user_input);  // If overflow, canary detects it
}
</code></pre>
<hr>
<h2 id="heap-management"><a class="header" href="#heap-management">Heap Management</a></h2>
<h3 id="heap-fundamentals"><a class="header" href="#heap-fundamentals">Heap Fundamentals</a></h3>
<p>The heap is used for <strong>dynamic memory allocation</strong>:</p>
<ul>
<li>Grows upward (low address → high address)</li>
<li>Managed explicitly by programmer</li>
<li>Allocated via <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code></li>
<li>Freed via <code>free()</code></li>
<li>More flexible but slower than stack</li>
</ul>
<h3 id="memory-allocation"><a class="header" href="#memory-allocation">Memory Allocation</a></h3>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

// Allocate memory
int* ptr = malloc(100 * sizeof(int));    // 400 bytes
if (ptr == NULL) {
    // Allocation failed
}

// Allocate and zero-initialize
int* ptr2 = calloc(100, sizeof(int));    // 400 bytes, zeroed

// Resize allocation
ptr = realloc(ptr, 200 * sizeof(int));   // 800 bytes

// Free memory
free(ptr);
ptr = NULL;  // Good practice
</code></pre>
<h3 id="system-calls-brk-and-sbrk"><a class="header" href="#system-calls-brk-and-sbrk">System Calls: brk() and sbrk()</a></h3>
<p><code>malloc()</code> uses <code>brk()</code>/<code>sbrk()</code> for small allocations:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

// Get current heap end (program break)
void* current_brk = sbrk(0);

// Increase heap by 1024 bytes
void* new_mem = sbrk(1024);

// Set heap end directly
brk(new_address);
</code></pre>
<p><strong>Process:</strong></p>
<ol>
<li><code>malloc()</code> requests memory from heap</li>
<li>If heap is too small, <code>malloc()</code> calls <code>sbrk()</code> to extend heap</li>
<li><code>sbrk()</code> system call moves the program break</li>
<li>Kernel allocates more pages to the process</li>
</ol>
<h3 id="system-call-mmap"><a class="header" href="#system-call-mmap">System Call: mmap()</a></h3>
<p>For large allocations (typically &gt;128 KB), <code>malloc()</code> uses <code>mmap()</code>:</p>
<pre><code class="language-c">#include &lt;sys/mman.h&gt;

// Allocate 1 MB anonymously
void* ptr = mmap(NULL, 1024*1024,
                 PROT_READ|PROT_WRITE,
                 MAP_PRIVATE|MAP_ANONYMOUS,
                 -1, 0);

if (ptr == MAP_FAILED) {
    perror("mmap");
}

// Free memory
munmap(ptr, 1024*1024);
</code></pre>
<p><strong>Why mmap for large allocations?</strong></p>
<ul>
<li>Can return memory to OS immediately</li>
<li>Doesn’t fragment heap</li>
<li>Better for sparse access patterns</li>
</ul>
<h3 id="heap-layout"><a class="header" href="#heap-layout">Heap Layout</a></h3>
<p>The heap is divided into chunks:</p>
<pre><code>┌────────────────────────────────┐
│  Chunk Header (metadata)       │  &lt;- Size, flags, prev/next pointers
├────────────────────────────────┤
│  User Data                     │  &lt;- Returned by malloc()
│  ...                           │
├────────────────────────────────┤
│  Chunk Header                  │
├────────────────────────────────┤
│  User Data                     │
│  ...                           │
└────────────────────────────────┘
</code></pre>
<h3 id="memory-allocators"><a class="header" href="#memory-allocators">Memory Allocators</a></h3>
<h4 id="glibc-malloc-ptmalloc2"><a class="header" href="#glibc-malloc-ptmalloc2">glibc malloc (ptmalloc2)</a></h4>
<p>Default allocator in Linux:</p>
<pre><code class="language-c">// Uses bins (freelists) for different sizes:
// - Fast bins: 16-80 bytes (LIFO)
// - Small bins: &lt;512 bytes (FIFO)
// - Large bins: ≥512 bytes (best fit)
// - Unsorted bin: recently freed chunks

// View malloc stats
malloc_stats();

// Configure malloc
mallopt(M_MMAP_THRESHOLD, 128*1024);  // mmap threshold
</code></pre>
<h4 id="alternative-allocators"><a class="header" href="#alternative-allocators">Alternative Allocators</a></h4>
<pre><code class="language-c">// jemalloc (used by Firefox, Redis)
// Install: apt-get install libjemalloc-dev
// Use: LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so ./program

// tcmalloc (Google's allocator)
// Install: apt-get install libgoogle-perftools-dev
// Use: LD_PRELOAD=/usr/lib/libtcmalloc.so ./program
</code></pre>
<h3 id="heap-visualization"><a class="header" href="#heap-visualization">Heap Visualization</a></h3>
<pre><code class="language-bash"># View heap size
cat /proc/$$/status | grep VmData

# View heap region
cat /proc/$$/maps | grep heap

# Analyze heap usage
valgrind --tool=massif ./program
ms_print massif.out.*

# Heap profiling
valgrind --tool=memcheck --leak-check=full ./program

# Real-time heap monitoring
heaptrack ./program
heaptrack_gui heaptrack.program.*.gz
</code></pre>
<h3 id="common-heap-issues"><a class="header" href="#common-heap-issues">Common Heap Issues</a></h3>
<h4 id="1-memory-leak"><a class="header" href="#1-memory-leak">1. Memory Leak</a></h4>
<pre><code class="language-c">void leak() {
    int* ptr = malloc(100);
    // Forgot to free(ptr)
}  // Memory never freed

// Detection
valgrind --leak-check=full ./program
</code></pre>
<h4 id="2-double-free"><a class="header" href="#2-double-free">2. Double Free</a></h4>
<pre><code class="language-c">int* ptr = malloc(100);
free(ptr);
free(ptr);  // ERROR: Double free

// Prevention
free(ptr);
ptr = NULL;  // Freeing NULL is safe
</code></pre>
<h4 id="3-use-after-free"><a class="header" href="#3-use-after-free">3. Use After Free</a></h4>
<pre><code class="language-c">int* ptr = malloc(100);
free(ptr);
*ptr = 42;  // ERROR: Use after free
</code></pre>
<h4 id="4-heap-fragmentation"><a class="header" href="#4-heap-fragmentation">4. Heap Fragmentation</a></h4>
<pre><code>Before:
[Used][Free  100KB  ][Used][Free  50KB  ][Used]

After many alloc/free:
[Used][Free 10KB][Used][Free 5KB][Used][Free 3KB]
              ↑ Can't allocate 50KB contiguous block
</code></pre>
<p><strong>Mitigation:</strong></p>
<ul>
<li>Use memory pools</li>
<li>Custom allocators</li>
<li>Minimize allocation/deallocation churn</li>
</ul>
<h3 id="heap-security"><a class="header" href="#heap-security">Heap Security</a></h3>
<h4 id="heap-overflow"><a class="header" href="#heap-overflow">Heap Overflow</a></h4>
<pre><code class="language-c">int* arr = malloc(10 * sizeof(int));
arr[15] = 42;  // Overflow! Corrupts heap metadata

// Protection:
// - ASLR (Address Space Layout Randomization)
// - Heap canaries
// - Safe libraries (AddressSanitizer)
</code></pre>
<h4 id="heap-spraying"><a class="header" href="#heap-spraying">Heap Spraying</a></h4>
<p>Attack technique filling heap with predictable data.</p>
<p><strong>Defense:</strong></p>
<pre><code class="language-bash"># Enable ASLR
echo 2 &gt; /proc/sys/kernel/randomize_va_space

# Compile with sanitizers
gcc -fsanitize=address program.c
</code></pre>
<hr>
<h2 id="shared-objects-so"><a class="header" href="#shared-objects-so">Shared Objects (SO)</a></h2>
<h3 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic Linking</a></h3>
<p>Shared objects (.so files) are dynamically linked libraries:</p>
<pre><code class="language-bash"># List shared library dependencies
ldd /bin/ls
# Output:
#   linux-vdso.so.1 (0x00007fff...)
#   libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1
#   libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6
#   /lib64/ld-linux-x86-64.so.2 (0x00007f...)

# Show shared objects loaded by process
cat /proc/$$/maps | grep "\.so"
pmap $$ | grep "\.so"
</code></pre>
<h3 id="static-vs-dynamic-linking"><a class="header" href="#static-vs-dynamic-linking">Static vs Dynamic Linking</a></h3>
<pre><code class="language-bash"># Static linking (larger binary, no dependencies)
gcc -static program.c -o program_static

# Dynamic linking (smaller binary, needs .so files)
gcc program.c -o program_dynamic

# Compare sizes
ls -lh program_static program_dynamic
# static: ~800 KB, dynamic: ~16 KB
</code></pre>
<h3 id="creating-shared-libraries"><a class="header" href="#creating-shared-libraries">Creating Shared Libraries</a></h3>
<pre><code class="language-c">// mylib.c
#include "mylib.h"

int add(int a, int b) {
    return a + b;
}
</code></pre>
<pre><code class="language-c">// mylib.h
#ifndef MYLIB_H
#define MYLIB_H

int add(int a, int b);

#endif
</code></pre>
<pre><code class="language-bash"># Compile as shared object
gcc -fPIC -c mylib.c -o mylib.o
gcc -shared -o libmylib.so mylib.o

# Use the library
gcc program.c -L. -lmylib -o program

# Run (need to set LD_LIBRARY_PATH)
LD_LIBRARY_PATH=. ./program
</code></pre>
<h3 id="position-independent-code-pic"><a class="header" href="#position-independent-code-pic">Position Independent Code (PIC)</a></h3>
<p>PIC allows code to run at any memory address:</p>
<pre><code class="language-bash"># Compile with PIC
gcc -fPIC -c code.c

# Check if binary is PIC
readelf -h binary | grep Type
# Type: DYN (Shared object file)  &lt;- PIC
# Type: EXEC (Executable file)    &lt;- Not PIC
</code></pre>
<p><strong>Why PIC?</strong></p>
<ul>
<li>ASLR: Security feature randomizes library load addresses</li>
<li>Sharing: Multiple processes share same physical memory for library code</li>
<li>Can’t share non-PIC code (different virtual addresses)</li>
</ul>
<h3 id="dynamic-loader"><a class="header" href="#dynamic-loader">Dynamic Loader</a></h3>
<p><code>ld.so</code> / <code>ld-linux.so</code> loads shared libraries at runtime:</p>
<pre><code class="language-bash"># Show loader
/lib64/ld-linux-x86-64.so.2 --version

# Trace library loading
LD_TRACE_LOADED_OBJECTS=1 ./program  # Same as ldd

# Debug dynamic linking
LD_DEBUG=all ./program 2&gt;debug.log
LD_DEBUG=libs ./program   # Show library search
LD_DEBUG=bindings ./program  # Show symbol binding
</code></pre>
<h3 id="library-search-path"><a class="header" href="#library-search-path">Library Search Path</a></h3>
<pre><code class="language-bash"># Search order:
# 1. RPATH (embedded in binary)
# 2. LD_LIBRARY_PATH environment variable
# 3. /etc/ld.so.cache (built from /etc/ld.so.conf)
# 4. /lib, /usr/lib

# View RPATH
readelf -d program | grep RPATH

# Set RPATH at compile time
gcc program.c -Wl,-rpath=/opt/mylib -o program

# Update library cache
ldconfig

# View cached libraries
ldconfig -p | grep libssl
</code></pre>
<h3 id="dynamic-loading-at-runtime"><a class="header" href="#dynamic-loading-at-runtime">Dynamic Loading at Runtime</a></h3>
<pre><code class="language-c">#include &lt;dlfcn.h&gt;

// Load library at runtime
void* handle = dlopen("libmylib.so", RTLD_LAZY);
if (!handle) {
    fprintf(stderr, "Error: %s\n", dlerror());
    exit(1);
}

// Get function pointer
typedef int (*add_func)(int, int);
add_func add = (add_func) dlsym(handle, "add");
if (!add) {
    fprintf(stderr, "Error: %s\n", dlerror());
    exit(1);
}

// Use function
int result = add(3, 4);

// Unload library
dlclose(handle);
</code></pre>
<pre><code class="language-bash"># Compile with -ldl
gcc program.c -ldl -o program
</code></pre>
<h3 id="symbol-resolution"><a class="header" href="#symbol-resolution">Symbol Resolution</a></h3>
<pre><code class="language-bash"># List symbols in library
nm -D libmylib.so
# T add  &lt;- Defined in text (function)
# U printf  &lt;- Undefined (needs to be resolved)

# List all symbols (including internal)
nm libmylib.so

# Show only exported symbols
objdump -T libmylib.so

# Symbol versioning
objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep printf
# printf@@GLIBC_2.2.5
</code></pre>
<h3 id="preloading-libraries"><a class="header" href="#preloading-libraries">Preloading Libraries</a></h3>
<pre><code class="language-bash"># Inject library before all others
LD_PRELOAD=/path/to/mylib.so ./program

# Common use cases:
# 1. Override functions (malloc, free)
# 2. Instrumentation
# 3. Testing/mocking

# Example: Override malloc
cat &gt; mymalloc.c &lt;&lt; 'EOF'
#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
#include &lt;stdio.h&gt;

void* malloc(size_t size) {
    static void* (*real_malloc)(size_t) = NULL;
    if (!real_malloc)
        real_malloc = dlsym(RTLD_NEXT, "malloc");

    printf("malloc(%zu)\n", size);
    return real_malloc(size);
}
EOF

gcc -shared -fPIC mymalloc.c -o mymalloc.so -ldl
LD_PRELOAD=./mymalloc.so ls  # Traces all malloc calls
</code></pre>
<h3 id="lazy-binding"><a class="header" href="#lazy-binding">Lazy Binding</a></h3>
<p>Functions are resolved on first call, not at load time:</p>
<pre><code class="language-bash"># Immediate binding (resolve all symbols at load)
LD_BIND_NOW=1 ./program

# Check binding
readelf -d program | grep BIND_NOW
</code></pre>
<hr>
<h2 id="process-lifecycle"><a class="header" href="#process-lifecycle">Process Lifecycle</a></h2>
<h3 id="process-creation"><a class="header" href="#process-creation">Process Creation</a></h3>
<pre><code>Parent Process
      |
      | fork()
      |
      +---&gt; Creates copy
      |
   Parent            Child
   (returns          (returns
    child PID)        0)
</code></pre>
<h3 id="process-states"><a class="header" href="#process-states">Process States</a></h3>
<p>A process transitions through several states:</p>
<pre><code>                   fork()
    [New] ────────────────&gt; [Ready]
                                │
                                │ Scheduler selects
                                ↓
    [Terminated] &lt;──────── [Running] ────────&gt; [Waiting/Blocked]
                   exit()       ↑                    │
                                │                    │ I/O complete,
                                │                    │ event occurs
                                └────────────────────┘
</code></pre>
<p><strong>States:</strong></p>
<ul>
<li><strong>R (Running/Runnable)</strong>: Executing or waiting for CPU</li>
<li><strong>S (Sleeping)</strong>: Waiting for an event (interruptible)</li>
<li><strong>D (Disk Sleep)</strong>: Waiting for I/O (uninterruptible)</li>
<li><strong>T (Stopped)</strong>: Stopped by signal (SIGSTOP, SIGTSTP)</li>
<li><strong>Z (Zombie)</strong>: Terminated but not reaped by parent</li>
<li><strong>I (Idle)</strong>: Kernel thread</li>
</ul>
<pre><code class="language-bash"># View process state
ps aux | awk '{print $8, $11}'
# S     /usr/bin/bash
# R+    ps aux
</code></pre>
<hr>
<h2 id="process-operations"><a class="header" href="#process-operations">Process Operations</a></h2>
<h3 id="fork---create-child-process"><a class="header" href="#fork---create-child-process">fork() - Create Child Process</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

pid_t pid = fork();

if (pid &lt; 0) {
    // Fork failed
    perror("fork");
    exit(1);
} else if (pid == 0) {
    // Child process
    printf("Child: PID=%d, PPID=%d\n", getpid(), getppid());
} else {
    // Parent process
    printf("Parent: PID=%d, Child PID=%d\n", getpid(), pid);
}
</code></pre>
<p><strong>What fork() copies:</strong></p>
<ul>
<li>✅ Code (shared, copy-on-write)</li>
<li>✅ Stack (copied)</li>
<li>✅ Heap (copied)</li>
<li>✅ Data/BSS (copied)</li>
<li>✅ File descriptors (shared)</li>
<li>✅ Signal handlers (copied)</li>
<li>❌ PID (different)</li>
<li>❌ PPID (different)</li>
<li>❌ Locks (not inherited)</li>
</ul>
<h3 id="vfork---fast-fork"><a class="header" href="#vfork---fast-fork">vfork() - Fast Fork</a></h3>
<pre><code class="language-c">pid_t pid = vfork();

if (pid == 0) {
    // Child: Don't modify memory!
    // Parent is suspended, memory is shared
    execve("/bin/ls", args, env);
    _exit(1);  // If exec fails
}
// Parent resumes here
</code></pre>
<p><strong>vfork() vs fork():</strong></p>
<ul>
<li>vfork(): Child shares memory with parent (no copy-on-write)</li>
<li>Parent is suspended until child calls <code>exec()</code> or <code>_exit()</code></li>
<li>Faster but dangerous (easy to corrupt parent’s memory)</li>
</ul>
<h3 id="clone---create-threadprocess"><a class="header" href="#clone---create-threadprocess">clone() - Create Thread/Process</a></h3>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;sched.h&gt;

// Low-level system call
// fork() and pthread_create() use clone() internally

int clone(int (*fn)(void *), void *stack, int flags, void *arg);

// Flags determine what's shared:
// CLONE_VM: Share memory
// CLONE_FS: Share filesystem info
// CLONE_FILES: Share file descriptors
// CLONE_SIGHAND: Share signal handlers
// CLONE_THREAD: Place in same thread group
</code></pre>
<h3 id="exec-family---replace-process-image"><a class="header" href="#exec-family---replace-process-image">exec() Family - Replace Process Image</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;

// Replace current process with new program
execl("/bin/ls", "ls", "-l", NULL);
execv("/bin/ls", args);
execle("/bin/ls", "ls", "-l", NULL, envp);
execve("/bin/ls", args, envp);  // System call
execlp("ls", "ls", "-l", NULL);  // Search PATH
execvp("ls", args);              // Search PATH

// If exec succeeds, this line never executes
perror("exec failed");
</code></pre>
<p><strong>Common pattern: fork() + exec()</strong></p>
<pre><code class="language-c">pid_t pid = fork();

if (pid == 0) {
    // Child: execute new program
    execl("/bin/date", "date", NULL);
    perror("exec failed");
    exit(1);
}

// Parent continues
wait(NULL);
</code></pre>
<h3 id="exit---terminate-process"><a class="header" href="#exit---terminate-process">exit() - Terminate Process</a></h3>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

// Normal termination (calls atexit handlers, flushes buffers)
exit(0);

// Immediate termination (no cleanup)
_exit(0);

// Register cleanup function
atexit(cleanup_func);
</code></pre>
<h3 id="wait--waitpid---wait-for-child"><a class="header" href="#wait--waitpid---wait-for-child">wait() / waitpid() - Wait for Child</a></h3>
<pre><code class="language-c">#include &lt;sys/wait.h&gt;

// Wait for any child
int status;
pid_t child_pid = wait(&amp;status);

// Wait for specific child
pid_t pid = waitpid(child_pid, &amp;status, 0);

// Non-blocking wait
pid_t pid = waitpid(-1, &amp;status, WNOHANG);

// Check exit status
if (WIFEXITED(status)) {
    printf("Exit code: %d\n", WEXITSTATUS(status));
}
if (WIFSIGNALED(status)) {
    printf("Killed by signal: %d\n", WTERMSIG(status));
}
</code></pre>
<p><strong>Zombie prevention:</strong></p>
<pre><code class="language-c">// Method 1: wait() for children
while (wait(NULL) &gt; 0);

// Method 2: Ignore SIGCHLD
signal(SIGCHLD, SIG_IGN);

// Method 3: Handle SIGCHLD
void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) &gt; 0);
}
signal(SIGCHLD, sigchld_handler);
</code></pre>
<h3 id="process-priority"><a class="header" href="#process-priority">Process Priority</a></h3>
<pre><code class="language-c">#include &lt;sys/resource.h&gt;

// Get/set nice value (-20 to 19, lower = higher priority)
int nice_val = getpriority(PRIO_PROCESS, 0);
setpriority(PRIO_PROCESS, 0, 10);  // Needs privilege for &lt;0

// Nice command
nice -n 10 ./program     // Run with lower priority
renice -n 5 -p 12345     // Change priority of running process
</code></pre>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<pre><code class="language-c">#include &lt;signal.h&gt;

// Send signal
kill(pid, SIGTERM);   // To process
kill(-pgid, SIGTERM); // To process group
killpg(pgid, SIGTERM); // To process group

// Signal handler
void handler(int sig) {
    printf("Received signal %d\n", sig);
}

signal(SIGINT, handler);      // Simple
sigaction(SIGINT, &amp;act, NULL); // Advanced

// Common signals:
// SIGINT (2): Interrupt (Ctrl+C)
// SIGKILL (9): Kill (uncatchable)
// SIGTERM (15): Terminate
// SIGSTOP (19): Stop (uncatchable)
// SIGCONT (18): Continue
// SIGCHLD (17): Child terminated
</code></pre>
<hr>
<h2 id="process-states-1"><a class="header" href="#process-states-1">Process States</a></h2>
<h3 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h3>
<pre><code class="language-bash"># View state in real-time
top
htop

# Process state codes
ps aux
# D    Uninterruptible sleep (usually I/O)
# R    Running or runnable (on run queue)
# S    Interruptible sleep (waiting for event)
# T    Stopped (job control or debugger)
# W    Paging (not valid since 2.6.xx)
# X    Dead (should never be seen)
# Z    Zombie (terminated but not reaped)
# &lt;    High priority
# N    Low priority
# L    Has pages locked into memory
# s    Is session leader
# l    Is multi-threaded
# +    In foreground process group
</code></pre>
<h3 id="uninterruptible-sleep-d"><a class="header" href="#uninterruptible-sleep-d">Uninterruptible Sleep (D)</a></h3>
<pre><code class="language-bash"># Find processes in D state
ps aux | awk '$8 ~ /D/ {print}'

# Common causes:
# - Waiting for disk I/O
# - NFS hangs
# - Hardware issues

# Cannot be killed with SIGKILL!
</code></pre>
<h3 id="zombie-processes"><a class="header" href="#zombie-processes">Zombie Processes</a></h3>
<pre><code class="language-bash"># Find zombies
ps aux | awk '$8 ~ /Z/ {print}'

# Parent's responsibility to reap
# If parent doesn't call wait(), child becomes zombie
# If parent dies, init adopts and reaps zombie

# Force parent to reap (send SIGCHLD)
kill -CHLD $PPID
</code></pre>
<hr>
<h2 id="process-management-tools"><a class="header" href="#process-management-tools">Process Management Tools</a></h2>
<h3 id="ps---process-status"><a class="header" href="#ps---process-status">ps - Process Status</a></h3>
<pre><code class="language-bash"># Most common usages
ps aux                   # All processes, user-oriented
ps -ef                   # All processes, full format
ps -eLf                  # Include threads
ps -p 1234               # Specific process
ps -u username           # User's processes
ps --forest              # Tree view
ps -o pid,ppid,cmd       # Custom columns

# Sort by CPU/memory
ps aux --sort=-%cpu | head
ps aux --sort=-%mem | head

# Watch specific process
watch -n 1 'ps -p 1234 -o pid,pcpu,pmem,cmd'
</code></pre>
<h3 id="top--htop---interactive-monitor"><a class="header" href="#top--htop---interactive-monitor">top / htop - Interactive Monitor</a></h3>
<pre><code class="language-bash"># top
top
# Keys:
#   M: Sort by memory
#   P: Sort by CPU
#   k: Kill process
#   r: Renice process
#   1: Show individual CPUs
#   H: Show threads

# htop (more user-friendly)
htop
# Mouse-clickable
# F5: Tree view
# F6: Sort
# F9: Kill
</code></pre>
<h3 id="pgrep--pkill---searchkill-by-name"><a class="header" href="#pgrep--pkill---searchkill-by-name">pgrep / pkill - Search/Kill by Name</a></h3>
<pre><code class="language-bash"># Find processes
pgrep firefox            # Print PIDs
pgrep -l firefox         # Print PIDs and names
pgrep -u username        # User's processes
pgrep -f "pattern"       # Match full command line

# Kill processes
pkill firefox            # Kill by name
pkill -9 firefox         # Force kill
pkill -u username        # Kill user's processes
</code></pre>
<h3 id="pstree---process-tree"><a class="header" href="#pstree---process-tree">pstree - Process Tree</a></h3>
<pre><code class="language-bash"># View process hierarchy
pstree
pstree -p              # Show PIDs
pstree -p 1234         # Tree from specific process
pstree -s 1234         # Show parents

# Example output:
# systemd─┬─sshd───sshd───bash───vim
#         ├─apache2───10*[apache2]
#         └─nginx───4*[nginx]
</code></pre>
<h3 id="pidof---find-pid-by-name"><a class="header" href="#pidof---find-pid-by-name">pidof - Find PID by Name</a></h3>
<pre><code class="language-bash">pidof firefox
pidof -s firefox      # Single PID only
</code></pre>
<h3 id="lsof---list-open-files"><a class="header" href="#lsof---list-open-files">lsof - List Open Files</a></h3>
<pre><code class="language-bash"># Files opened by process
lsof -p 1234

# Processes with file open
lsof /var/log/syslog

# Network connections
lsof -i                # All
lsof -i :80           # Port 80
lsof -i TCP:80        # TCP port 80
lsof -i @192.168.1.1  # Remote host

# By user
lsof -u username
</code></pre>
<h3 id="strace---trace-system-calls"><a class="header" href="#strace---trace-system-calls">strace - Trace System Calls</a></h3>
<pre><code class="language-bash"># Trace system calls
strace ./program
strace -p 1234        # Attach to running process

# Trace specific calls
strace -e open,read,write ./program
strace -e trace=network ./program
strace -e trace=process ./program

# Count calls
strace -c ./program

# Timestamp
strace -t ./program
strace -tt ./program  # Microseconds
strace -T ./program   # Time spent in each call

# Save to file
strace -o trace.log ./program

# Trace child processes
strace -f ./program
</code></pre>
<h3 id="ltrace---trace-library-calls"><a class="header" href="#ltrace---trace-library-calls">ltrace - Trace Library Calls</a></h3>
<pre><code class="language-bash"># Trace library calls
ltrace ./program
ltrace -p 1234

# Specific library
ltrace -l libssl.so ./program

# Count calls
ltrace -c ./program
</code></pre>
<h3 id="gdb---debugger"><a class="header" href="#gdb---debugger">gdb - Debugger</a></h3>
<pre><code class="language-bash"># Debug program
gdb ./program
gdb -p 1234           # Attach to running process

# Common commands
(gdb) run             # Start program
(gdb) break main      # Set breakpoint
(gdb) continue        # Continue execution
(gdb) next            # Step over
(gdb) step            # Step into
(gdb) backtrace       # Stack trace
(gdb) info threads    # List threads
(gdb) thread 2        # Switch to thread
(gdb) print var       # Print variable
(gdb) info proc mappings  # Memory map
</code></pre>
<h3 id="proc-filesystem"><a class="header" href="#proc-filesystem">/proc Filesystem</a></h3>
<p>See <a href="#proc-filesystem">/proc Filesystem</a> section.</p>
<hr>
<h2 id="proc-filesystem-1"><a class="header" href="#proc-filesystem-1">/proc Filesystem</a></h2>
<p>Virtual filesystem providing process and system information.</p>
<h3 id="process-information"><a class="header" href="#process-information">Process Information</a></h3>
<pre><code class="language-bash"># Process directory: /proc/[pid]/

# Command line arguments
cat /proc/$$/cmdline | tr '\0' ' '

# Environment variables
cat /proc/$$/environ | tr '\0' '\n'

# Current working directory
ls -l /proc/$$/cwd

# Executable
ls -l /proc/$$/exe

# File descriptors
ls -l /proc/$$/fd/
# 0 -&gt; /dev/pts/0 (stdin)
# 1 -&gt; /dev/pts/0 (stdout)
# 2 -&gt; /dev/pts/0 (stderr)

# Memory maps
cat /proc/$$/maps

# Memory statistics
cat /proc/$$/status
cat /proc/$$/statm

# System calls
cat /proc/$$/syscall

# Limits
cat /proc/$$/limits

# Stack trace
cat /proc/$$/stack

# Open files
ls -l /proc/$$/fd/

# Mount points
cat /proc/$$/mountinfo

# Namespace
ls -l /proc/$$/ns/
</code></pre>
<h3 id="procpidstatus"><a class="header" href="#procpidstatus">/proc/[pid]/status</a></h3>
<pre><code class="language-bash">cat /proc/$$/status

# Key fields:
# Name: Process name
# State: Current state
# Tgid: Thread group ID
# Pid: Process ID
# PPid: Parent PID
# Uid: Real, Effective, Saved, Filesystem UIDs
# Gid: Real, Effective, Saved, Filesystem GIDs
# VmSize: Virtual memory size
# VmRSS: Resident Set Size (physical memory)
# VmData: Size of data segment
# VmStk: Size of stack
# VmExe: Size of text (code)
# VmLib: Shared library size
# Threads: Number of threads
# voluntary_ctxt_switches: Voluntary context switches
# nonvoluntary_ctxt_switches: Involuntary context switches
</code></pre>
<h3 id="procpidmaps"><a class="header" href="#procpidmaps">/proc/[pid]/maps</a></h3>
<pre><code class="language-bash">cat /proc/$$/maps

# Format:
# address           perms offset  dev   inode   pathname
# 00400000-00401000 r-xp 00000000 08:01 123     /bin/bash

# Permissions:
# r: Read
# w: Write
# x: Execute
# p: Private (copy-on-write)
# s: Shared

# Special regions:
# [heap]
# [stack]
# [vdso]  - Virtual Dynamic Shared Object
# [vvar]  - Virtual variables
</code></pre>
<h3 id="system-wide-information"><a class="header" href="#system-wide-information">System-wide Information</a></h3>
<pre><code class="language-bash"># CPU info
cat /proc/cpuinfo

# Memory info
cat /proc/meminfo

# Load average
cat /proc/loadavg

# Uptime
cat /proc/uptime

# Kernel version
cat /proc/version

# Filesystems
cat /proc/filesystems

# Devices
cat /proc/devices

# Interrupts
cat /proc/interrupts

# I/O ports
cat /proc/ioports

# Network
cat /proc/net/tcp
cat /proc/net/udp
cat /proc/net/unix
cat /proc/net/dev

# Block devices
cat /proc/diskstats
</code></pre>
<hr>
<h2 id="inter-process-communication"><a class="header" href="#inter-process-communication">Inter-Process Communication</a></h2>
<h3 id="pipes"><a class="header" href="#pipes">Pipes</a></h3>
<pre><code class="language-bash"># Anonymous pipe (shell)
ls | grep txt

# In C
int pipefd[2];
pipe(pipefd);
// pipefd[0]: read end
// pipefd[1]: write end
</code></pre>
<h3 id="named-pipes-fifos"><a class="header" href="#named-pipes-fifos">Named Pipes (FIFOs)</a></h3>
<pre><code class="language-bash"># Create FIFO
mkfifo /tmp/mypipe

# Writer
echo "Hello" &gt; /tmp/mypipe &amp;

# Reader
cat /tmp/mypipe
</code></pre>
<h3 id="message-queues"><a class="header" href="#message-queues">Message Queues</a></h3>
<pre><code class="language-c">#include &lt;sys/msg.h&gt;

// Create queue
int msgid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);

// Send
struct msgbuf {
    long mtype;
    char mtext[100];
};
msgsnd(msgid, &amp;msg, sizeof(msg.mtext), 0);

// Receive
msgrcv(msgid, &amp;msg, sizeof(msg.mtext), 1, 0);

// Delete
msgctl(msgid, IPC_RMID, NULL);
</code></pre>
<pre><code class="language-bash"># View message queues
ipcs -q

# Remove queue
ipcrm -q &lt;msqid&gt;
</code></pre>
<h3 id="shared-memory"><a class="header" href="#shared-memory">Shared Memory</a></h3>
<pre><code class="language-c">#include &lt;sys/shm.h&gt;

// Create shared memory
int shmid = shmget(IPC_PRIVATE, 4096, 0666 | IPC_CREAT);

// Attach
char* ptr = shmat(shmid, NULL, 0);

// Use
strcpy(ptr, "Hello");

// Detach
shmdt(ptr);

// Delete
shmctl(shmid, IPC_RMID, NULL);
</code></pre>
<pre><code class="language-bash"># View shared memory
ipcs -m

# Remove shared memory
ipcrm -m &lt;shmid&gt;
</code></pre>
<h3 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h3>
<pre><code class="language-c">#include &lt;sys/sem.h&gt;

// Create semaphore
int semid = semget(IPC_PRIVATE, 1, 0666 | IPC_CREAT);

// Initialize
semctl(semid, 0, SETVAL, 1);

// P (wait/acquire)
struct sembuf sb = {0, -1, 0};
semop(semid, &amp;sb, 1);

// V (signal/release)
sb.sem_op = 1;
semop(semid, &amp;sb, 1);

// Delete
semctl(semid, 0, IPC_RMID);
</code></pre>
<h3 id="sockets"><a class="header" href="#sockets">Sockets</a></h3>
<pre><code class="language-c">// See src/linux/networking.md for details

// Unix domain socket (local IPC)
int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

// Internet socket
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
</code></pre>
<h3 id="signals-1"><a class="header" href="#signals-1">Signals</a></h3>
<p>See <a href="#signals">Signals</a> section.</p>
<hr>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="copy-on-write-cow"><a class="header" href="#copy-on-write-cow">Copy-on-Write (COW)</a></h3>
<p>After <code>fork()</code>, parent and child share memory pages:</p>
<pre><code>Before fork():
Parent: [Page A]

After fork():
Parent: [Page A] ←─┐
                   │ Both point to same physical page
Child:  [Page A] ←─┘

After write by child:
Parent: [Page A]    ← Original page
Child:  [Page A']   ← New copy
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Fast fork() - no immediate copying</li>
<li>Memory efficient - copy only modified pages</li>
<li>View COW in action:</li>
</ul>
<pre><code class="language-bash"># Before fork
cat /proc/$$/status | grep VmRSS

# After fork (child shares memory)
# VmRSS doesn't double

# After child modifies memory
# VmRSS increases
</code></pre>
<h3 id="virtual-memory"><a class="header" href="#virtual-memory">Virtual Memory</a></h3>
<p>Process sees contiguous virtual address space:</p>
<pre><code>Virtual Address Space         Physical Memory
┌────────────────┐            ┌────────────────┐
│  0xFFFFFFFF    │            │                │
│                │   ┌────────│  Frame 1234    │
│  [Stack]       │───┘        ├────────────────┤
│                │            │                │
│  ...           │   ┌────────│  Frame 5678    │
│  [Heap]        │───┘        ├────────────────┤
│                │            │                │
│  [Data/BSS]    │───┐        │  Frame 9012    │
│                │   └────────├────────────────┤
│  [Text]        │───┐        │                │
│  0x00000000    │   └────────│  Frame 3456    │
└────────────────┘            └────────────────┘

Page Table translates Virtual → Physical
</code></pre>
<p><strong>Page size:</strong></p>
<pre><code class="language-bash">getconf PAGE_SIZE    # Usually 4096 bytes (4 KB)
</code></pre>
<h3 id="context-switching"><a class="header" href="#context-switching">Context Switching</a></h3>
<p>When CPU switches between processes:</p>
<ol>
<li>
<p><strong>Save context</strong> of current process:</p>
<ul>
<li>Registers (PC, SP, etc.)</li>
<li>Process state</li>
</ul>
</li>
<li>
<p><strong>Load context</strong> of next process:</p>
<ul>
<li>Restore registers</li>
<li>Switch page tables</li>
<li>Update kernel structures</li>
</ul>
</li>
</ol>
<p><strong>Cost:</strong> Several microseconds</p>
<pre><code class="language-bash"># Context switches per second
vmstat 1
# cs column shows context switches

# Per-process context switches
cat /proc/$$/status | grep ctxt
</code></pre>
<h3 id="process-scheduling"><a class="header" href="#process-scheduling">Process Scheduling</a></h3>
<p>Linux uses Completely Fair Scheduler (CFS):</p>
<pre><code class="language-bash"># View scheduler
cat /proc/$$/sched

# Scheduling policies:
# SCHED_NORMAL (0): Default time-sharing
# SCHED_FIFO (1): Real-time FIFO
# SCHED_RR (2): Real-time round-robin
# SCHED_BATCH (3): Batch processing
# SCHED_IDLE (5): Very low priority

# Set policy
chrt -f 10 ./program     # FIFO, priority 10
chrt -r 10 ./program     # Round-robin
</code></pre>
<h3 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h3>
<p>Isolate processes (used by containers):</p>
<pre><code class="language-bash"># Namespace types:
# - mnt: Mount points
# - pid: Process IDs
# - net: Network stack
# - ipc: IPC resources
# - uts: Hostname
# - user: User/group IDs
# - cgroup: Control groups

# View namespaces
ls -l /proc/$$/ns/

# Create namespace
unshare --pid --fork --mount-proc bash
# Now in new PID namespace, ps shows only local processes

# Enter namespace
nsenter -t &lt;pid&gt; -a  # All namespaces
</code></pre>
<h3 id="control-groups-cgroups"><a class="header" href="#control-groups-cgroups">Control Groups (cgroups)</a></h3>
<p>Limit/prioritize resources:</p>
<pre><code class="language-bash"># v1 location
ls /sys/fs/cgroup/

# v2 location
ls /sys/fs/cgroup/unified/

# Create cgroup
mkdir /sys/fs/cgroup/memory/mygroup

# Set memory limit (100 MB)
echo 104857600 &gt; /sys/fs/cgroup/memory/mygroup/memory.limit_in_bytes

# Add process to cgroup
echo $$ &gt; /sys/fs/cgroup/memory/mygroup/cgroup.procs

# View cgroup of process
cat /proc/$$/cgroup
</code></pre>
<h3 id="daemon-processes"><a class="header" href="#daemon-processes">Daemon Processes</a></h3>
<p>Background services:</p>
<pre><code class="language-c">// Daemonization steps
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

void daemonize() {
    // 1. Fork and exit parent
    pid_t pid = fork();
    if (pid &gt; 0) exit(0);

    // 2. Create new session
    setsid();

    // 3. Fork again (prevent controlling terminal)
    pid = fork();
    if (pid &gt; 0) exit(0);

    // 4. Change directory
    chdir("/");

    // 5. Close file descriptors
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // 6. Set umask
    umask(0);

    // 7. Open log file
    open("/var/log/mydaemon.log", O_WRONLY|O_CREAT, 0644);
}
</code></pre>
<pre><code class="language-bash"># Modern way (systemd)
systemctl start mydaemon
systemctl enable mydaemon
</code></pre>
<hr>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="example-1-memory-layout-viewer"><a class="header" href="#example-1-memory-layout-viewer">Example 1: Memory Layout Viewer</a></h3>
<pre><code class="language-c">// memory_layout.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int global_init = 42;           // Data segment
int global_uninit;              // BSS segment
const int const_data = 100;     // Read-only data

void print_addresses() {
    int stack_var;                 // Stack
    int* heap_ptr = malloc(10);    // Heap

    printf("=== Memory Layout ===\n");
    printf("Text (function):    %p\n", (void*)print_addresses);
    printf("Data (initialized): %p\n", (void*)&amp;global_init);
    printf("BSS (uninitialized):%p\n", (void*)&amp;global_uninit);
    printf("Heap:               %p\n", (void*)heap_ptr);
    printf("Stack:              %p\n", (void*)&amp;stack_var);
    printf("===================\n");

    free(heap_ptr);
}

int main() {
    printf("PID: %d\n", getpid());
    print_addresses();
    printf("\nCheck: cat /proc/%d/maps\n", getpid());
    sleep(30);  // Keep process alive
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc memory_layout.c -o memory_layout
./memory_layout &amp;
cat /proc/$(pgrep memory_layout)/maps
</code></pre>
<h3 id="example-2-fork-and-exec"><a class="header" href="#example-2-fork-and-exec">Example 2: Fork and Exec</a></h3>
<pre><code class="language-c">// fork_exec.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    printf("Parent PID: %d\n", getpid());

    pid_t pid = fork();

    if (pid &lt; 0) {
        perror("fork");
        exit(1);
    } else if (pid == 0) {
        // Child process
        printf("Child PID: %d, PPID: %d\n", getpid(), getppid());

        // Execute new program
        char* args[] = {"ls", "-l", NULL};
        execvp("ls", args);

        // Only reached if exec fails
        perror("exec");
        exit(1);
    } else {
        // Parent process
        printf("Parent created child: %d\n", pid);

        // Wait for child
        int status;
        waitpid(pid, &amp;status, 0);

        if (WIFEXITED(status)) {
            printf("Child exited with status: %d\n",
                   WEXITSTATUS(status));
        }
    }

    return 0;
}
</code></pre>
<h3 id="example-3-pipe-communication"><a class="header" href="#example-3-pipe-communication">Example 3: Pipe Communication</a></h3>
<pre><code class="language-c">// pipe_example.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main() {
    int pipefd[2];
    char buffer[100];

    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(1);
    }

    pid_t pid = fork();

    if (pid == 0) {
        // Child: writer
        close(pipefd[0]);  // Close read end
        char* msg = "Hello from child!";
        write(pipefd[1], msg, strlen(msg) + 1);
        close(pipefd[1]);
        exit(0);
    } else {
        // Parent: reader
        close(pipefd[1]);  // Close write end
        read(pipefd[0], buffer, sizeof(buffer));
        printf("Parent received: %s\n", buffer);
        close(pipefd[0]);
        wait(NULL);
    }

    return 0;
}
</code></pre>
<h3 id="example-4-shared-memory"><a class="header" href="#example-4-shared-memory">Example 4: Shared Memory</a></h3>
<pre><code class="language-c">// shm_example.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main() {
    int shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT | 0666);

    pid_t pid = fork();

    if (pid == 0) {
        // Child: writer
        char* ptr = shmat(shmid, NULL, 0);
        strcpy(ptr, "Shared memory message!");
        shmdt(ptr);
        exit(0);
    } else {
        // Parent: reader
        wait(NULL);
        char* ptr = shmat(shmid, NULL, 0);
        printf("Read from shared memory: %s\n", ptr);
        shmdt(ptr);
        shmctl(shmid, IPC_RMID, NULL);
    }

    return 0;
}
</code></pre>
<h3 id="example-5-process-monitor"><a class="header" href="#example-5-process-monitor">Example 5: Process Monitor</a></h3>
<pre><code class="language-bash">#!/bin/bash
# process_monitor.sh

PID=$1

if [ -z "$PID" ]; then
    echo "Usage: $0 &lt;pid&gt;"
    exit 1
fi

echo "Monitoring PID: $PID"
echo "================================"

while kill -0 $PID 2&gt;/dev/null; do
    clear
    echo "=== Process Info ==="
    ps -p $PID -o pid,ppid,state,pcpu,pmem,vsz,rss,cmd

    echo -e "\n=== Memory Details ==="
    cat /proc/$PID/status | grep -E "VmSize|VmRSS|VmData|VmStk|VmExe"

    echo -e "\n=== Open Files ==="
    ls -l /proc/$PID/fd/ 2&gt;/dev/null | wc -l

    echo -e "\n=== Threads ==="
    ls /proc/$PID/task/ 2&gt;/dev/null | wc -l

    echo -e "\n=== Context Switches ==="
    cat /proc/$PID/status | grep ctxt

    sleep 2
done

echo "Process $PID terminated"
</code></pre>
<h3 id="example-6-signal-handling"><a class="header" href="#example-6-signal-handling">Example 6: Signal Handling</a></h3>
<pre><code class="language-c">// signal_example.c
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

volatile sig_atomic_t keep_running = 1;

void signal_handler(int signum) {
    if (signum == SIGINT) {
        printf("\nReceived SIGINT (Ctrl+C)\n");
        keep_running = 0;
    } else if (signum == SIGTERM) {
        printf("\nReceived SIGTERM\n");
        keep_running = 0;
    }
}

int main() {
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    printf("PID: %d\n", getpid());
    printf("Press Ctrl+C to stop\n");

    while (keep_running) {
        printf("Running...\n");
        sleep(1);
    }

    printf("Exiting gracefully\n");
    return 0;
}
</code></pre>
<hr>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h3>
<ol>
<li>
<p><strong>Process Components:</strong></p>
<ul>
<li>Code (text), Data, BSS, Heap (dynamic), Stack (local vars)</li>
<li>PID, PPID, PGID, SID for identification</li>
<li>Shared objects for dynamic linking</li>
</ul>
</li>
<li>
<p><strong>Memory Management:</strong></p>
<ul>
<li>Stack: Automatic, grows down, fast, limited size</li>
<li>Heap: Manual, grows up, flexible, slower</li>
<li>Virtual memory with page tables</li>
<li>Copy-on-write optimization</li>
</ul>
</li>
<li>
<p><strong>Process Operations:</strong></p>
<ul>
<li><code>fork()</code>: Create child process</li>
<li><code>exec()</code>: Replace process image</li>
<li><code>wait()</code>: Wait for child termination</li>
<li><code>exit()</code>: Terminate process</li>
</ul>
</li>
<li>
<p><strong>IPC Mechanisms:</strong></p>
<ul>
<li>Pipes, message queues, shared memory</li>
<li>Semaphores, sockets, signals</li>
</ul>
</li>
<li>
<p><strong>Tools:</strong></p>
<ul>
<li><code>ps</code>, <code>top</code>, <code>htop</code>: Process monitoring</li>
<li><code>strace</code>, <code>ltrace</code>: System/library call tracing</li>
<li><code>/proc</code> filesystem: Process introspection</li>
<li><code>lsof</code>: Open files and connections</li>
</ul>
</li>
<li>
<p><strong>Advanced:</strong></p>
<ul>
<li>Namespaces: Process isolation</li>
<li>cgroups: Resource limiting</li>
<li>Scheduling policies and priorities</li>
</ul>
</li>
</ol>
<hr>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><code>man 2 fork</code></li>
<li><code>man 2 exec</code></li>
<li><code>man 2 wait</code></li>
<li><code>man 7 signal</code></li>
<li><code>man 5 proc</code></li>
<li><a href="https://www.kernel.org/doc/Documentation/">Linux Kernel Documentation</a></li>
<li><a href="http://man7.org/tlpi/">The Linux Programming Interface</a> by Michael Kerrisk</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/udev.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../linux/wireguard.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/udev.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../linux/wireguard.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
