# cfg80211 and mac80211

Linux wireless subsystem frameworks for 802.11 (WiFi) device drivers and configuration.

## Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [cfg80211](#cfg80211)
- [mac80211](#mac80211)
- [Driver Development](#driver-development)
- [nl80211](#nl80211)
- [Regulatory Framework](#regulatory-framework)
- [Power Management](#power-management)
- [Scanning](#scanning)
- [Connection Management](#connection-management)
- [Mesh Networking](#mesh-networking)
- [Debugging](#debugging)

---

## Overview

The Linux wireless stack consists of two main components:

- **cfg80211**: Configuration API and regulatory database for 802.11 devices
- **mac80211**: Generic IEEE 802.11 MAC layer implementation

### Why Two Layers?

```
┌─────────────────────────────────────┐
│        User Space (iw, wpa_supplicant)  │
└─────────────────────────────────────┘
              │ nl80211
┌─────────────────────────────────────┐
│          cfg80211                    │  ← Configuration & regulatory
│   (wireless configuration API)       │
└─────────────────────────────────────┘
              │
┌─────────────────────────────────────┐
│          mac80211                    │  ← MAC layer (optional)
│   (generic MAC implementation)       │
└─────────────────────────────────────┘
              │
┌─────────────────────────────────────┐
│      WiFi Device Driver              │  ← Hardware-specific
│   (ath9k, iwlwifi, rtl8xxxu, etc.)  │
└─────────────────────────────────────┘
              │
┌─────────────────────────────────────┐
│      Hardware (WiFi Chip)            │
└─────────────────────────────────────┘
```

**cfg80211** is mandatory for all wireless drivers. It provides:
- Configuration interface via nl80211
- Regulatory domain management
- Scanning coordination
- Authentication/association state machine

**mac80211** is optional and provides a generic MAC layer implementation for devices that only implement hardware-specific functions (PHY layer). Drivers can choose to:
1. Use mac80211 (most SoftMAC drivers: ath9k, iwlwifi, rtl8xxxu)
2. Implement their own MAC (FullMAC drivers: brcmfmac, mwifiex)

---

## Architecture

### Layer Responsibilities

```
User Space
    │
    ├─ iw: Configuration tool
    ├─ wpa_supplicant: WPA/WPA2 authentication
    └─ hostapd: Access Point daemon
    │
    ▼ nl80211 (netlink)
    │
cfg80211
    │
    ├─ Configuration API
    ├─ Regulatory database
    ├─ Scan results management
    ├─ Connection tracking
    └─ nl80211 ↔ cfg80211_ops translation
    │
    ▼ cfg80211_ops
    │
mac80211 (optional)
    │
    ├─ Beacon handling
    ├─ Power save
    ├─ Aggregation (A-MPDU/A-MSDU)
    ├─ Rate control
    ├─ TX/RX queuing
    └─ Frame filtering
    │
    ▼ ieee80211_ops
    │
Driver (hardware-specific)
    │
    ├─ Channel switching
    ├─ TX/RX DMA
    ├─ Interrupt handling
    └─ Register access
    │
    ▼
Hardware
```

### Data Flow

**TX Path:**
```
Application
    ↓
Socket/Network Stack
    ↓
cfg80211 (for management frames)
    ↓
mac80211 (encryption, aggregation, queuing)
    ↓
Driver (DMA, hardware TX)
    ↓
Hardware
```

**RX Path:**
```
Hardware
    ↓
Driver (interrupt, DMA)
    ↓
mac80211 (decryption, defragmentation)
    ↓
cfg80211 (scan results, regulatory info)
    ↓
Network Stack
    ↓
Application
```

---

## cfg80211

### Core Concepts

cfg80211 is the configuration API for 802.11 devices. It abstracts hardware differences and provides a unified interface.

### Key Data Structures

```c
#include <net/cfg80211.h>

/* Wireless device (wiphy) - represents physical device */
struct wiphy {
	int n_addresses;
	struct mac_address *addresses;

	/* Supported bands */
	struct ieee80211_supported_band *bands[NUM_NL80211_BANDS];

	/* Regulatory domain */
	const struct ieee80211_regdomain *regd;

	/* Driver callbacks */
	const struct cfg80211_ops *ops;

	/* Flags */
	u32 flags;

	/* Interface modes supported */
	u16 interface_modes;

	/* Cipher suites */
	const u32 *cipher_suites;
	int n_cipher_suites;

	/* Maximum scan SSIDs */
	u8 max_scan_ssids;

	/* Maximum scheduled scan SSIDs */
	u8 max_sched_scan_ssids;

	/* Private driver data */
	void *priv;
};

/* Wireless interface (wdev) - represents virtual interface */
struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;

	struct net_device *netdev;

	/* Current BSS */
	struct cfg80211_bss *current_bss;

	/* Connection parameters */
	u8 ssid[IEEE80211_MAX_SSID_LEN];
	u8 ssid_len;

	/* Wireless extensions compatibility */
	struct cfg80211_internal_bss *authtry_bsses[4];
	struct cfg80211_internal_bss *auth_bsses[4];
	struct cfg80211_internal_bss *assoc_bsses[4];
};

/* BSS information */
struct cfg80211_bss {
	struct ieee80211_channel *channel;

	u8 bssid[ETH_ALEN];
	u64 tsf;
	u16 beacon_interval;
	u16 capability;

	const u8 *ies;
	size_t ies_len;

	s32 signal;
	u64 parent_tsf;
};
```

### cfg80211_ops - Driver Callbacks

```c
struct cfg80211_ops {
	/* Interface management */
	int (*add_virtual_intf)(struct wiphy *wiphy,
				const char *name,
				enum nl80211_iftype type,
				struct vif_params *params);

	int (*del_virtual_intf)(struct wiphy *wiphy,
				struct wireless_dev *wdev);

	int (*change_virtual_intf)(struct wiphy *wiphy,
				   struct net_device *dev,
				   enum nl80211_iftype type,
				   struct vif_params *params);

	/* Scanning */
	int (*scan)(struct wiphy *wiphy,
		    struct cfg80211_scan_request *request);

	/* Connection */
	int (*connect)(struct wiphy *wiphy,
		       struct net_device *dev,
		       struct cfg80211_connect_params *sme);

	int (*disconnect)(struct wiphy *wiphy,
			  struct net_device *dev,
			  u16 reason_code);

	/* Authentication & Association */
	int (*auth)(struct wiphy *wiphy,
		    struct net_device *dev,
		    struct cfg80211_auth_request *req);

	int (*assoc)(struct wiphy *wiphy,
		     struct net_device *dev,
		     struct cfg80211_assoc_request *req);

	int (*deauth)(struct wiphy *wiphy,
		      struct net_device *dev,
		      struct cfg80211_deauth_request *req);

	int (*disassoc)(struct wiphy *wiphy,
			struct net_device *dev,
			struct cfg80211_disassoc_request *req);

	/* Configuration */
	int (*set_channel)(struct wiphy *wiphy,
			   struct cfg80211_chan_def *chandef);

	int (*set_txq_params)(struct wiphy *wiphy,
			      struct net_device *dev,
			      struct ieee80211_txq_params *params);

	int (*set_tx_power)(struct wiphy *wiphy,
			    struct wireless_dev *wdev,
			    enum nl80211_tx_power_setting type,
			    int mbm);

	int (*get_tx_power)(struct wiphy *wiphy,
			    struct wireless_dev *wdev,
			    int *dbm);

	/* AP mode */
	int (*start_ap)(struct wiphy *wiphy,
			struct net_device *dev,
			struct cfg80211_ap_settings *settings);

	int (*stop_ap)(struct wiphy *wiphy,
		       struct net_device *dev);

	/* Station management */
	int (*add_station)(struct wiphy *wiphy,
			   struct net_device *dev,
			   const u8 *mac,
			   struct station_parameters *params);

	int (*del_station)(struct wiphy *wiphy,
			   struct net_device *dev,
			   struct station_del_parameters *params);

	int (*change_station)(struct wiphy *wiphy,
			      struct net_device *dev,
			      const u8 *mac,
			      struct station_parameters *params);

	int (*get_station)(struct wiphy *wiphy,
			   struct net_device *dev,
			   const u8 *mac,
			   struct station_info *sinfo);

	/* Power management */
	int (*set_power_mgmt)(struct wiphy *wiphy,
			      struct net_device *dev,
			      bool enabled,
			      int timeout);

	/* Regulatory */
	void (*reg_notifier)(struct wiphy *wiphy,
			     struct regulatory_request *request);
};
```

### Registering a Wiphy

```c
#include <net/cfg80211.h>

static const struct cfg80211_ops my_cfg_ops = {
	.scan = my_scan,
	.connect = my_connect,
	.disconnect = my_disconnect,
	/* ... other callbacks ... */
};

static int my_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
	struct wiphy *wiphy;
	struct my_priv *priv;
	int ret;

	/* Allocate wiphy with private data */
	wiphy = wiphy_new(&my_cfg_ops, sizeof(*priv));
	if (!wiphy)
		return -ENOMEM;

	priv = wiphy_priv(wiphy);

	/* Set wiphy parameters */
	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
				 BIT(NL80211_IFTYPE_AP);

	wiphy->max_scan_ssids = 4;
	wiphy->max_scan_ie_len = 256;

	/* Set supported bands */
	wiphy->bands[NL80211_BAND_2GHZ] = &my_band_2ghz;
	wiphy->bands[NL80211_BAND_5GHZ] = &my_band_5ghz;

	/* Set supported cipher suites */
	wiphy->cipher_suites = my_cipher_suites;
	wiphy->n_cipher_suites = ARRAY_SIZE(my_cipher_suites);

	/* Set regulatory domain */
	wiphy->regulatory_flags = REGULATORY_STRICT_REG;

	/* Register wiphy */
	ret = wiphy_register(wiphy);
	if (ret) {
		wiphy_free(wiphy);
		return ret;
	}

	return 0;
}

static void my_remove(struct pci_dev *pdev)
{
	struct wiphy *wiphy = pci_get_drvdata(pdev);

	wiphy_unregister(wiphy);
	wiphy_free(wiphy);
}
```

### Band and Channel Definition

```c
/* 2.4 GHz band channels */
static struct ieee80211_channel my_2ghz_channels[] = {
	{ .band = NL80211_BAND_2GHZ, .center_freq = 2412, .hw_value = 1 },
	{ .band = NL80211_BAND_2GHZ, .center_freq = 2417, .hw_value = 2 },
	{ .band = NL80211_BAND_2GHZ, .center_freq = 2422, .hw_value = 3 },
	/* ... channels 4-13 ... */
};

/* Supported rates for 2.4 GHz */
static struct ieee80211_rate my_2ghz_rates[] = {
	{ .bitrate = 10 },   /* 1 Mbps */
	{ .bitrate = 20 },   /* 2 Mbps */
	{ .bitrate = 55 },   /* 5.5 Mbps */
	{ .bitrate = 110 },  /* 11 Mbps */
	{ .bitrate = 60 },   /* 6 Mbps */
	{ .bitrate = 90 },   /* 9 Mbps */
	{ .bitrate = 120 },  /* 12 Mbps */
	/* ... more rates ... */
};

/* 2.4 GHz band definition */
static struct ieee80211_supported_band my_band_2ghz = {
	.channels = my_2ghz_channels,
	.n_channels = ARRAY_SIZE(my_2ghz_channels),
	.bitrates = my_2ghz_rates,
	.n_bitrates = ARRAY_SIZE(my_2ghz_rates),
	.ht_cap = {
		.cap = IEEE80211_HT_CAP_SGI_20 |
		       IEEE80211_HT_CAP_SGI_40 |
		       IEEE80211_HT_CAP_SUP_WIDTH_20_40,
		.ht_supported = true,
	},
};
```

---

## mac80211

### Overview

mac80211 is a framework for SoftMAC 802.11 drivers. It implements the MAC layer so drivers only need to implement hardware-specific operations.

### Key Features

- **Frame handling**: Beacon, probe, authentication, association
- **Encryption**: WEP, TKIP, CCMP (AES)
- **Power save**: PS-Poll, U-APSD
- **Aggregation**: A-MPDU, A-MSDU
- **Rate control**: Minstrel, Minstrel HT
- **Quality of Service**: WMM/802.11e
- **Block ACK**: Aggregation acknowledgment

### Core Data Structures

```c
#include <net/mac80211.h>

/* Hardware structure */
struct ieee80211_hw {
	struct ieee80211_conf conf;
	struct wiphy *wiphy;
	const char *rate_control_algorithm;
	void *priv;
	unsigned long flags;

	/* Queues */
	u16 queues;
	u16 max_listen_interval;
	s8 max_signal;

	/* TX aggregation */
	u8 max_rx_aggregation_subframes;
	u8 max_tx_aggregation_subframes;

	/* Offload capabilities */
	u32 offchannel_tx_hw_queue;
	netdev_features_t netdev_features;
};

/* Virtual interface (VIF) */
struct ieee80211_vif {
	enum nl80211_iftype type;
	struct ieee80211_bss_conf bss_conf;
	u8 addr[ETH_ALEN];
	bool p2p;

	/* Driver private data */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

/* BSS configuration */
struct ieee80211_bss_conf {
	u8 bssid[ETH_ALEN];
	bool assoc;
	u16 aid;

	bool use_cts_prot;
	bool use_short_preamble;
	bool use_short_slot;
	bool enable_beacon;

	u16 beacon_int;
	u8 dtim_period;

	u32 basic_rates;
	u32 beacon_rate;

	struct ieee80211_p2p_noa_attr p2p_noa_attr;
};

/* Station information */
struct ieee80211_sta {
	u8 addr[ETH_ALEN];
	u16 aid;
	u16 max_amsdu_len;

	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;

	u8 max_sp;
	u8 rx_nss;

	/* Driver private data */
	u8 drv_priv[0] __aligned(sizeof(void *));
};

/* TX info - attached to each TX skb */
struct ieee80211_tx_info {
	u32 flags;
	u8 band;

	struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];

	union {
		struct {
			struct ieee80211_vif *vif;
			struct ieee80211_key_conf *hw_key;
		} control;
		struct {
			u64 cookie;
		} ack;
		struct {
			struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];
			u8 ack_signal;
		} status;
	};
};

/* RX status - filled by driver */
struct ieee80211_rx_status {
	u64 mactime;
	u32 device_timestamp;
	u16 flag;
	u16 freq;
	u8 rate_idx;
	u8 vht_nss;
	u8 rx_flags;
	u8 band;
	u8 antenna;
	s8 signal;
	u8 chains;
	s8 chain_signal[IEEE80211_MAX_CHAINS];
};
```

### ieee80211_ops - Driver Operations

```c
struct ieee80211_ops {
	/* Basic operations */
	int (*start)(struct ieee80211_hw *hw);
	void (*stop)(struct ieee80211_hw *hw);

	/* Interface handling */
	int (*add_interface)(struct ieee80211_hw *hw,
			     struct ieee80211_vif *vif);
	void (*remove_interface)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif);

	/* Configuration */
	int (*config)(struct ieee80211_hw *hw, u32 changed);
	void (*bss_info_changed)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct ieee80211_bss_conf *info,
				 u32 changed);

	/* TX/RX */
	void (*tx)(struct ieee80211_hw *hw,
		   struct ieee80211_tx_control *control,
		   struct sk_buff *skb);

	int (*set_key)(struct ieee80211_hw *hw,
		       enum set_key_cmd cmd,
		       struct ieee80211_vif *vif,
		       struct ieee80211_sta *sta,
		       struct ieee80211_key_conf *key);

	/* Scanning */
	void (*sw_scan_start)(struct ieee80211_hw *hw,
			      struct ieee80211_vif *vif,
			      const u8 *mac_addr);
	void (*sw_scan_complete)(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif);

	int (*hw_scan)(struct ieee80211_hw *hw,
		       struct ieee80211_vif *vif,
		       struct ieee80211_scan_request *req);

	/* Aggregation */
	int (*ampdu_action)(struct ieee80211_hw *hw,
			    struct ieee80211_vif *vif,
			    struct ieee80211_ampdu_params *params);

	/* Station management */
	int (*sta_add)(struct ieee80211_hw *hw,
		       struct ieee80211_vif *vif,
		       struct ieee80211_sta *sta);

	int (*sta_remove)(struct ieee80211_hw *hw,
			  struct ieee80211_vif *vif,
			  struct ieee80211_sta *sta);

	void (*sta_notify)(struct ieee80211_hw *hw,
			   struct ieee80211_vif *vif,
			   enum sta_notify_cmd cmd,
			   struct ieee80211_sta *sta);

	/* Power management */
	int (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);
	void (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);

	/* Multicast filter */
	void (*configure_filter)(struct ieee80211_hw *hw,
				 unsigned int changed_flags,
				 unsigned int *total_flags,
				 u64 multicast);
};
```

### Registering with mac80211

```c
static const struct ieee80211_ops my_ops = {
	.start = my_start,
	.stop = my_stop,
	.add_interface = my_add_interface,
	.remove_interface = my_remove_interface,
	.config = my_config,
	.bss_info_changed = my_bss_info_changed,
	.tx = my_tx,
	.set_key = my_set_key,
	/* ... */
};

static int my_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
	struct ieee80211_hw *hw;
	struct my_priv *priv;
	int ret;

	/* Allocate hardware structure */
	hw = ieee80211_alloc_hw(sizeof(*priv), &my_ops);
	if (!hw)
		return -ENOMEM;

	priv = hw->priv;
	priv->pdev = pdev;

	/* Set hardware capabilities */
	hw->flags = IEEE80211_HW_SIGNAL_DBM |
		    IEEE80211_HW_AMPDU_AGGREGATION |
		    IEEE80211_HW_SUPPORTS_PS |
		    IEEE80211_HW_MFP_CAPABLE;

	hw->queues = 4;  /* Number of TX queues */
	hw->max_rates = 4;
	hw->max_rate_tries = 7;

	/* Set channel bands */
	hw->wiphy->bands[NL80211_BAND_2GHZ] = &my_band_2ghz;
	hw->wiphy->bands[NL80211_BAND_5GHZ] = &my_band_5ghz;

	/* Set supported interface modes */
	hw->wiphy->interface_modes =
		BIT(NL80211_IFTYPE_STATION) |
		BIT(NL80211_IFTYPE_AP) |
		BIT(NL80211_IFTYPE_P2P_CLIENT) |
		BIT(NL80211_IFTYPE_P2P_GO);

	/* Register hardware */
	ret = ieee80211_register_hw(hw);
	if (ret) {
		ieee80211_free_hw(hw);
		return ret;
	}

	return 0;
}
```

### TX Path Implementation

```c
static void my_tx(struct ieee80211_hw *hw,
		  struct ieee80211_tx_control *control,
		  struct sk_buff *skb)
{
	struct my_priv *priv = hw->priv;
	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;

	/* Get TX rate from mac80211 rate control */
	u8 rate_idx = info->control.rates[0].idx;

	/* Determine hardware queue */
	u8 queue = skb_get_queue_mapping(skb);

	/* Add hardware-specific TX descriptor */
	struct my_tx_desc *desc = (struct my_tx_desc *)skb_push(skb, sizeof(*desc));
	memset(desc, 0, sizeof(*desc));

	desc->rate = rate_idx;
	desc->retry_limit = info->control.rates[0].count;

	/* Handle encryption if needed */
	if (info->control.hw_key) {
		/* Hardware encryption */
		desc->key_idx = info->control.hw_key->hw_key_idx;
		desc->flags |= TX_FLAGS_ENCRYPT;
	}

	/* Submit to hardware TX queue */
	spin_lock_bh(&priv->tx_lock);

	if (my_tx_queue_full(priv, queue)) {
		/* Queue full, stop mac80211 queue */
		ieee80211_stop_queue(hw, queue);
		spin_unlock_bh(&priv->tx_lock);
		dev_kfree_skb_any(skb);
		return;
	}

	/* Add to DMA ring */
	my_tx_add_to_ring(priv, queue, skb);

	/* Kick hardware */
	my_tx_kick(priv, queue);

	spin_unlock_bh(&priv->tx_lock);
}

/* TX completion interrupt handler */
static void my_tx_complete(struct my_priv *priv)
{
	struct ieee80211_hw *hw = priv->hw;
	struct sk_buff *skb;
	struct ieee80211_tx_info *info;
	u8 queue;

	while ((skb = my_get_completed_frame(priv, &queue))) {
		info = IEEE80211_SKB_CB(skb);

		/* Fill in TX status */
		if (my_tx_was_successful(skb)) {
			info->flags |= IEEE80211_TX_STAT_ACK;
		}

		/* Remove hardware TX descriptor */
		skb_pull(skb, sizeof(struct my_tx_desc));

		/* Report to mac80211 */
		ieee80211_tx_status(hw, skb);

		/* Wake queue if needed */
		if (ieee80211_queue_stopped(hw, queue))
			ieee80211_wake_queue(hw, queue);
	}
}
```

### RX Path Implementation

```c
static void my_rx_tasklet(unsigned long data)
{
	struct my_priv *priv = (struct my_priv *)data;
	struct ieee80211_hw *hw = priv->hw;
	struct sk_buff *skb;
	struct ieee80211_rx_status *rx_status;
	struct my_rx_desc *desc;

	while ((skb = my_get_rx_frame(priv))) {
		desc = (struct my_rx_desc *)skb->data;

		/* Allocate rx_status */
		rx_status = IEEE80211_SKB_RXCB(skb);
		memset(rx_status, 0, sizeof(*rx_status));

		/* Fill in RX status from hardware descriptor */
		rx_status->freq = ieee80211_channel_to_frequency(
					desc->channel,
					NL80211_BAND_2GHZ);
		rx_status->band = NL80211_BAND_2GHZ;
		rx_status->signal = desc->rssi;
		rx_status->rate_idx = desc->rate;
		rx_status->antenna = desc->antenna;

		/* Set flags */
		if (desc->flags & RX_FLAG_SHORT_PREAMBLE)
			rx_status->flag |= RX_FLAG_SHORTPRE;

		if (desc->flags & RX_FLAG_DECRYPTED) {
			rx_status->flag |= RX_FLAG_DECRYPTED;
			rx_status->flag |= RX_FLAG_IV_STRIPPED;
			rx_status->flag |= RX_FLAG_MMIC_STRIPPED;
		}

		/* Remove hardware RX descriptor */
		skb_pull(skb, sizeof(*desc));

		/* Pass to mac80211 */
		ieee80211_rx(hw, skb);
	}
}
```

---

## Driver Development

### FullMAC Driver Example

FullMAC drivers implement their own MAC and only use cfg80211.

```c
#include <net/cfg80211.h>

/* FullMAC driver - implements own MAC */
static int my_fullmac_scan(struct wiphy *wiphy,
			   struct cfg80211_scan_request *request)
{
	struct my_priv *priv = wiphy_priv(wiphy);
	int i;

	/* Send scan command to firmware */
	for (i = 0; i < request->n_ssids; i++) {
		my_fw_scan_ssid(priv,
				request->ssids[i].ssid,
				request->ssids[i].ssid_len);
	}

	for (i = 0; i < request->n_channels; i++) {
		my_fw_scan_channel(priv,
				   request->channels[i]->center_freq);
	}

	my_fw_start_scan(priv);

	return 0;
}

/* Firmware event: scan result */
static void my_handle_scan_result(struct my_priv *priv,
				   struct my_scan_result *result)
{
	struct wiphy *wiphy = priv->wiphy;
	struct cfg80211_bss *bss;
	struct ieee80211_channel *channel;
	struct cfg80211_inform_bss data = {};

	channel = ieee80211_get_channel(wiphy, result->frequency);
	if (!channel)
		return;

	/* Inform cfg80211 about BSS */
	bss = cfg80211_inform_bss_data(
		wiphy,
		&data,
		CFG80211_BSS_FTYPE_UNKNOWN,
		result->bssid,
		result->tsf,
		result->capability,
		result->beacon_interval,
		result->ie,
		result->ie_len,
		result->signal,
		GFP_KERNEL);

	cfg80211_put_bss(wiphy, bss);
}

/* Firmware event: scan complete */
static void my_handle_scan_complete(struct my_priv *priv)
{
	struct cfg80211_scan_info info = {
		.aborted = false,
	};

	cfg80211_scan_done(priv->scan_request, &info);
	priv->scan_request = NULL;
}

/* Connect */
static int my_fullmac_connect(struct wiphy *wiphy,
			      struct net_device *dev,
			      struct cfg80211_connect_params *sme)
{
	struct my_priv *priv = wiphy_priv(wiphy);

	/* Send connect command to firmware */
	my_fw_connect(priv,
		      sme->ssid, sme->ssid_len,
		      sme->bssid,
		      sme->channel,
		      sme->auth_type);

	return 0;
}

/* Firmware event: connected */
static void my_handle_connected(struct my_priv *priv)
{
	cfg80211_connect_result(priv->dev,
				priv->bssid,
				NULL, 0,
				NULL, 0,
				WLAN_STATUS_SUCCESS,
				GFP_KERNEL);
}

/* Firmware event: disconnected */
static void my_handle_disconnected(struct my_priv *priv, u16 reason)
{
	cfg80211_disconnected(priv->dev, reason, NULL, 0, true, GFP_KERNEL);
}
```

### SoftMAC Driver Example

SoftMAC drivers use mac80211 for MAC implementation.

```c
#include <net/mac80211.h>

static int my_softmac_start(struct ieee80211_hw *hw)
{
	struct my_priv *priv = hw->priv;

	/* Power on hardware */
	my_hw_power_on(priv);

	/* Load firmware if needed */
	my_load_firmware(priv);

	/* Initialize hardware */
	my_hw_init(priv);

	/* Enable interrupts */
	my_enable_interrupts(priv);

	return 0;
}

static void my_softmac_stop(struct ieee80211_hw *hw)
{
	struct my_priv *priv = hw->priv;

	/* Disable interrupts */
	my_disable_interrupts(priv);

	/* Shutdown hardware */
	my_hw_shutdown(priv);

	/* Power off */
	my_hw_power_off(priv);
}

static int my_softmac_add_interface(struct ieee80211_hw *hw,
				    struct ieee80211_vif *vif)
{
	struct my_priv *priv = hw->priv;

	/* Set MAC address */
	my_hw_set_mac_address(priv, vif->addr);

	/* Set interface type */
	switch (vif->type) {
	case NL80211_IFTYPE_STATION:
		my_hw_set_mode(priv, MODE_STA);
		break;
	case NL80211_IFTYPE_AP:
		my_hw_set_mode(priv, MODE_AP);
		break;
	default:
		return -EOPNOTSUPP;
	}

	return 0;
}

static void my_softmac_bss_info_changed(struct ieee80211_hw *hw,
					struct ieee80211_vif *vif,
					struct ieee80211_bss_conf *info,
					u32 changed)
{
	struct my_priv *priv = hw->priv;

	if (changed & BSS_CHANGED_BSSID) {
		/* BSSID changed */
		my_hw_set_bssid(priv, info->bssid);
	}

	if (changed & BSS_CHANGED_ASSOC) {
		if (info->assoc) {
			/* Associated */
			my_hw_set_associated(priv, true);
			my_hw_set_aid(priv, info->aid);
		} else {
			/* Disassociated */
			my_hw_set_associated(priv, false);
		}
	}

	if (changed & BSS_CHANGED_BEACON_INT) {
		/* Beacon interval changed */
		my_hw_set_beacon_interval(priv, info->beacon_int);
	}

	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
		/* CTS protection changed */
		my_hw_set_cts_protection(priv, info->use_cts_prot);
	}

	if (changed & BSS_CHANGED_ERP_SLOT) {
		/* Slot time changed */
		my_hw_set_short_slot(priv, info->use_short_slot);
	}
}

static int my_softmac_config(struct ieee80211_hw *hw, u32 changed)
{
	struct my_priv *priv = hw->priv;
	struct ieee80211_conf *conf = &hw->conf;

	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
		/* Channel changed */
		struct ieee80211_channel *chan = conf->chandef.chan;
		my_hw_set_channel(priv, chan->center_freq);
	}

	if (changed & IEEE80211_CONF_CHANGE_POWER) {
		/* TX power changed */
		my_hw_set_tx_power(priv, conf->power_level);
	}

	if (changed & IEEE80211_CONF_CHANGE_IDLE) {
		/* Idle state changed */
		if (conf->flags & IEEE80211_CONF_IDLE)
			my_hw_enter_idle(priv);
		else
			my_hw_exit_idle(priv);
	}

	return 0;
}
```

---

## nl80211

nl80211 is the netlink-based configuration interface for wireless devices.

### User Space Tools

```bash
# iw - nl80211 configuration utility

# List wireless devices
iw dev

# Scan for networks
iw dev wlan0 scan

# Connect to network
iw dev wlan0 connect MyNetwork

# Set channel
iw dev wlan0 set channel 6

# Set TX power
iw dev wlan0 set txpower fixed 2000  # 20 dBm

# Create AP
iw dev wlan0 set type __ap
ip link set wlan0 up
iw dev wlan0 set channel 6

# Monitor mode
iw dev wlan0 set type monitor
ip link set wlan0 up

# Station info
iw dev wlan0 station dump

# Link statistics
iw dev wlan0 link

# Survey (channel usage)
iw dev wlan0 survey dump
```

### nl80211 in Code

```c
#include <net/nl80211.h>

/* User space typically uses libnl */
#include <netlink/netlink.h>
#include <netlink/genl/genl.h>
#include <netlink/genl/ctrl.h>

/* Send scan request */
static int nl80211_scan(const char *ifname)
{
	struct nl_sock *sk;
	struct nl_msg *msg;
	int ret, family_id;

	sk = nl_socket_alloc();
	genl_connect(sk);

	family_id = genl_ctrl_resolve(sk, "nl80211");

	msg = nlmsg_alloc();
	genlmsg_put(msg, 0, 0, family_id, 0, 0, NL80211_CMD_TRIGGER_SCAN, 0);

	nla_put_u32(msg, NL80211_ATTR_IFINDEX, if_nametoindex(ifname));

	ret = nl_send_auto(sk, msg);
	nlmsg_free(msg);

	nl_socket_free(sk);

	return ret;
}
```

---

## Regulatory Framework

The regulatory framework enforces regional wireless regulations.

### Regulatory Database

```c
/* Regulatory domain definition */
static const struct ieee80211_regdomain my_regdom = {
	.n_reg_rules = 2,
	.alpha2 = "US",
	.reg_rules = {
		/* 2.4 GHz */
		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
		/* 5 GHz */
		REG_RULE(5180-10, 5320+10, 160, 6, 23, 0),
	}
};

/* Set regulatory domain */
static void my_set_regdom(struct wiphy *wiphy)
{
	regulatory_hint(wiphy, "US");
}

/* Regulatory notifier */
static void my_reg_notifier(struct wiphy *wiphy,
			    struct regulatory_request *request)
{
	struct my_priv *priv = wiphy_priv(wiphy);

	pr_info("Regulatory domain: %c%c\n",
		request->alpha2[0], request->alpha2[1]);

	/* Update hardware with new regulatory settings */
	my_hw_update_regulatory(priv, request);
}
```

### Country IE Handling

```c
/* Parse country IE from beacon */
static void my_parse_country_ie(struct my_priv *priv,
				const u8 *country_ie, size_t len)
{
	char alpha2[2];
	struct ieee80211_regdomain *rd;

	if (len < 6)
		return;

	/* Extract country code */
	alpha2[0] = country_ie[0];
	alpha2[1] = country_ie[1];

	/* Hint regulatory domain */
	regulatory_hint(priv->wiphy, alpha2);
}
```

---

## Power Management

### Station Power Save

```c
/* Enable power save */
static int my_set_power_mgmt(struct wiphy *wiphy,
			     struct net_device *dev,
			     bool enabled, int timeout)
{
	struct my_priv *priv = wiphy_priv(wiphy);

	if (enabled) {
		my_hw_enable_power_save(priv);
		my_hw_set_ps_timeout(priv, timeout);
	} else {
		my_hw_disable_power_save(priv);
	}

	return 0;
}

/* Handle beacon from AP (in power save mode) */
static void my_handle_beacon(struct my_priv *priv, struct sk_buff *skb)
{
	struct ieee80211_mgmt *mgmt = (void *)skb->data;
	u8 *tim_ie;
	bool has_buffered;

	/* Find TIM IE */
	tim_ie = my_find_ie(mgmt->u.beacon.variable,
			    skb->len - offsetof(struct ieee80211_mgmt,
						u.beacon.variable),
			    WLAN_EID_TIM);

	if (!tim_ie)
		return;

	/* Check if AP has buffered frames */
	has_buffered = my_check_tim(tim_ie, priv->aid);

	if (has_buffered) {
		/* Send PS-Poll to retrieve frames */
		my_send_pspoll(priv);
	}
}
```

### AP Power Save

```c
/* Client entered power save */
static void my_sta_ps_start(struct my_priv *priv, struct ieee80211_sta *sta)
{
	/* Mark station as sleeping */
	set_sta_flag(sta, WLAN_STA_PS_STA);

	/* Queue frames instead of transmitting */
}

/* Client exited power save */
static void my_sta_ps_end(struct my_priv *priv, struct ieee80211_sta *sta)
{
	/* Mark station as awake */
	clear_sta_flag(sta, WLAN_STA_PS_STA);

	/* Transmit buffered frames */
	my_deliver_buffered_frames(priv, sta);
}
```

---

## Scanning

### Active Scan

```c
/* Send probe request */
static void my_send_probe_req(struct my_priv *priv,
			      const u8 *ssid, size_t ssid_len,
			      u32 freq)
{
	struct sk_buff *skb;
	struct ieee80211_mgmt *mgmt;
	u8 *pos;

	skb = dev_alloc_skb(200);
	mgmt = (struct ieee80211_mgmt *)skb_put(skb,
		offsetof(struct ieee80211_mgmt, u.probe_req.variable));

	/* Fill in header */
	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
					  IEEE80211_STYPE_PROBE_REQ);
	eth_broadcast_addr(mgmt->da);
	memcpy(mgmt->sa, priv->mac_addr, ETH_ALEN);
	eth_broadcast_addr(mgmt->bssid);

	/* Add SSID IE */
	pos = skb_put(skb, 2 + ssid_len);
	*pos++ = WLAN_EID_SSID;
	*pos++ = ssid_len;
	memcpy(pos, ssid, ssid_len);

	/* Add supported rates IE */
	/* ... */

	/* Transmit */
	my_tx_mgmt_frame(priv, skb, freq);
}
```

### Passive Scan

```c
/* Listen for beacons on channel */
static void my_passive_scan_channel(struct my_priv *priv, u32 freq)
{
	/* Switch to channel */
	my_hw_set_channel(priv, freq);

	/* Wait for beacons (typically 100-200ms per channel) */
	msleep(100);

	/* Process received beacons in RX handler */
}
```

---

## Connection Management

### Station Connection Flow

```c
/* 1. Authentication */
static int my_authenticate(struct my_priv *priv,
			   const u8 *bssid,
			   enum nl80211_auth_type auth_type)
{
	struct sk_buff *skb;
	struct ieee80211_mgmt *mgmt;

	skb = dev_alloc_skb(256);
	mgmt = (struct ieee80211_mgmt *)skb_put(skb,
		offsetof(struct ieee80211_mgmt, u.auth.variable));

	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
					  IEEE80211_STYPE_AUTH);
	memcpy(mgmt->da, bssid, ETH_ALEN);
	memcpy(mgmt->sa, priv->mac_addr, ETH_ALEN);
	memcpy(mgmt->bssid, bssid, ETH_ALEN);

	mgmt->u.auth.auth_alg = cpu_to_le16(auth_type);
	mgmt->u.auth.auth_transaction = cpu_to_le16(1);
	mgmt->u.auth.status_code = 0;

	my_tx_mgmt_frame(priv, skb, priv->channel_freq);

	return 0;
}

/* 2. Handle authentication response */
static void my_handle_auth_resp(struct my_priv *priv, struct sk_buff *skb)
{
	struct ieee80211_mgmt *mgmt = (void *)skb->data;
	u16 status = le16_to_cpu(mgmt->u.auth.status_code);

	if (status == WLAN_STATUS_SUCCESS) {
		/* Authenticated, proceed to association */
		cfg80211_tx_mlme_mgmt(priv->dev, skb->data, skb->len);
		my_associate(priv, mgmt->bssid);
	} else {
		cfg80211_tx_mlme_mgmt(priv->dev, skb->data, skb->len);
	}
}

/* 3. Association */
static int my_associate(struct my_priv *priv, const u8 *bssid)
{
	struct sk_buff *skb;
	struct ieee80211_mgmt *mgmt;
	u8 *pos;

	skb = dev_alloc_skb(512);
	mgmt = (struct ieee80211_mgmt *)skb_put(skb,
		offsetof(struct ieee80211_mgmt, u.assoc_req.variable));

	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
					  IEEE80211_STYPE_ASSOC_REQ);
	memcpy(mgmt->da, bssid, ETH_ALEN);
	memcpy(mgmt->sa, priv->mac_addr, ETH_ALEN);
	memcpy(mgmt->bssid, bssid, ETH_ALEN);

	mgmt->u.assoc_req.capab_info = cpu_to_le16(WLAN_CAPABILITY_ESS);
	mgmt->u.assoc_req.listen_interval = cpu_to_le16(10);

	pos = mgmt->u.assoc_req.variable;

	/* Add SSID IE */
	/* Add supported rates IE */
	/* Add HT capabilities IE */
	/* Add VHT capabilities IE */
	/* ... */

	my_tx_mgmt_frame(priv, skb, priv->channel_freq);

	return 0;
}

/* 4. Handle association response */
static void my_handle_assoc_resp(struct my_priv *priv, struct sk_buff *skb)
{
	struct ieee80211_mgmt *mgmt = (void *)skb->data;
	u16 status = le16_to_cpu(mgmt->u.assoc_resp.status_code);
	u16 aid = le16_to_cpu(mgmt->u.assoc_resp.aid);

	if (status == WLAN_STATUS_SUCCESS) {
		priv->aid = aid & 0x3fff;
		cfg80211_connect_result(priv->dev,
					mgmt->bssid,
					NULL, 0, NULL, 0,
					status, GFP_KERNEL);
	} else {
		cfg80211_connect_result(priv->dev,
					mgmt->bssid,
					NULL, 0, NULL, 0,
					status, GFP_KERNEL);
	}
}
```

---

## Mesh Networking

```c
/* Start mesh interface */
static int my_join_mesh(struct wiphy *wiphy,
			struct net_device *dev,
			const struct mesh_config *conf,
			const struct mesh_setup *setup)
{
	struct my_priv *priv = wiphy_priv(wiphy);

	/* Set mesh ID */
	memcpy(priv->mesh_id, setup->mesh_id, setup->mesh_id_len);
	priv->mesh_id_len = setup->mesh_id_len;

	/* Enable mesh mode in hardware */
	my_hw_enable_mesh(priv);

	/* Start beaconing */
	my_start_mesh_beaconing(priv);

	return 0;
}

/* Handle mesh peering */
static void my_mesh_peer_open(struct my_priv *priv,
			      const u8 *peer_addr)
{
	/* Send peer link open frame */
	my_send_mesh_peering_frame(priv, peer_addr,
				    MESH_PEERING_OPEN);
}
```

---

## Debugging

### Enable cfg80211 Debug

```bash
# Enable cfg80211 debug messages
echo 'module cfg80211 +p' > /sys/kernel/debug/dynamic_debug/control

# Or at boot
cfg80211.debug=0xffffffff
```

### Enable mac80211 Debug

```bash
# Enable mac80211 debug
echo 'module mac80211 +p' > /sys/kernel/debug/dynamic_debug/control

# Or at module load
modprobe mac80211 debug=0xffffffff

# Debug categories (bitfield):
# 0x00000001 - INFO
# 0x00000002 - PS (power save)
# 0x00000004 - HT (high throughput)
# 0x00000008 - TX status
```

### Driver Debug

```c
/* Use dev_dbg for driver messages */
dev_dbg(&pdev->dev, "Channel: %d, Freq: %d\n", channel, freq);

/* Conditional debugging */
#ifdef DEBUG
#define my_dbg(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
#else
#define my_dbg(fmt, ...) no_printk(fmt, ##__VA_ARGS__)
#endif

/* Rate control debugging */
#ifdef CONFIG_MAC80211_RC_MINSTREL_DEBUGFS
/* Rate stats available in debugfs */
/* /sys/kernel/debug/ieee80211/phyX/netdev:wlanX/stations/<MAC>/rc_stats */
#endif
```

### Useful debugfs Entries

```bash
# List all wireless devices
ls /sys/kernel/debug/ieee80211/

# Per-PHY info
cat /sys/kernel/debug/ieee80211/phy0/hwflags
cat /sys/kernel/debug/ieee80211/phy0/queues

# Per-netdev info
ls /sys/kernel/debug/ieee80211/phy0/netdev:wlan0/

# Station info
ls /sys/kernel/debug/ieee80211/phy0/netdev:wlan0/stations/

# Rate control stats
cat /sys/kernel/debug/ieee80211/phy0/netdev:wlan0/stations/<MAC>/rc_stats

# Reset stats
echo 1 > /sys/kernel/debug/ieee80211/phy0/reset
```

### Packet Capture

```bash
# Monitor mode for packet capture
iw dev wlan0 set type monitor
ip link set wlan0 up
iw dev wlan0 set channel 6

# Capture with tcpdump
tcpdump -i wlan0 -w capture.pcap

# Or with wireshark
wireshark -i wlan0 -k
```

---

## Best Practices

### Driver Development

1. **Use mac80211 when possible**: Unless hardware has a full MAC, use mac80211
2. **Implement all required callbacks**: Check return values
3. **Handle errors gracefully**: Don't crash the kernel
4. **Test with multiple APs**: Different vendors, security types
5. **Support monitor mode**: Essential for debugging
6. **Implement regulatory**: Country codes, power limits
7. **Handle race conditions**: Use proper locking
8. **Clean up resources**: On errors and removal

### Performance

1. **Enable hardware offloads**: Encryption, aggregation
2. **Use DMA efficiently**: Minimize CPU involvement
3. **Implement rate control**: Or use mac80211's minstrel
4. **Support A-MPDU/A-MSDU**: For high throughput
5. **Optimize interrupt handling**: Use NAPI if possible
6. **Enable power save**: For battery-powered devices

### Security

1. **Never trust user input**: Validate all parameters
2. **Handle untrusted frames**: Check lengths, types
3. **Implement hardware encryption**: When available
4. **Support WPA3**: Modern security standards
5. **Protect management frames**: 802.11w (PMF)

---

## Resources

- **Kernel Documentation**: `Documentation/networking/mac80211.rst`
- **cfg80211 header**: `include/net/cfg80211.h`
- **mac80211 header**: `include/net/mac80211.h`
- **nl80211 header**: `include/uapi/linux/nl80211.h`
- **Example drivers**: `drivers/net/wireless/`
  - `ath/ath9k/` - mac80211 driver
  - `broadcom/brcm80211/brcmfmac/` - FullMAC driver
  - `intel/iwlwifi/` - Advanced mac80211 driver
- **iw tool source**: [https://git.kernel.org/pub/scm/linux/kernel/git/jberg/iw.git](https://git.kernel.org/pub/scm/linux/kernel/git/jberg/iw.git)
- **Regulatory database**: [https://git.kernel.org/pub/scm/linux/kernel/git/sforshee/wireless-regdb.git](https://git.kernel.org/pub/scm/linux/kernel/git/sforshee/wireless-regdb.git)

---

cfg80211 and mac80211 provide a robust framework for wireless driver development in Linux, handling much of the complex 802.11 protocol logic so drivers can focus on hardware-specific operations.
