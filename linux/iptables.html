<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IPTables - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="iptables"><a class="header" href="#iptables">iptables</a></h1>
<p>iptables is a user-space utility program that allows a system administrator to configure the IP packet filter rules of the Linux kernel firewall, implemented by the Netfilter project. It is a powerful tool for managing network traffic, implementing network address translation (NAT), and enhancing security through packet filtering and manipulation.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="tables"><a class="header" href="#tables">Tables</a></h3>
<p>iptables organizes rules into five different tables, each serving a specific purpose:</p>
<ol>
<li>
<p><strong>filter</strong> (default table)</p>
<ul>
<li>Purpose: Packet filtering (allow/deny traffic)</li>
<li>Chains: INPUT, OUTPUT, FORWARD</li>
<li>Most commonly used table for firewall rules</li>
</ul>
</li>
<li>
<p><strong>nat</strong></p>
<ul>
<li>Purpose: Network Address Translation</li>
<li>Chains: PREROUTING, POSTROUTING, OUTPUT</li>
<li>Used for: SNAT, DNAT, masquerading, port forwarding</li>
</ul>
</li>
<li>
<p><strong>mangle</strong></p>
<ul>
<li>Purpose: Packet alteration (modify packet headers)</li>
<li>Chains: PREROUTING, POSTROUTING, INPUT, OUTPUT, FORWARD</li>
<li>Used for: TOS, TTL modifications, marking packets</li>
</ul>
</li>
<li>
<p><strong>raw</strong></p>
<ul>
<li>Purpose: Connection tracking exemptions</li>
<li>Chains: PREROUTING, OUTPUT</li>
<li>Used to: Mark packets to bypass connection tracking (NOTRACK)</li>
</ul>
</li>
<li>
<p><strong>security</strong></p>
<ul>
<li>Purpose: Mandatory Access Control (MAC) rules</li>
<li>Chains: INPUT, OUTPUT, FORWARD</li>
<li>Used by: SELinux for security policies</li>
</ul>
</li>
</ol>
<h3 id="chains"><a class="header" href="#chains">Chains</a></h3>
<p>Chains are lists of rules that packets are checked against. Built-in chains:</p>
<ul>
<li><strong>INPUT</strong>: Packets destined for the local system</li>
<li><strong>OUTPUT</strong>: Packets generated by the local system</li>
<li><strong>FORWARD</strong>: Packets routed through the system</li>
<li><strong>PREROUTING</strong>: Packets before routing decision (nat, mangle, raw)</li>
<li><strong>POSTROUTING</strong>: Packets after routing decision (nat, mangle)</li>
</ul>
<h3 id="packet-flow"><a class="header" href="#packet-flow">Packet Flow</a></h3>
<pre><code>                               Incoming Packet
                                     |
                                     v
                            [PREROUTING (raw)]
                                     |
                                     v
                            [PREROUTING (mangle)]
                                     |
                                     v
                            [PREROUTING (nat)]
                                     |
                                     v
                            Routing Decision
                          /                  \
                         /                    \
                        v                      v
                  For Local                For Other
                   System                   System
                      |                        |
                      v                        v
               [INPUT (mangle)]         [FORWARD (mangle)]
                      |                        |
                      v                        v
               [INPUT (filter)]         [FORWARD (filter)]
                      |                        |
                      v                        v
               Local Process            Routing Decision
                      |                        |
                      v                        v
               [OUTPUT (raw)]          [POSTROUTING (mangle)]
                      |                        |
                      v                        v
               [OUTPUT (mangle)]       [POSTROUTING (nat)]
                      |                        |
                      v                        v
               [OUTPUT (nat)]           Outgoing Packet
                      |
                      v
               [OUTPUT (filter)]
                      |
                      v
              Routing Decision
                      |
                      v
         [POSTROUTING (mangle)]
                      |
                      v
         [POSTROUTING (nat)]
                      |
                      v
            Outgoing Packet
</code></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<ul>
<li><strong>Rules</strong>: Conditions and actions for packet processing</li>
<li><strong>Matches</strong>: Criteria for packet selection (IP, port, protocol, state, etc.)</li>
<li><strong>Targets</strong>: Actions to take when a packet matches a rule</li>
<li><strong>Policies</strong>: Default action when no rules match</li>
<li><strong>Connection Tracking</strong>: Stateful packet inspection using conntrack</li>
</ul>
<h2 id="targets-and-actions"><a class="header" href="#targets-and-actions">Targets and Actions</a></h2>
<h3 id="basic-targets"><a class="header" href="#basic-targets">Basic Targets</a></h3>
<ul>
<li><strong>ACCEPT</strong>: Allow the packet through</li>
<li><strong>DROP</strong>: Silently discard the packet (no response)</li>
<li><strong>REJECT</strong>: Discard packet and send error response</li>
<li><strong>LOG</strong>: Log the packet and continue processing</li>
<li><strong>RETURN</strong>: Return to the calling chain</li>
</ul>
<h3 id="nat-targets"><a class="header" href="#nat-targets">NAT Targets</a></h3>
<ul>
<li><strong>SNAT</strong>: Source NAT (modify source IP)</li>
<li><strong>DNAT</strong>: Destination NAT (modify destination IP)</li>
<li><strong>MASQUERADE</strong>: Dynamic SNAT (for dynamic IPs)</li>
<li><strong>REDIRECT</strong>: Redirect to local port</li>
</ul>
<h3 id="advanced-targets"><a class="header" href="#advanced-targets">Advanced Targets</a></h3>
<ul>
<li><strong>MARK</strong>: Mark packets for later processing</li>
<li><strong>TCPMSS</strong>: Modify TCP MSS value</li>
<li><strong>TOS</strong>: Modify Type of Service field</li>
<li><strong>TTL</strong>: Modify Time To Live field</li>
<li><strong>NOTRACK</strong>: Disable connection tracking</li>
<li><strong>QUEUE</strong>: Send to userspace for processing</li>
</ul>
<h2 id="match-criteria"><a class="header" href="#match-criteria">Match Criteria</a></h2>
<h3 id="basic-matches"><a class="header" href="#basic-matches">Basic Matches</a></h3>
<pre><code class="language-bash"># Source IP address
-s, --source 192.168.1.100
-s 192.168.1.0/24              # CIDR notation
-s 192.168.1.100,192.168.1.200 # Multiple IPs (with iprange)

# Destination IP address
-d, --destination 10.0.0.1

# Protocol
-p tcp
-p udp
-p icmp
-p all

# Input interface
-i eth0
-i eth+    # Match all eth interfaces

# Output interface
-o eth0

# Fragment packets
-f, --fragment
</code></pre>
<h3 id="protocol-specific-matches"><a class="header" href="#protocol-specific-matches">Protocol-Specific Matches</a></h3>
<pre><code class="language-bash"># TCP matches
--sport 80              # Source port
--dport 443             # Destination port
--tcp-flags SYN,ACK SYN # TCP flags
--syn                   # SYN packets (shorthand)

# UDP matches
--sport 53
--dport 53

# ICMP matches
--icmp-type echo-request
--icmp-type echo-reply
--icmp-type 8           # By number
</code></pre>
<h3 id="extended-matches"><a class="header" href="#extended-matches">Extended Matches</a></h3>
<pre><code class="language-bash"># Multiple ports (requires multiport module)
-m multiport --sports 80,443,8080
-m multiport --dports 20:22  # Port range

# IP ranges (requires iprange module)
-m iprange --src-range 192.168.1.100-192.168.1.200
-m iprange --dst-range 10.0.0.1-10.0.0.100

# MAC address
-m mac --mac-source 00:11:22:33:44:55

# Connection state
-m state --state NEW,ESTABLISHED,RELATED
-m conntrack --ctstate NEW,ESTABLISHED,RELATED,INVALID

# Rate limiting
-m limit --limit 5/min --limit-burst 10
-m hashlimit --hashlimit-above 10/sec --hashlimit-mode srcip

# Recent connections (track IPs)
-m recent --name SSH --rcheck --seconds 60

# Time-based rules
-m time --timestart 09:00 --timestop 17:00
-m time --weekdays Mon,Tue,Wed,Thu,Fri

# String matching
-m string --string "GET" --algo bm

# Connection limit
-m connlimit --connlimit-above 10 --connlimit-mask 32

# Owner (OUTPUT chain only)
-m owner --uid-owner 1000
-m owner --gid-owner www-data

# Comment (for documentation)
-m comment --comment "Allow HTTP traffic"
</code></pre>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="viewing-rules"><a class="header" href="#viewing-rules">Viewing Rules</a></h3>
<pre><code class="language-bash"># List all rules in all chains (filter table)
iptables -L
iptables -L -v              # Verbose (with packet/byte counters)
iptables -L -n              # Numeric (no DNS resolution)
iptables -L -v -n --line-numbers  # With line numbers

# List specific chain
iptables -L INPUT
iptables -L INPUT -v -n --line-numbers

# List all tables
iptables -t nat -L -v -n
iptables -t mangle -L -v -n

# Show rules as commands (easier to copy/modify)
iptables -S
iptables -S INPUT
iptables -t nat -S

# Show rules with packet counts
iptables -L -v -n -x  # -x for exact numbers (no K/M/G)
</code></pre>
<h3 id="adding-rules"><a class="header" href="#adding-rules">Adding Rules</a></h3>
<pre><code class="language-bash"># Append to end of chain (-A)
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Insert at specific position (-I)
iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT  # Insert as first rule
iptables -I INPUT 5 -p tcp --dport 443 -j ACCEPT # Insert as 5th rule

# Replace rule at position (-R)
iptables -R INPUT 3 -p tcp --dport 8080 -j ACCEPT
</code></pre>
<h3 id="deleting-rules"><a class="header" href="#deleting-rules">Deleting Rules</a></h3>
<pre><code class="language-bash"># Delete by specification
iptables -D INPUT -p tcp --dport 80 -j ACCEPT

# Delete by line number
iptables -D INPUT 5

# Delete all rules in chain
iptables -F INPUT           # Flush INPUT chain
iptables -F                 # Flush all chains in filter table
iptables -t nat -F          # Flush all chains in nat table

# Delete all rules in all tables
iptables -F
iptables -t nat -F
iptables -t mangle -F
iptables -t raw -F
</code></pre>
<h3 id="chain-management"><a class="header" href="#chain-management">Chain Management</a></h3>
<pre><code class="language-bash"># Create custom chain
iptables -N CUSTOM_CHAIN

# Delete custom chain (must be empty and unreferenced)
iptables -X CUSTOM_CHAIN

# Rename chain
iptables -E OLD_NAME NEW_NAME

# Zero packet/byte counters
iptables -Z                 # All chains
iptables -Z INPUT           # Specific chain
</code></pre>
<h3 id="policy-management"><a class="header" href="#policy-management">Policy Management</a></h3>
<pre><code class="language-bash"># Set default policy
iptables -P INPUT DROP      # Drop all input by default
iptables -P OUTPUT ACCEPT   # Accept all output by default
iptables -P FORWARD DROP    # Drop all forwarded traffic

# View current policies
iptables -L | grep policy
</code></pre>
<h3 id="save-and-restore"><a class="header" href="#save-and-restore">Save and Restore</a></h3>
<pre><code class="language-bash"># Save current rules
iptables-save &gt; /etc/iptables/rules.v4
iptables-save &gt; /tmp/iptables-backup.txt

# Save specific table
iptables-save -t nat &gt; /tmp/nat-rules.txt

# Restore rules
iptables-restore &lt; /etc/iptables/rules.v4

# Restore without flushing existing rules
iptables-restore -n &lt; /etc/iptables/rules.v4

# Test restore (don't actually apply)
iptables-restore -t &lt; /etc/iptables/rules.v4
</code></pre>
<h2 id="nat-operations"><a class="header" href="#nat-operations">NAT Operations</a></h2>
<h3 id="source-nat-snat"><a class="header" href="#source-nat-snat">Source NAT (SNAT)</a></h3>
<p>Change the source IP address of outgoing packets:</p>
<pre><code class="language-bash"># SNAT to specific IP
iptables -t nat -A POSTROUTING -o eth0 -s 192.168.1.0/24 -j SNAT --to-source 203.0.113.5

# SNAT with port range
iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 203.0.113.5-203.0.113.10

# SNAT with specific ports
iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 203.0.113.5:1024-65535
</code></pre>
<h3 id="masquerading"><a class="header" href="#masquerading">Masquerading</a></h3>
<p>Dynamic SNAT for connections with dynamic IPs (like DHCP):</p>
<pre><code class="language-bash"># Basic masquerading
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# Masquerade specific subnet
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp0 -j MASQUERADE

# Masquerade with port range
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE --to-ports 1024-65535
</code></pre>
<h3 id="destination-nat-dnat"><a class="header" href="#destination-nat-dnat">Destination NAT (DNAT)</a></h3>
<p>Change the destination IP address of incoming packets:</p>
<pre><code class="language-bash"># Port forwarding (external port 80 to internal server)
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100:80

# Forward to different port
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.100:80

# Load balancing (requires statistic module)
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode random --probability 0.5 -j DNAT --to-destination 192.168.1.100
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.101
</code></pre>
<h3 id="port-redirection"><a class="header" href="#port-redirection">Port Redirection</a></h3>
<p>Redirect packets to local port:</p>
<pre><code class="language-bash"># Redirect external port 80 to local port 8080
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080

# Redirect for specific interface
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080
</code></pre>
<h3 id="complete-natforwarding-setup"><a class="header" href="#complete-natforwarding-setup">Complete NAT/Forwarding Setup</a></h3>
<pre><code class="language-bash"># Enable IP forwarding
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
# Make permanent: add 'net.ipv4.ip_forward=1' to /etc/sysctl.conf

# Allow forwarding for established/related connections
iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Allow forwarding from internal network
iptables -A FORWARD -s 192.168.1.0/24 -j ACCEPT

# Masquerade outgoing traffic
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</code></pre>
<h2 id="connection-tracking-stateful-firewall"><a class="header" href="#connection-tracking-stateful-firewall">Connection Tracking (Stateful Firewall)</a></h2>
<p>Connection tracking allows iptables to maintain state information about connections:</p>
<h3 id="connection-states"><a class="header" href="#connection-states">Connection States</a></h3>
<ul>
<li><strong>NEW</strong>: First packet of a new connection</li>
<li><strong>ESTABLISHED</strong>: Part of an existing connection</li>
<li><strong>RELATED</strong>: Related to an existing connection (e.g., FTP data, ICMP errors)</li>
<li><strong>INVALID</strong>: Packet doesn't belong to any known connection</li>
<li><strong>UNTRACKED</strong>: Marked with NOTRACK target</li>
</ul>
<h3 id="stateful-firewall-pattern"><a class="header" href="#stateful-firewall-pattern">Stateful Firewall Pattern</a></h3>
<pre><code class="language-bash"># Allow established and related connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Drop invalid packets
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# Allow new connections only for specific services
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT
iptables -A INPUT -p tcp --dport 80 -m conntrack --ctstate NEW -j ACCEPT
</code></pre>
<h3 id="advanced-connection-tracking"><a class="header" href="#advanced-connection-tracking">Advanced Connection Tracking</a></h3>
<pre><code class="language-bash"># Track specific connection properties
-m conntrack --ctstate NEW,ESTABLISHED
-m conntrack --ctproto tcp
-m conntrack --ctorigsrc 192.168.1.0/24
-m conntrack --ctorigdst 10.0.0.1
-m conntrack --ctreplsrc 10.0.0.1
-m conntrack --ctrepldst 192.168.1.100
-m conntrack --ctexpire 60:120  # Connection age in seconds

# Connection tracking helpers (for protocols with dynamic ports)
modprobe nf_conntrack_ftp
modprobe nf_conntrack_sip
modprobe nf_conntrack_h323

# Disable tracking for high-traffic connections (performance)
iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK
iptables -t raw -A OUTPUT -p tcp --sport 80 -j NOTRACK
</code></pre>
<h2 id="common-firewall-patterns"><a class="header" href="#common-firewall-patterns">Common Firewall Patterns</a></h2>
<h3 id="basic-firewall-setup"><a class="header" href="#basic-firewall-setup">Basic Firewall Setup</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# Set default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Allow established and related
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Drop invalid packets
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# Allow SSH (be careful with this!)
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT

# Allow ping (ICMP)
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Log dropped packets (optional)
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables INPUT denied: " --log-level 7

# Final drop (redundant with policy, but explicit)
iptables -A INPUT -j DROP
</code></pre>
<h3 id="web-server-firewall"><a class="header" href="#web-server-firewall">Web Server Firewall</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Allow HTTP
iptables -A INPUT -p tcp --dport 80 -m conntrack --ctstate NEW -j ACCEPT

# Allow HTTPS
iptables -A INPUT -p tcp --dport 443 -m conntrack --ctstate NEW -j ACCEPT

# Allow HTTP/3 (QUIC over UDP)
iptables -A INPUT -p udp --dport 443 -m conntrack --ctstate NEW -j ACCEPT

# Rate limit HTTP connections (anti-DoS)
iptables -A INPUT -p tcp --dport 80 -m state --state NEW -m recent --set --name HTTP
iptables -A INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 60 --hitcount 20 --name HTTP -j DROP

# Limit concurrent connections per IP
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 32 -j REJECT --reject-with tcp-reset
</code></pre>
<h3 id="ssh-server-hardening"><a class="header" href="#ssh-server-hardening">SSH Server Hardening</a></h3>
<pre><code class="language-bash"># Allow SSH only from specific subnet
iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 22 -m conntrack --ctstate NEW -j ACCEPT

# SSH brute force protection (max 3 attempts per minute)
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 --rttl --name SSH -j LOG --log-prefix "SSH brute force: "
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 --rttl --name SSH -j DROP
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT

# Alternative: SSH port knocking (more complex, requires additional setup)
# See port knocking documentation for implementation
</code></pre>
<h3 id="dns-server"><a class="header" href="#dns-server">DNS Server</a></h3>
<pre><code class="language-bash"># Allow DNS queries (UDP, primary)
iptables -A INPUT -p udp --dport 53 -j ACCEPT

# Allow DNS over TCP (for zone transfers and large responses)
iptables -A INPUT -p tcp --dport 53 -j ACCEPT

# Rate limit DNS queries (anti-amplification attack)
iptables -A INPUT -p udp --dport 53 -m hashlimit --hashlimit-above 10/sec --hashlimit-mode srcip --hashlimit-name dns -j DROP
</code></pre>
<h3 id="database-server"><a class="header" href="#database-server">Database Server</a></h3>
<pre><code class="language-bash"># PostgreSQL from application servers only
iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 5432 -m conntrack --ctstate NEW -j ACCEPT

# MySQL from application servers only
iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 3306 -m conntrack --ctstate NEW -j ACCEPT

# MongoDB from application servers only
iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 27017 -m conntrack --ctstate NEW -j ACCEPT

# Limit connections per IP
iptables -A INPUT -p tcp --dport 5432 -m connlimit --connlimit-above 10 --connlimit-mask 32 -j REJECT
</code></pre>
<h3 id="mail-server"><a class="header" href="#mail-server">Mail Server</a></h3>
<pre><code class="language-bash"># SMTP
iptables -A INPUT -p tcp --dport 25 -m conntrack --ctstate NEW -j ACCEPT

# SMTP Submission
iptables -A INPUT -p tcp --dport 587 -m conntrack --ctstate NEW -j ACCEPT

# SMTP over SSL
iptables -A INPUT -p tcp --dport 465 -m conntrack --ctstate NEW -j ACCEPT

# IMAP
iptables -A INPUT -p tcp --dport 143 -m conntrack --ctstate NEW -j ACCEPT

# IMAPS
iptables -A INPUT -p tcp --dport 993 -m conntrack --ctstate NEW -j ACCEPT

# POP3
iptables -A INPUT -p tcp --dport 110 -m conntrack --ctstate NEW -j ACCEPT

# POP3S
iptables -A INPUT -p tcp --dport 995 -m conntrack --ctstate NEW -j ACCEPT

# Rate limit SMTP connections (anti-spam)
iptables -A INPUT -p tcp --dport 25 -m state --state NEW -m recent --set --name SMTP
iptables -A INPUT -p tcp --dport 25 -m state --state NEW -m recent --update --seconds 60 --hitcount 10 --name SMTP -j DROP
</code></pre>
<h2 id="security-patterns"><a class="header" href="#security-patterns">Security Patterns</a></h2>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<pre><code class="language-bash"># Limit new connections per second
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT

# Per-IP rate limiting with hashlimit
iptables -A INPUT -p tcp --dport 80 -m hashlimit --hashlimit-above 10/sec --hashlimit-mode srcip --hashlimit-name http -j DROP

# Connection rate limit per subnet
iptables -A INPUT -p tcp --dport 80 -m hashlimit --hashlimit-above 100/sec --hashlimit-mode srcip --hashlimit-srcmask 24 --hashlimit-name http_subnet -j DROP
</code></pre>
<h3 id="syn-flood-protection"><a class="header" href="#syn-flood-protection">SYN Flood Protection</a></h3>
<pre><code class="language-bash"># Limit SYN packets
iptables -A INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j ACCEPT
iptables -A INPUT -p tcp --syn -j DROP

# Or with hashlimit (better for per-IP tracking)
iptables -A INPUT -p tcp --syn -m hashlimit --hashlimit-above 5/sec --hashlimit-mode srcip --hashlimit-name syn_flood -j DROP

# Enable SYN cookies (kernel parameter)
# echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies
</code></pre>
<h3 id="port-scan-detection"><a class="header" href="#port-scan-detection">Port Scan Detection</a></h3>
<pre><code class="language-bash"># Detect and block port scans
iptables -N PORT_SCAN
iptables -A INPUT -p tcp --tcp-flags ALL NONE -j PORT_SCAN
iptables -A INPUT -p tcp --tcp-flags ALL ALL -j PORT_SCAN
iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j PORT_SCAN
iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j PORT_SCAN
iptables -A INPUT -p tcp --tcp-flags FIN,RST FIN,RST -j PORT_SCAN
iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j PORT_SCAN

iptables -A PORT_SCAN -m limit --limit 1/min -j LOG --log-prefix "Port scan detected: " --log-level 7
iptables -A PORT_SCAN -j DROP
</code></pre>
<h3 id="ddos-protection"><a class="header" href="#ddos-protection">DDoS Protection</a></h3>
<pre><code class="language-bash"># Limit connections per IP
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 32 -j REJECT --reject-with tcp-reset

# Protect against SYN flood
iptables -A INPUT -p tcp --syn -m hashlimit --hashlimit-above 5/sec --hashlimit-mode srcip --hashlimit-name syn_limit -j DROP

# Block fragmented packets
iptables -A INPUT -f -j DROP

# Block invalid packets
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# Block new packets that are not SYN
iptables -A INPUT -p tcp ! --syn -m conntrack --ctstate NEW -j DROP

# Block uncommon MSS values
iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP
</code></pre>
<h3 id="brute-force-protection"><a class="header" href="#brute-force-protection">Brute Force Protection</a></h3>
<pre><code class="language-bash"># SSH brute force protection (max 4 attempts in 60 seconds)
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 --rttl --name SSH -j DROP

# FTP brute force protection
iptables -A INPUT -p tcp --dport 21 -m state --state NEW -m recent --set --name FTP
iptables -A INPUT -p tcp --dport 21 -m state --state NEW -m recent --update --seconds 60 --hitcount 3 --rttl --name FTP -j DROP

# Web login brute force (for admin panels)
iptables -A INPUT -p tcp --dport 443 -m string --string "POST /admin/login" --algo bm -m recent --set --name WEB_LOGIN
iptables -A INPUT -p tcp --dport 443 -m string --string "POST /admin/login" --algo bm -m recent --update --seconds 300 --hitcount 5 --name WEB_LOGIN -j DROP
</code></pre>
<h3 id="geo-blocking-requires-xtables-addons"><a class="header" href="#geo-blocking-requires-xtables-addons">Geo-blocking (requires xtables-addons)</a></h3>
<pre><code class="language-bash"># Block specific countries (requires geoip module)
iptables -A INPUT -m geoip --src-cc CN,RU -j DROP

# Allow only specific countries
iptables -A INPUT -m geoip ! --src-cc US,CA,GB -j DROP
</code></pre>
<h2 id="logging-and-debugging"><a class="header" href="#logging-and-debugging">Logging and Debugging</a></h2>
<h3 id="basic-logging"><a class="header" href="#basic-logging">Basic Logging</a></h3>
<pre><code class="language-bash"># Log dropped packets
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables INPUT DROP: " --log-level 7
iptables -A INPUT -j DROP

# Log to specific file (requires rsyslog configuration)
iptables -A INPUT -j LOG --log-prefix "FIREWALL: " --log-level 4

# Log with additional information
iptables -A INPUT -j LOG --log-prefix "DROP: " --log-tcp-sequence --log-tcp-options --log-ip-options
</code></pre>
<h3 id="debugging-rules"><a class="header" href="#debugging-rules">Debugging Rules</a></h3>
<pre><code class="language-bash"># Create logging chain for debugging
iptables -N LOG_AND_ACCEPT
iptables -A LOG_AND_ACCEPT -j LOG --log-prefix "ACCEPT: " --log-level 7
iptables -A LOG_AND_ACCEPT -j ACCEPT

# Use it in rules
iptables -A INPUT -p tcp --dport 80 -j LOG_AND_ACCEPT

# Trace packet path (requires raw table TRACE target and iptables events)
iptables -t raw -A PREROUTING -p tcp --dport 80 -s 192.168.1.100 -j TRACE
# View traces: xtables-monitor --trace

# Count packets matching a rule (for testing)
iptables -A INPUT -p tcp --dport 80 -c 0 0
iptables -L INPUT -v -n  # Check packet counters
</code></pre>
<h3 id="logging-best-practices"><a class="header" href="#logging-best-practices">Logging Best Practices</a></h3>
<pre><code class="language-bash"># Use rate limiting to prevent log flooding
iptables -A INPUT -m limit --limit 5/min --limit-burst 10 -j LOG --log-prefix "DROP: "

# Use different prefixes for different rules
iptables -A INPUT -p tcp --dport 22 -m recent --update --seconds 60 --hitcount 4 -j LOG --log-prefix "SSH-BRUTE: "
iptables -A INPUT -p tcp --syn -j LOG --log-prefix "NEW-CONN: "

# Log to different levels
# 0=emerg, 1=alert, 2=crit, 3=err, 4=warning, 5=notice, 6=info, 7=debug
iptables -A INPUT -j LOG --log-level 4  # warning level
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="rule-ordering"><a class="header" href="#rule-ordering">Rule Ordering</a></h3>
<pre><code class="language-bash"># 1. Allow loopback first
iptables -A INPUT -i lo -j ACCEPT

# 2. Drop invalid packets early
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

# 3. Allow established/related connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# 4. Rate limiting and anti-abuse rules
iptables -A INPUT -p tcp --syn -m hashlimit --hashlimit-above 10/sec --hashlimit-mode srcip -j DROP

# 5. Specific service rules (most used first)
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# 6. Less common services
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# 7. Logging before default policy
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "DROP: "

# 8. Default policy or explicit drop
# (handled by policy setting)
</code></pre>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li>
<p><strong>Default Deny</strong>: Set default policy to DROP</p>
<pre><code class="language-bash">iptables -P INPUT DROP
iptables -P FORWARD DROP
</code></pre>
</li>
<li>
<p><strong>Explicit Rules</strong>: Be explicit about what you allow</p>
<pre><code class="language-bash"># Good
iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 22 -m conntrack --ctstate NEW -j ACCEPT

# Bad (too permissive)
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
</code></pre>
</li>
<li>
<p><strong>Protect SSH</strong>: Always ensure SSH is protected before applying rules</p>
<pre><code class="language-bash"># Test rules before applying permanently
# Use at/cron to reset rules in case you lock yourself out
at now + 5 minutes &lt;&lt;&lt; "iptables -F; iptables -P INPUT ACCEPT"
</code></pre>
</li>
<li>
<p><strong>Stateful Filtering</strong>: Always use connection tracking</p>
<pre><code class="language-bash">iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
</code></pre>
</li>
<li>
<p><strong>Rate Limiting</strong>: Protect against abuse</p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --dport 80 -m hashlimit --hashlimit-above 10/sec -j DROP
</code></pre>
</li>
<li>
<p><strong>Logging</strong>: Log suspicious activity</p>
<pre><code class="language-bash">iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "SUSPICIOUS: "
</code></pre>
</li>
<li>
<p><strong>Regular Audits</strong>: Review rules periodically</p>
<pre><code class="language-bash">iptables -S &gt; /tmp/rules-$(date +%Y%m%d).txt
</code></pre>
</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<pre><code class="language-bash"># 1. Put most-matched rules first
# 2. Use connection tracking to reduce rule processing
# 3. Disable tracking for high-traffic connections
iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK

# 4. Use ipset for large IP lists (more efficient than multiple rules)
ipset create blacklist hash:ip
ipset add blacklist 1.2.3.4
ipset add blacklist 5.6.7.8
iptables -A INPUT -m set --match-set blacklist src -j DROP

# 5. Minimize logging in production
# 6. Use hashlimit instead of recent for large-scale rate limiting
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<h4 id="locked-out-of-ssh"><a class="header" href="#locked-out-of-ssh">Locked Out of SSH</a></h4>
<pre><code class="language-bash"># Prevention: Use at command to reset rules
at now + 10 minutes &lt;&lt;&lt; "iptables -F; iptables -P INPUT ACCEPT"

# Then apply your rules. If something goes wrong, rules will auto-reset in 10 minutes

# Recovery: Access via console/KVM and run:
iptables -F
iptables -P INPUT ACCEPT
</code></pre>
<h4 id="rules-not-working"><a class="header" href="#rules-not-working">Rules Not Working</a></h4>
<pre><code class="language-bash"># 1. Check rule order
iptables -L -v -n --line-numbers

# 2. Check packet counters
iptables -L -v -n  # Look at pkts column

# 3. Verify packet path with logging
iptables -I INPUT 1 -p tcp --dport 80 -j LOG --log-prefix "TEST: "
# Check logs: tail -f /var/log/syslog | grep "TEST:"

# 4. Check conntrack state
conntrack -L
conntrack -L | grep 192.168.1.100

# 5. Verify routing
ip route show
ip route get 8.8.8.8
</code></pre>
<h4 id="nat-not-working"><a class="header" href="#nat-not-working">NAT Not Working</a></h4>
<pre><code class="language-bash"># 1. Verify IP forwarding is enabled
cat /proc/sys/net/ipv4/ip_forward  # Should be 1
echo 1 &gt; /proc/sys/net/ipv4/ip_forward

# 2. Check NAT rules
iptables -t nat -L -v -n

# 3. Check FORWARD chain
iptables -L FORWARD -v -n

# 4. Verify conntrack
conntrack -L | grep DNAT
conntrack -L | grep SNAT

# 5. Check routing
ip route show
</code></pre>
<h4 id="rules-disappear-after-reboot"><a class="header" href="#rules-disappear-after-reboot">Rules Disappear After Reboot</a></h4>
<pre><code class="language-bash"># Install persistence package
# Debian/Ubuntu: apt install iptables-persistent
# RHEL/CentOS: yum install iptables-services

# Save rules
iptables-save &gt; /etc/iptables/rules.v4
ip6tables-save &gt; /etc/iptables/rules.v6

# Or with netfilter-persistent
netfilter-persistent save

# Verify persistence service is enabled
systemctl status netfilter-persistent
systemctl enable netfilter-persistent
</code></pre>
<h4 id="high-cpu-usage"><a class="header" href="#high-cpu-usage">High CPU Usage</a></h4>
<pre><code class="language-bash"># 1. Check for excessive logging
iptables -L -v -n | grep LOG

# 2. Disable conntrack for high-traffic connections
iptables -t raw -A PREROUTING -p tcp --dport 80 -j NOTRACK
iptables -t raw -A OUTPUT -p tcp --sport 80 -j NOTRACK

# 3. Use ipset for large IP lists
# 4. Optimize rule order (most-matched first)
# 5. Check conntrack table size
cat /proc/sys/net/netfilter/nf_conntrack_count
cat /proc/sys/net/netfilter/nf_conntrack_max

# Increase if needed:
echo 262144 &gt; /proc/sys/net/netfilter/nf_conntrack_max
</code></pre>
<h3 id="testing-rules"><a class="header" href="#testing-rules">Testing Rules</a></h3>
<pre><code class="language-bash"># Test from another machine
nc -zv &lt;server-ip&gt; 80  # Test TCP connection
nmap -p 80,443 &lt;server-ip&gt;  # Scan ports

# Test locally
telnet localhost 80
curl -v http://localhost

# Simulate traffic
hping3 -S -p 80 &lt;server-ip&gt;  # SYN flood test
ab -n 1000 -c 10 http://localhost/  # HTTP load test

# Verify packet flow
tcpdump -i eth0 -n 'port 80'  # Capture packets
tcpdump -i any -n 'host 192.168.1.100'  # Track specific host
</code></pre>
<h2 id="persistence-and-system-integration"><a class="header" href="#persistence-and-system-integration">Persistence and System Integration</a></h2>
<h3 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h3>
<pre><code class="language-bash"># Install persistence
apt install iptables-persistent

# Save rules
netfilter-persistent save

# Or manually
iptables-save &gt; /etc/iptables/rules.v4
ip6tables-save &gt; /etc/iptables/rules.v6

# Restore on boot (handled by netfilter-persistent service)
systemctl status netfilter-persistent
systemctl enable netfilter-persistent
</code></pre>
<h3 id="rhelcentosfedora"><a class="header" href="#rhelcentosfedora">RHEL/CentOS/Fedora</a></h3>
<pre><code class="language-bash"># Install service
yum install iptables-services

# Save rules
service iptables save
# Saves to: /etc/sysconfig/iptables

# Enable on boot
systemctl enable iptables
systemctl start iptables

# Manual save/restore
iptables-save &gt; /etc/sysconfig/iptables
iptables-restore &lt; /etc/sysconfig/iptables
</code></pre>
<h3 id="systemd-integration"><a class="header" href="#systemd-integration">systemd Integration</a></h3>
<p>Create a systemd service for custom iptables script:</p>
<pre><code class="language-bash"># Create script: /usr/local/bin/firewall.sh
#!/bin/bash
# Your iptables rules here

# Create service: /etc/systemd/system/firewall.service
cat &gt; /etc/systemd/system/firewall.service &lt;&lt;'EOF'
[Unit]
Description=Custom Firewall Rules
Before=network-pre.target
Wants=network-pre.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/firewall.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# Enable service
systemctl daemon-reload
systemctl enable firewall.service
systemctl start firewall.service
</code></pre>
<h3 id="atomic-rule-updates"><a class="header" href="#atomic-rule-updates">Atomic Rule Updates</a></h3>
<pre><code class="language-bash"># Method 1: Use iptables-restore
iptables-save &gt; /tmp/current-rules.txt
# Edit /tmp/current-rules.txt
iptables-restore &lt; /tmp/current-rules.txt

# Method 2: Use iptables-apply (safer, auto-rollback)
iptables-save &gt; /tmp/new-rules.txt
# Edit /tmp/new-rules.txt
iptables-apply /tmp/new-rules.txt
# Confirms changes or auto-reverts after timeout
</code></pre>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="custom-chains"><a class="header" href="#custom-chains">Custom Chains</a></h3>
<pre><code class="language-bash"># Create custom chain for web traffic
iptables -N WEB_TRAFFIC
iptables -A WEB_TRAFFIC -p tcp --dport 80 -j ACCEPT
iptables -A WEB_TRAFFIC -p tcp --dport 443 -j ACCEPT
iptables -A WEB_TRAFFIC -j RETURN

# Use custom chain
iptables -A INPUT -j WEB_TRAFFIC

# Create reusable logging chain
iptables -N LOG_DROP
iptables -A LOG_DROP -m limit --limit 5/min -j LOG --log-prefix "DROP: " --log-level 7
iptables -A LOG_DROP -j DROP

# Use it
iptables -A INPUT -p tcp --dport 23 -j LOG_DROP
</code></pre>
<h3 id="connection-marking"><a class="header" href="#connection-marking">Connection Marking</a></h3>
<pre><code class="language-bash"># Mark packets for QoS
iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 1
iptables -t mangle -A PREROUTING -p tcp --dport 80 -j MARK --set-mark 2

# Use marks in routing (requires ip rule/route configuration)
ip rule add fwmark 1 table 100
ip rule add fwmark 2 table 200

# Use marks in other iptables rules
iptables -A FORWARD -m mark --mark 1 -j ACCEPT
</code></pre>
<h3 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h3>
<pre><code class="language-bash"># Simple round-robin load balancing
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode nth --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode nth --every 2 --packet 0 -j DNAT --to-destination 192.168.1.102:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.103:80

# Random load balancing
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode random --probability 0.33 -j DNAT --to-destination 192.168.1.101:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -m statistic --mode random --probability 0.50 -j DNAT --to-destination 192.168.1.102:80
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.103:80
</code></pre>
<h3 id="integration-with-fail2ban"><a class="header" href="#integration-with-fail2ban">Integration with fail2ban</a></h3>
<pre><code class="language-bash"># fail2ban creates and manages iptables rules automatically
# Example fail2ban chain (created by fail2ban)
iptables -L fail2ban-ssh -v -n

# Manual ban
iptables -I INPUT -s 1.2.3.4 -j DROP

# Unban
iptables -D INPUT -s 1.2.3.4 -j DROP
</code></pre>
<h3 id="ipv6-ip6tables"><a class="header" href="#ipv6-ip6tables">IPv6 (ip6tables)</a></h3>
<pre><code class="language-bash"># ip6tables syntax is nearly identical to iptables
ip6tables -A INPUT -p tcp --dport 80 -j ACCEPT

# Allow ICMPv6 (essential for IPv6)
ip6tables -A INPUT -p ipv6-icmp -j ACCEPT

# Save IPv6 rules
ip6tables-save &gt; /etc/iptables/rules.v6
</code></pre>
<h2 id="complete-firewall-examples"><a class="header" href="#complete-firewall-examples">Complete Firewall Examples</a></h2>
<h3 id="basic-server"><a class="header" href="#basic-server">Basic Server</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Basic server firewall script

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X

# Default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Loopback
iptables -A INPUT -i lo -j ACCEPT

# Connection tracking
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# SSH with brute force protection
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 --name SSH -j DROP
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT

# HTTP/HTTPS
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# ICMP (ping)
iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s -j ACCEPT

# Log dropped packets
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables DROP: " --log-level 7

# Save rules
netfilter-persistent save
</code></pre>
<h3 id="routergateway"><a class="header" href="#routergateway">Router/Gateway</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Router firewall script

# Enable IP forwarding
echo 1 &gt; /proc/sys/net/ipv4/ip_forward

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X

# Default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Loopback
iptables -A INPUT -i lo -j ACCEPT

# Connection tracking
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Allow SSH from LAN only
iptables -A INPUT -i eth1 -p tcp --dport 22 -j ACCEPT

# Allow DNS from LAN
iptables -A INPUT -i eth1 -p udp --dport 53 -j ACCEPT
iptables -A INPUT -i eth1 -p tcp --dport 53 -j ACCEPT

# Allow DHCP from LAN
iptables -A INPUT -i eth1 -p udp --dport 67:68 -j ACCEPT

# Forward LAN to WAN
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT

# NAT/Masquerading
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# Port forwarding example: external 80 -&gt; internal 192.168.1.100:80
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100:80
iptables -A FORWARD -i eth0 -o eth1 -p tcp -d 192.168.1.100 --dport 80 -m conntrack --ctstate NEW -j ACCEPT

# Anti-spoofing
iptables -A INPUT -i eth0 -s 192.168.0.0/16 -j DROP
iptables -A INPUT -i eth0 -s 10.0.0.0/8 -j DROP
iptables -A INPUT -i eth0 -s 172.16.0.0/12 -j DROP

# Save rules
netfilter-persistent save
</code></pre>
<h2 id="migration-to-nftables"><a class="header" href="#migration-to-nftables">Migration to nftables</a></h2>
<p>Note: nftables is the successor to iptables. Consider migrating:</p>
<pre><code class="language-bash"># Install nftables
apt install nftables

# Translate iptables rules to nftables
iptables-save &gt; /tmp/iptables-rules.txt
iptables-restore-translate -f /tmp/iptables-rules.txt &gt; /etc/nftables.conf

# Or translate interactively
iptables-translate -A INPUT -p tcp --dport 80 -j ACCEPT
# Output: nft add rule ip filter INPUT tcp dport 80 counter accept
</code></pre>
<h2 id="eli10-what-is-iptables"><a class="header" href="#eli10-what-is-iptables">ELI10: What is iptables?</a></h2>
<p>iptables is like a smart security guard for your computer's network door. Just like a building might have rules about who can come in, what they can bring, and where they can go, iptables helps your computer decide what network data is allowed in or out.</p>
<h3 id="simple-concepts"><a class="header" href="#simple-concepts">Simple Concepts:</a></h3>
<ul>
<li><strong>Tables</strong>: Different rulebooks for different jobs (like one for filtering visitors, one for changing addresses)</li>
<li><strong>Chains</strong>: Lists of rules checked in order (like checking ID, then bags, then appointment)</li>
<li><strong>Rules</strong>: Individual checks (like "allow friends from school" or "block strangers")</li>
<li><strong>Targets</strong>: What to do when a rule matches (let them in, send them away, or write it down)</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example:</a></h3>
<p>Imagine your computer is a house:</p>
<ul>
<li><strong>INPUT chain</strong>: Rules for people trying to come into your house</li>
<li><strong>OUTPUT chain</strong>: Rules for people leaving your house</li>
<li><strong>FORWARD chain</strong>: Rules for people passing through your yard</li>
</ul>
<p>You might have rules like:</p>
<ul>
<li>"Let my friends in" (ACCEPT)</li>
<li>"Don't let strangers in" (DROP)</li>
<li>"Write down when someone suspicious comes by" (LOG)</li>
</ul>
<p>iptables does this same job but for network data instead of people!</p>
<h2 id="common-commands-reference"><a class="header" href="#common-commands-reference">Common Commands Reference</a></h2>
<pre><code class="language-bash"># View rules
iptables -L -v -n --line-numbers
iptables -S
iptables-save

# Add rules
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    # Append
iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT  # Insert

# Delete rules
iptables -D INPUT 5                              # By line number
iptables -D INPUT -p tcp --dport 80 -j ACCEPT    # By specification

# Flush rules
iptables -F                                      # All chains
iptables -F INPUT                                # Specific chain

# Set policy
iptables -P INPUT DROP

# Save/Restore
iptables-save &gt; /etc/iptables/rules.v4
iptables-restore &lt; /etc/iptables/rules.v4
netfilter-persistent save
</code></pre>
<h2 id="useful-resources"><a class="header" href="#useful-resources">Useful Resources</a></h2>
<ul>
<li>Official Netfilter documentation: https://www.netfilter.org/documentation/</li>
<li>iptables man page: <code>man iptables</code></li>
<li>iptables-extensions man page: <code>man iptables-extensions</code></li>
<li>Connection tracking: <code>man conntrack</code></li>
<li>nftables (successor): https://wiki.nftables.org/</li>
</ul>
<h2 id="quick-troubleshooting-checklist"><a class="header" href="#quick-troubleshooting-checklist">Quick Troubleshooting Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Is IP forwarding enabled? (for NAT/routing)</li>
<li><input disabled="" type="checkbox"/>
Are rules in the correct table?</li>
<li><input disabled="" type="checkbox"/>
Is rule order correct? (specific before general)</li>
<li><input disabled="" type="checkbox"/>
Are connection states allowed? (ESTABLISHED,RELATED)</li>
<li><input disabled="" type="checkbox"/>
Is the default policy correct?</li>
<li><input disabled="" type="checkbox"/>
Are rules persistent across reboots?</li>
<li><input disabled="" type="checkbox"/>
Are logs showing what you expect?</li>
<li><input disabled="" type="checkbox"/>
Is conntrack table not full?</li>
<li><input disabled="" type="checkbox"/>
Are there no conflicting rules?</li>
<li><input disabled="" type="checkbox"/>
Is the interface name correct?</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/tc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../linux/systemd.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/tc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../linux/systemd.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
