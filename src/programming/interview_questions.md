# Interview Questions

## LeetCode Patterns

LeetCode is a popular platform for practicing coding problems and preparing for technical interviews. Many problems on LeetCode can be categorized into specific patterns. Understanding these patterns can help you approach and solve problems more efficiently. Here are some common LeetCode patterns:

### 1. Sliding Window
The sliding window pattern is used to solve problems that involve a contiguous sequence of elements, such as subarrays or substrings. This pattern helps in reducing the time complexity by avoiding redundant calculations.

**Example Problem:** Find the maximum sum of a subarray of size `k`.

### 2. Two Pointers
The two pointers pattern is used to solve problems involving sorted arrays or linked lists. It involves using two pointers to iterate through the data structure, often from opposite ends, to find pairs or subarrays that meet certain criteria.

**Example Problem:** Find two numbers in a sorted array that add up to a given target.

### 3. Fast and Slow Pointers
The fast and slow pointers pattern is used to detect cycles in linked lists or arrays. The fast pointer moves twice as fast as the slow pointer, and if there is a cycle, they will eventually meet.

**Example Problem:** Detect a cycle in a linked list.

### 4. Merge Intervals
The merge intervals pattern is used to solve problems that involve overlapping intervals. This pattern helps in merging overlapping intervals and simplifying the problem.

**Example Problem:** Merge overlapping intervals in a list of intervals.

### 5. Cyclic Sort
The cyclic sort pattern is used to solve problems involving arrays where the elements are in a range from 1 to `n`. This pattern helps in placing each element at its correct index.

**Example Problem:** Find the missing number in an array of size `n` containing numbers from 1 to `n`.

### 6. In-place Reversal of a Linked List
The in-place reversal of a linked list pattern is used to solve problems that require reversing a portion of a linked list. This pattern helps in reversing the nodes of the linked list in-place without using extra space.

**Example Problem:** Reverse a sublist of a linked list from position `m` to `n`.

### 7. Tree BFS (Breadth-First Search)
The tree BFS pattern is used to solve problems involving tree traversal. This pattern helps in traversing the tree level by level and is useful for problems that require processing nodes in a specific order.

**Example Problem:** Find the level order traversal of a binary tree.

### 8. Tree DFS (Depth-First Search)
The tree DFS pattern is used to solve problems involving tree traversal. This pattern helps in traversing the tree depth-wise and is useful for problems that require exploring all paths from the root to the leaves.

**Example Problem:** Find all root-to-leaf paths in a binary tree.

### 9. Two Heaps
The two heaps pattern is used to solve problems that require finding the median of a data stream. This pattern involves using two heaps (a max-heap and a min-heap) to maintain the median efficiently.

**Example Problem:** Find the median of a data stream.

### 10. Subsets
The subsets pattern is used to solve problems that involve generating all possible subsets of a given set. This pattern helps in exploring all combinations and permutations of the elements.

**Example Problem:** Generate all subsets of a given set of numbers.

### 11. Modified Binary Search
The modified binary search pattern is used to solve problems that involve searching in a sorted array or matrix. This pattern helps in reducing the search space by half in each step.

**Example Problem:** Find the peak element in a mountain array.

### 12. Topological Sort
The topological sort pattern is used to solve problems involving directed acyclic graphs (DAGs). This pattern helps in ordering the nodes of the graph in a linear sequence based on their dependencies.

**Example Problem:** Find the order of courses to take given their prerequisites.

### 13. K-way Merge
The k-way merge pattern is used to solve problems that involve merging multiple sorted arrays or lists. This pattern helps in efficiently merging the arrays using a min-heap.

**Example Problem:** Merge `k` sorted linked lists.

### 14. Knapsack (Dynamic Programming)
The knapsack pattern is used to solve problems that involve selecting items with given weights and values to maximize the total value without exceeding a weight limit. This pattern helps in solving optimization problems using dynamic programming.

**Example Problem:** Find the maximum value that can be obtained by selecting items with given weights and values.

Understanding these patterns and practicing problems based on them can significantly improve your problem-solving skills and help you perform better in technical interviews.

### 15. Stacks
The stack pattern is used to solve problems that involve processing elements in a last-in, first-out (LIFO) order. This pattern helps in managing function calls, parsing expressions, and backtracking problems.

**Example Problem:** Evaluate a postfix expression.

Understanding these patterns and practicing problems based on them can significantly improve your problem-solving skills and help you perform better in technical interviews.


