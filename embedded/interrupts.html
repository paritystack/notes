<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interrupts - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-c8b3b484.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-525481d4.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Interrupts are signals that temporarily halt the normal execution of a program, allowing the system to respond to important events. They are a crucial mechanism in embedded systems and computer architecture, enabling efficient event handling, real-time processing, and hardware interaction without constant polling.</p>
<h2 id="types-of-interrupts"><a class="header" href="#types-of-interrupts">Types of Interrupts</a></h2>
<h3 id="hardware-interrupts"><a class="header" href="#hardware-interrupts">Hardware Interrupts</a></h3>
<p>Generated by hardware peripherals (e.g., UART, timers, GPIO, SPI, I2C) to signal that they require attention from the CPU. These interrupts can occur asynchronously and are typically prioritized to ensure critical tasks are handled promptly.</p>
<p><strong>Categories:</strong></p>
<ul>
<li><strong>External Interrupts</strong>: Triggered by external pins (GPIO state changes, button presses)</li>
<li><strong>Peripheral Interrupts</strong>: Generated by on-chip peripherals (UART data ready, timer overflow, ADC conversion complete)</li>
<li><strong>System Interrupts</strong>: Critical system events (watchdog timeout, clock failure, brown-out detection)</li>
</ul>
<h3 id="software-interrupts"><a class="header" href="#software-interrupts">Software Interrupts</a></h3>
<p>Triggered by software instructions, such as:</p>
<ul>
<li><strong>System Calls</strong>: Programs requesting OS services</li>
<li><strong>Exceptions</strong>: Division by zero, invalid memory access, undefined instructions</li>
<li><strong>Debug Events</strong>: Breakpoints, single-step execution</li>
</ul>
<h3 id="timer-interrupts"><a class="header" href="#timer-interrupts">Timer Interrupts</a></h3>
<p>Generated by hardware timers at regular intervals for:</p>
<ul>
<li>Task scheduling in RTOS</li>
<li>Time-keeping and timestamps</li>
<li>PWM generation</li>
<li>Periodic sampling and control loops</li>
</ul>
<h2 id="arm-cortex-m-interrupt-architecture"><a class="header" href="#arm-cortex-m-interrupt-architecture">ARM Cortex-M Interrupt Architecture</a></h2>
<h3 id="nvic-nested-vectored-interrupt-controller"><a class="header" href="#nvic-nested-vectored-interrupt-controller">NVIC (Nested Vectored Interrupt Controller)</a></h3>
<p>The NVIC is the interrupt controller in ARM Cortex-M processors, providing:</p>
<ul>
<li>Support for up to 240 external interrupts (MCU-dependent)</li>
<li>Hardware priority management</li>
<li>Nested interrupt support</li>
<li>Low-latency interrupt entry/exit</li>
<li>Automatic state saving and restoration</li>
</ul>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Priority Levels</strong>: Configurable priority for each interrupt (typically 3-8 bits)</li>
<li><strong>Priority Grouping</strong>: Splits priority into preemption priority and sub-priority</li>
<li><strong>Interrupt Masking</strong>: PRIMASK, FAULTMASK, BASEPRI registers for selective masking</li>
<li><strong>Tail Chaining</strong>: Optimized back-to-back interrupt handling without state restore</li>
</ul>
<h3 id="vector-table"><a class="header" href="#vector-table">Vector Table</a></h3>
<p>The vector table is a data structure at the beginning of memory (typically 0x00000000 or relocated) containing:</p>
<ul>
<li>Initial stack pointer value (first entry)</li>
<li>Reset handler address</li>
<li>Exception handler addresses (NMI, HardFault, etc.)</li>
<li>IRQ handler addresses for all peripheral interrupts</li>
</ul>
<p><strong>Example Vector Table Structure (Cortex-M):</strong></p>
<pre><code class="language-c">__attribute__ ((section(".isr_vector")))
const uint32_t vector_table[] = {
    (uint32_t)&amp;_estack,           // 0: Initial Stack Pointer
    (uint32_t)Reset_Handler,      // 1: Reset Handler
    (uint32_t)NMI_Handler,        // 2: NMI Handler
    (uint32_t)HardFault_Handler,  // 3: Hard Fault Handler
    (uint32_t)MemManage_Handler,  // 4: MPU Fault Handler
    (uint32_t)BusFault_Handler,   // 5: Bus Fault Handler
    (uint32_t)UsageFault_Handler, // 6: Usage Fault Handler
    0,                            // 7-10: Reserved
    0,
    0,
    0,
    (uint32_t)SVC_Handler,        // 11: SVCall Handler
    (uint32_t)DebugMon_Handler,   // 12: Debug Monitor
    0,                            // 13: Reserved
    (uint32_t)PendSV_Handler,     // 14: PendSV Handler
    (uint32_t)SysTick_Handler,    // 15: SysTick Handler
    // External Interrupts
    (uint32_t)WWDG_IRQHandler,    // 16: Window Watchdog
    (uint32_t)EXTI0_IRQHandler,   // 17: EXTI Line 0
    // ... more peripheral IRQs
};
</code></pre>
<h3 id="interrupt-priority-configuration"><a class="header" href="#interrupt-priority-configuration">Interrupt Priority Configuration</a></h3>
<p><strong>Priority Grouping:</strong></p>
<pre><code class="language-c">// Set priority grouping (4 bits preemption, 0 bits sub-priority)
NVIC_SetPriorityGrouping(3);

// Configure interrupt priority
// Priority 2, sub-priority 0
NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(3, 2, 0));

// Enable interrupt
NVIC_EnableIRQ(USART1_IRQn);
</code></pre>
<p><strong>Priority Levels:</strong></p>
<ul>
<li>Lower numerical value = higher priority</li>
<li>Priority 0 is the highest (most urgent)</li>
<li>Interrupts with higher preemption priority can preempt lower priority handlers</li>
<li>Sub-priority determines execution order when multiple interrupts are pending with same preemption priority</li>
</ul>
<h3 id="exception-states-cortex-m"><a class="header" href="#exception-states-cortex-m">Exception States (Cortex-M)</a></h3>
<ol>
<li><strong>Inactive</strong>: Exception not active or pending</li>
<li><strong>Pending</strong>: Exception waiting to be serviced</li>
<li><strong>Active</strong>: Exception handler is executing</li>
<li><strong>Active and Pending</strong>: Handler executing, and another instance is pending</li>
</ol>
<h2 id="avr-interrupts"><a class="header" href="#avr-interrupts">AVR Interrupts</a></h2>
<h3 id="avr-interrupt-architecture"><a class="header" href="#avr-interrupt-architecture">AVR Interrupt Architecture</a></h3>
<p>AVR microcontrollers use a simpler interrupt system compared to ARM Cortex-M:</p>
<ul>
<li><strong>Single Priority Level</strong>: All interrupts have the same priority (no nested interrupts by default)</li>
<li><strong>Fixed Vector Table</strong>: Located at the beginning of program memory</li>
<li><strong>Automatic Global Interrupt Disable</strong>: When an interrupt fires, global interrupts are automatically disabled</li>
<li><strong>Manual Re-enable</strong>: Must use <code>sei()</code> in ISR for nested interrupts</li>
</ul>
<h3 id="avr-vector-table"><a class="header" href="#avr-vector-table">AVR Vector Table</a></h3>
<p>Each interrupt has a fixed vector address at the beginning of flash memory:</p>
<pre><code class="language-c">// ATmega328P example vectors
ISR(RESET_vect) { }          // 0x0000: Reset
ISR(INT0_vect) { }           // 0x0002: External Interrupt 0
ISR(INT1_vect) { }           // 0x0004: External Interrupt 1
ISR(PCINT0_vect) { }         // 0x0006: Pin Change Interrupt 0
ISR(PCINT1_vect) { }         // 0x0008: Pin Change Interrupt 1
ISR(PCINT2_vect) { }         // 0x000A: Pin Change Interrupt 2
ISR(TIMER2_COMPA_vect) { }   // 0x000C: Timer2 Compare Match A
ISR(TIMER2_COMPB_vect) { }   // 0x000E: Timer2 Compare Match B
ISR(TIMER2_OVF_vect) { }     // 0x0010: Timer2 Overflow
ISR(TIMER1_CAPT_vect) { }    // 0x0012: Timer1 Capture
ISR(USART_RX_vect) { }       // etc.
</code></pre>
<h3 id="avr-interrupt-configuration"><a class="header" href="#avr-interrupt-configuration">AVR Interrupt Configuration</a></h3>
<p><strong>Enabling Interrupts:</strong></p>
<pre><code class="language-c">#include &lt;avr/interrupt.h&gt;

// Enable global interrupts
sei();

// Disable global interrupts
cli();

// Enable specific interrupt (e.g., Timer0 overflow)
TIMSK0 |= (1 &lt;&lt; TOIE0);

// Enable external interrupt INT0
EIMSK |= (1 &lt;&lt; INT0);

// Configure INT0 to trigger on falling edge
EICRA |= (1 &lt;&lt; ISC01);
EICRA &amp;= ~(1 &lt;&lt; ISC00);
</code></pre>
<p><strong>AVR ISR Definition:</strong></p>
<pre><code class="language-c">// Timer0 overflow interrupt
ISR(TIMER0_OVF_vect) {
    // Handler code
    TCNT0 = 0;  // Reset counter
    // ISR automatically clears global interrupt flag on entry
    // and restores it on exit (via RETI instruction)
}

// ISR with nested interrupts enabled
ISR(USART_RX_vect) {
    uint8_t data = UDR0;  // Read data

    // Re-enable interrupts for nesting (use with caution)
    sei();

    // Process data
    process_data(data);

    // cli() not needed - RETI handles this
}
</code></pre>
<h3 id="avr-interrupt-priority"><a class="header" href="#avr-interrupt-priority">AVR Interrupt Priority</a></h3>
<p>AVR interrupts are serviced based on <strong>vector table position</strong>:</p>
<ul>
<li>Lower vector addresses have higher priority</li>
<li>If multiple interrupts are pending, the one with the lowest vector address executes first</li>
<li>No hardware-based preemption (unless manually enabled with <code>sei()</code> in ISR)</li>
</ul>
<h2 id="isr-best-practices"><a class="header" href="#isr-best-practices">ISR Best Practices</a></h2>
<h3 id="keep-isrs-short-and-fast"><a class="header" href="#keep-isrs-short-and-fast">Keep ISRs Short and Fast</a></h3>
<p><strong>Why:</strong></p>
<ul>
<li>Long ISRs block other interrupts</li>
<li>Increase interrupt latency</li>
<li>Can cause system instability</li>
</ul>
<p><strong>Guidelines:</strong></p>
<pre><code class="language-c">// BAD: Complex processing in ISR
ISR(UART_RX_vect) {
    char data = UDR0;
    process_protocol(data);      // Complex function
    update_display();            // Slow operation
    send_response();             // I/O operation
}

// GOOD: Minimal processing, defer work
volatile uint8_t rx_buffer[64];
volatile uint8_t rx_head = 0;
volatile bool data_ready = false;

ISR(UART_RX_vect) {
    rx_buffer[rx_head++] = UDR0;
    if (rx_head &gt;= 64) rx_head = 0;
    data_ready = true;            // Set flag for main loop
}

// Main loop handles processing
void main_loop(void) {
    if (data_ready) {
        cli();
        process_buffer(rx_buffer);
        data_ready = false;
        sei();
    }
}
</code></pre>
<h3 id="volatile-variables"><a class="header" href="#volatile-variables">Volatile Variables</a></h3>
<p>Variables shared between ISR and main code <strong>must</strong> be declared <code>volatile</code>:</p>
<pre><code class="language-c">// Tells compiler this variable can change unexpectedly
volatile uint32_t tick_count = 0;
volatile bool button_pressed = false;

ISR(TIMER0_OVF_vect) {
    tick_count++;
}

void delay_ms(uint32_t ms) {
    uint32_t start = tick_count;  // Read volatile variable
    while ((tick_count - start) &lt; ms) {
        // Compiler won't optimize this loop away
    }
}
</code></pre>
<h3 id="atomic-access-for-multi-byte-variables"><a class="header" href="#atomic-access-for-multi-byte-variables">Atomic Access for Multi-Byte Variables</a></h3>
<p>Reading/writing multi-byte variables is not atomic on 8-bit and 16-bit MCUs:</p>
<pre><code class="language-c">volatile uint32_t counter = 0;

// BAD: Non-atomic read (can be interrupted mid-read)
void bad_read(void) {
    uint32_t local = counter;  // 4 separate byte reads on AVR
}

// GOOD: Atomic read
uint32_t atomic_read_counter(void) {
    uint32_t temp;
    cli();                // Disable interrupts
    temp = counter;       // Safe read
    sei();                // Re-enable interrupts
    return temp;
}

// Alternative for ARM Cortex-M: Use LDREX/STREX or disable interrupts
uint32_t safe_increment(void) {
    __disable_irq();
    uint32_t temp = counter++;
    __enable_irq();
    return temp;
}
</code></pre>
<h3 id="re-entrancy"><a class="header" href="#re-entrancy">Re-entrancy</a></h3>
<p>ISRs should generally be <strong>non-reentrant</strong> unless carefully designed:</p>
<pre><code class="language-c">// NOT re-entrant (static state)
void bad_isr_function(void) {
    static int count = 0;  // Shared state
    count++;
    // If this function is called from multiple ISRs, count can be corrupted
}

// Re-entrant (no static state, uses only parameters and local variables)
void good_isr_function(int* buffer, int index, int value) {
    buffer[index] = value;  // Safe if buffer, index, value are on stack
}
</code></pre>
<h3 id="avoid-dynamic-memory-allocation"><a class="header" href="#avoid-dynamic-memory-allocation">Avoid Dynamic Memory Allocation</a></h3>
<p>Never use <code>malloc()</code>, <code>free()</code>, or <code>new</code>/<code>delete</code> in ISRs:</p>
<ul>
<li>Not re-entrant</li>
<li>Can cause heap corruption</li>
<li>Unpredictable execution time</li>
<li>May use interrupts internally</li>
</ul>
<h2 id="critical-sections"><a class="header" href="#critical-sections">Critical Sections</a></h2>
<h3 id="what-is-a-critical-section"><a class="header" href="#what-is-a-critical-section">What is a Critical Section?</a></h3>
<p>A critical section is code that accesses shared resources and must not be interrupted:</p>
<pre><code class="language-c">volatile uint16_t adc_sum = 0;
volatile uint8_t adc_count = 0;

// Critical section: updating two related variables
void add_adc_sample(uint16_t sample) {
    cli();                    // Enter critical section
    adc_sum += sample;
    adc_count++;
    sei();                    // Exit critical section
}
</code></pre>
<h3 id="methods-for-protecting-critical-sections"><a class="header" href="#methods-for-protecting-critical-sections">Methods for Protecting Critical Sections</a></h3>
<p><strong>AVR - Global Interrupt Disable:</strong></p>
<pre><code class="language-c">cli();
// Critical code
sei();
</code></pre>
<p><strong>ARM Cortex-M - Multiple Methods:</strong></p>
<pre><code class="language-c">// Method 1: Disable all interrupts
__disable_irq();
// Critical code
__enable_irq();

// Method 2: Raise execution priority (CMSIS)
uint32_t primask = __get_PRIMASK();
__disable_irq();
// Critical code
__set_PRIMASK(primask);

// Method 3: Use BASEPRI to mask interrupts below certain priority
uint32_t basepri = __get_BASEPRI();
__set_BASEPRI(64);  // Mask interrupts with priority &gt;= 64
// Critical code
__set_BASEPRI(basepri);
</code></pre>
<p><strong>Nestable Critical Sections:</strong></p>
<pre><code class="language-c">static volatile uint8_t critical_nesting = 0;

void enter_critical(void) {
    cli();
    critical_nesting++;
}

void exit_critical(void) {
    critical_nesting--;
    if (critical_nesting == 0) {
        sei();
    }
}
</code></pre>
<h3 id="race-conditions"><a class="header" href="#race-conditions">Race Conditions</a></h3>
<p>Example of a race condition:</p>
<pre><code class="language-c">volatile bool data_ready = false;
volatile uint8_t data_buffer[10];
volatile uint8_t data_length = 0;

ISR(UART_RX_vect) {
    data_buffer[data_length++] = UDR0;
    if (data_length &gt;= 10) {
        data_ready = true;
        data_length = 0;
    }
}

// BAD: Race condition
void process_data(void) {
    if (data_ready) {
        // ISR could fire here and modify data_buffer!
        for (int i = 0; i &lt; 10; i++) {
            do_something(data_buffer[i]);  // Possible corruption
        }
        data_ready = false;
    }
}

// GOOD: Protected with critical section
void process_data_safe(void) {
    uint8_t local_buffer[10];
    bool ready;

    cli();
    ready = data_ready;
    if (ready) {
        memcpy(local_buffer, (void*)data_buffer, 10);
        data_ready = false;
    }
    sei();

    if (ready) {
        for (int i = 0; i &lt; 10; i++) {
            do_something(local_buffer[i]);  // Safe
        }
    }
}
</code></pre>
<h2 id="interrupt-latency"><a class="header" href="#interrupt-latency">Interrupt Latency</a></h2>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p><strong>Interrupt Latency</strong>: Time from interrupt assertion to first instruction of ISR executing.</p>
<p><strong>Components:</strong></p>
<ol>
<li><strong>Hardware latency</strong>: Time for CPU to recognize interrupt</li>
<li><strong>Context saving</strong>: Pushing registers to stack</li>
<li><strong>Vector fetch</strong>: Reading ISR address from vector table</li>
<li><strong>Pipeline flush</strong>: Clearing instruction pipeline</li>
</ol>
<h3 id="typical-latency-values"><a class="header" href="#typical-latency-values">Typical Latency Values</a></h3>
<ul>
<li><strong>AVR</strong>: 4-5 clock cycles (hardware) + ISR prologue</li>
<li><strong>ARM Cortex-M0</strong>: 15 cycles (includes stacking)</li>
<li><strong>ARM Cortex-M3/M4</strong>: 12 cycles (with tail-chaining: 6 cycles)</li>
<li><strong>ARM Cortex-M7</strong>: 12 cycles (can be reduced to 6 with optimization)</li>
</ul>
<h3 id="factors-affecting-latency"><a class="header" href="#factors-affecting-latency">Factors Affecting Latency</a></h3>
<ol>
<li><strong>Interrupt Priority</strong>: Lower priority interrupts wait for higher priority ones</li>
<li><strong>Disabled Interrupts</strong>: Critical sections delay recognition</li>
<li><strong>Current ISR Execution</strong>: Lower priority interrupts wait for higher priority ISRs</li>
<li><strong>Flash Wait States</strong>: Slow memory access increases latency</li>
<li><strong>Bus Contention</strong>: DMA or other masters accessing memory</li>
</ol>
<h3 id="reducing-interrupt-latency"><a class="header" href="#reducing-interrupt-latency">Reducing Interrupt Latency</a></h3>
<p><strong>ARM Cortex-M Optimization:</strong></p>
<pre><code class="language-c">// Enable interrupt tail-chaining (automatic in NVIC)
// Reduces back-to-back ISR latency from 12 to 6 cycles

// Keep vector table in fast memory (RAM or tightly-coupled memory)
__attribute__((section(".ram_vector"))) uint32_t ram_vectors[256];

// Use fast interrupt handlers for critical interrupts
__attribute__((interrupt("IRQ"))) void fast_handler(void);
</code></pre>
<p><strong>AVR Optimization:</strong></p>
<pre><code class="language-c">// Use SIGNAL instead of ISR for critical interrupts (no nested interrupt support)
SIGNAL(TIMER0_OVF_vect) {
    // Fastest possible handler - no interrupt nesting support
    PORTB ^= (1 &lt;&lt; PB0);  // Toggle pin
}

// Place critical ISR code in specific section for faster flash access
__attribute__((section(".lowtext"))) void critical_function(void);
</code></pre>
<p><strong>General Tips:</strong></p>
<ul>
<li>Use higher priority for time-critical interrupts</li>
<li>Minimize critical section duration</li>
<li>Use tail-chaining (ARM Cortex-M)</li>
<li>Keep ISRs in fast memory</li>
<li>Reduce ISR complexity</li>
</ul>
<h2 id="hardware-interrupt-characteristics"><a class="header" href="#hardware-interrupt-characteristics">Hardware Interrupt Characteristics</a></h2>
<h3 id="edge-vs-level-triggered"><a class="header" href="#edge-vs-level-triggered">Edge vs. Level Triggered</a></h3>
<p><strong>Edge-Triggered:</strong></p>
<ul>
<li>Interrupt fires on rising/falling edge of signal</li>
<li>Must be cleared by reading status register or peripheral action</li>
<li>Can miss events if edges occur too quickly</li>
<li>Typically used for event counting, button presses</li>
</ul>
<pre><code class="language-c">// STM32 - Configure GPIO for falling edge interrupt
EXTI-&gt;FTSR |= EXTI_FTSR_TR0;   // Falling edge trigger
EXTI-&gt;RTSR &amp;= ~EXTI_RTSR_TR0;  // Disable rising edge

// AVR - Configure INT0 for falling edge
EICRA |= (1 &lt;&lt; ISC01);
EICRA &amp;= ~(1 &lt;&lt; ISC00);
</code></pre>
<p><strong>Level-Triggered:</strong></p>
<ul>
<li>Interrupt active while signal is at specific level (high or low)</li>
<li>Interrupt repeats if condition not cleared</li>
<li>Won’t miss events but can cause interrupt storms</li>
<li>Used for status flags, continuous conditions</li>
</ul>
<pre><code class="language-c">// Some peripherals use level-triggered interrupts
// Must clear the condition (e.g., read data register, clear flag)

ISR(USART_RX_vect) {
    uint8_t data = UDR0;  // Reading UDR0 clears the interrupt flag
    // If not cleared, interrupt will immediately fire again
}
</code></pre>
<h3 id="interrupt-flags-and-pending-registers"><a class="header" href="#interrupt-flags-and-pending-registers">Interrupt Flags and Pending Registers</a></h3>
<p><strong>Interrupt Flag Register (IFR):</strong></p>
<ul>
<li>Indicates which interrupt source triggered</li>
<li>Must be cleared (usually by writing 1 to the bit)</li>
</ul>
<p><strong>Pending Register:</strong></p>
<ul>
<li>Shows interrupts waiting to be serviced</li>
</ul>
<pre><code class="language-c">// ARM Cortex-M - Check pending interrupts
if (NVIC_GetPendingIRQ(USART1_IRQn)) {
    // USART1 interrupt is pending
}

// Clear pending interrupt
NVIC_ClearPendingIRQ(USART1_IRQn);

// AVR - Check and clear interrupt flags
if (TIFR0 &amp; (1 &lt;&lt; TOV0)) {  // Timer0 overflow flag set
    TIFR0 |= (1 &lt;&lt; TOV0);   // Clear by writing 1
}
</code></pre>
<p><strong>Common Mistake - Flag Clearing:</strong></p>
<pre><code class="language-c">// BAD: Reading flag doesn't clear it (on most MCUs)
ISR(TIMER_COMP_vect) {
    if (TIM_SR &amp; TIM_FLAG_CC1) {
        // Flag still set, interrupt will fire again immediately!
    }
}

// GOOD: Explicitly clear the flag
ISR(TIMER_COMP_vect) {
    TIM_SR = ~TIM_FLAG_CC1;  // Clear flag (write 0 on some MCUs)
    // or
    TIM_SR |= TIM_FLAG_CC1;  // Clear flag (write 1 on others - check datasheet)
}
</code></pre>
<h2 id="rtos-considerations"><a class="header" href="#rtos-considerations">RTOS Considerations</a></h2>
<h3 id="interrupt-safe-api-calls"><a class="header" href="#interrupt-safe-api-calls">Interrupt-Safe API Calls</a></h3>
<p>Most RTOS functions are <strong>not</strong> safe to call from ISRs. Use special ISR-safe versions:</p>
<p><strong>FreeRTOS Example:</strong></p>
<pre><code class="language-c">// Main task code
void task_function(void* param) {
    uint32_t value;
    xQueueReceive(queue, &amp;value, portMAX_DELAY);
}

// ISR code - use FromISR variants
void USART1_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    uint32_t data = USART1-&gt;DR;

    // Use ISR-safe version
    xQueueSendFromISR(queue, &amp;data, &amp;xHigherPriorityTaskWoken);

    // Request context switch if higher priority task woken
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
</code></pre>
<p><strong>Common ISR-Safe Functions:</strong></p>
<ul>
<li><code>xQueueSendFromISR()</code> / <code>xQueueReceiveFromISR()</code></li>
<li><code>xSemaphoreGiveFromISR()</code> / <code>xSemaphoreTakeFromISR()</code></li>
<li><code>xEventGroupSetBitsFromISR()</code></li>
<li><code>vTaskNotifyGiveFromISR()</code></li>
</ul>
<h3 id="deferred-interrupt-processing"><a class="header" href="#deferred-interrupt-processing">Deferred Interrupt Processing</a></h3>
<p>Pattern: Do minimal work in ISR, defer complex processing to task</p>
<p><strong>Method 1: Binary Semaphore</strong></p>
<pre><code class="language-c">SemaphoreHandle_t xDataSemaphore;

void data_processing_task(void* param) {
    while (1) {
        xSemaphoreTake(xDataSemaphore, portMAX_DELAY);
        // Do complex processing here
        process_sensor_data();
    }
}

void SENSOR_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    // Quick: read sensor, store in buffer
    read_sensor_to_buffer();

    // Wake up processing task
    xSemaphoreGiveFromISR(xDataSemaphore, &amp;xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
</code></pre>
<p><strong>Method 2: Task Notification (More Efficient)</strong></p>
<pre><code class="language-c">TaskHandle_t xProcessingTask;

void data_processing_task(void* param) {
    while (1) {
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        process_sensor_data();
    }
}

void SENSOR_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    read_sensor_to_buffer();
    vTaskNotifyGiveFromISR(xProcessingTask, &amp;xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
</code></pre>
<p><strong>Method 3: Message Queue</strong></p>
<pre><code class="language-c">QueueHandle_t xEventQueue;

void event_handler_task(void* param) {
    event_t event;
    while (1) {
        xQueueReceive(xEventQueue, &amp;event, portMAX_DELAY);
        handle_event(&amp;event);
    }
}

void BUTTON_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    event_t event = { .type = BUTTON_PRESSED, .timestamp = get_time() };
    xQueueSendFromISR(xEventQueue, &amp;event, &amp;xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
</code></pre>
<h3 id="interrupt-priority-vs-rtos-priority"><a class="header" href="#interrupt-priority-vs-rtos-priority">Interrupt Priority vs RTOS Priority</a></h3>
<p><strong>Critical Rule</strong>: RTOS API calls from ISR are only safe if interrupt priority is <strong>lower</strong> than <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>.</p>
<pre><code class="language-c">// FreeRTOS configuration
#define configMAX_SYSCALL_INTERRUPT_PRIORITY 5

// Interrupt priorities (ARM Cortex-M, lower number = higher priority)
NVIC_SetPriority(TIMER_IRQn, 3);   // Priority 3 - CANNOT call RTOS APIs (too high)
NVIC_SetPriority(USART_IRQn, 5);   // Priority 5 - Can call RTOS FromISR APIs
NVIC_SetPriority(SPI_IRQn, 10);    // Priority 10 - Can call RTOS FromISR APIs
</code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="stm32-arm-cortex-m-external-interrupt-example"><a class="header" href="#stm32-arm-cortex-m-external-interrupt-example">STM32 (ARM Cortex-M) External Interrupt Example</a></h3>
<pre><code class="language-c">#include "stm32f4xx.h"

void EXTI0_Config(void) {
    // Enable GPIOA clock
    RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // Configure PA0 as input
    GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER0;

    // Enable SYSCFG clock
    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    // Connect EXTI0 to PA0
    SYSCFG-&gt;EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PA;

    // Enable rising edge trigger
    EXTI-&gt;RTSR |= EXTI_RTSR_TR0;

    // Unmask EXTI0
    EXTI-&gt;IMR |= EXTI_IMR_MR0;

    // Set priority and enable in NVIC
    NVIC_SetPriority(EXTI0_IRQn, 2);
    NVIC_EnableIRQ(EXTI0_IRQn);
}

void EXTI0_IRQHandler(void) {
    // Check if EXTI0 triggered
    if (EXTI-&gt;PR &amp; EXTI_PR_PR0) {
        // Clear pending bit by writing 1
        EXTI-&gt;PR = EXTI_PR_PR0;

        // Handle interrupt
        toggle_led();
    }
}
</code></pre>
<h3 id="stm32-timer-interrupt-example"><a class="header" href="#stm32-timer-interrupt-example">STM32 Timer Interrupt Example</a></h3>
<pre><code class="language-c">void TIM2_Config(void) {
    // Enable TIM2 clock
    RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM2EN;

    // Configure timer for 1ms interrupt @ 84MHz
    TIM2-&gt;PSC = 84 - 1;        // Prescaler: 84MHz / 84 = 1MHz
    TIM2-&gt;ARR = 1000 - 1;      // Auto-reload: 1MHz / 1000 = 1kHz (1ms)

    // Enable update interrupt
    TIM2-&gt;DIER |= TIM_DIER_UIE;

    // Enable TIM2 global interrupt in NVIC
    NVIC_SetPriority(TIM2_IRQn, 3);
    NVIC_EnableIRQ(TIM2_IRQn);

    // Start timer
    TIM2-&gt;CR1 |= TIM_CR1_CEN;
}

volatile uint32_t system_ticks = 0;

void TIM2_IRQHandler(void) {
    // Check update interrupt flag
    if (TIM2-&gt;SR &amp; TIM_SR_UIF) {
        // Clear flag
        TIM2-&gt;SR &amp;= ~TIM_SR_UIF;

        // Increment tick counter
        system_ticks++;
    }
}
</code></pre>
<h3 id="avr-timer-interrupt-example"><a class="header" href="#avr-timer-interrupt-example">AVR Timer Interrupt Example</a></h3>
<pre><code class="language-c">#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;

void timer0_init(void) {
    // Set timer0 to CTC mode
    TCCR0A |= (1 &lt;&lt; WGM01);

    // Set compare value for 1ms @ 16MHz with prescaler 64
    // 16MHz / 64 / 250 = 1kHz (1ms)
    OCR0A = 250 - 1;

    // Enable compare match interrupt
    TIMSK0 |= (1 &lt;&lt; OCIE0A);

    // Start timer with prescaler 64
    TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00);

    // Enable global interrupts
    sei();
}

volatile uint32_t millis_count = 0;

ISR(TIMER0_COMPA_vect) {
    millis_count++;
}

uint32_t millis(void) {
    uint32_t m;
    cli();
    m = millis_count;
    sei();
    return m;
}
</code></pre>
<h3 id="avr-external-interrupt-example"><a class="header" href="#avr-external-interrupt-example">AVR External Interrupt Example</a></h3>
<pre><code class="language-c">#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;

void ext_int0_init(void) {
    // Configure INT0 pin (PD2) as input with pull-up
    DDRD &amp;= ~(1 &lt;&lt; PD2);
    PORTD |= (1 &lt;&lt; PD2);

    // Trigger on falling edge
    EICRA |= (1 &lt;&lt; ISC01);
    EICRA &amp;= ~(1 &lt;&lt; ISC00);

    // Enable INT0
    EIMSK |= (1 &lt;&lt; INT0);

    // Enable global interrupts
    sei();
}

volatile uint8_t button_pressed = 0;

ISR(INT0_vect) {
    button_pressed = 1;
    // Debouncing should be handled in main loop or with timer
}
</code></pre>
<h3 id="nordic-nrf52-arm-cortex-m4-gpiote-example"><a class="header" href="#nordic-nrf52-arm-cortex-m4-gpiote-example">Nordic nRF52 (ARM Cortex-M4) GPIOTE Example</a></h3>
<pre><code class="language-c">#include "nrf_gpio.h"
#include "nrf_gpiote.h"

void gpiote_init(void) {
    // Configure GPIO pin
    nrf_gpio_cfg_input(BUTTON_PIN, NRF_GPIO_PIN_PULLUP);

    // Configure GPIOTE channel 0 for button
    NRF_GPIOTE-&gt;CONFIG[0] = (GPIOTE_CONFIG_MODE_Event &lt;&lt; GPIOTE_CONFIG_MODE_Pos) |
                            (BUTTON_PIN &lt;&lt; GPIOTE_CONFIG_PSEL_Pos) |
                            (GPIOTE_CONFIG_POLARITY_HiToLo &lt;&lt; GPIOTE_CONFIG_POLARITY_Pos);

    // Enable interrupt for channel 0
    NRF_GPIOTE-&gt;INTENSET = GPIOTE_INTENSET_IN0_Msk;

    // Enable GPIOTE interrupt in NVIC
    NVIC_SetPriority(GPIOTE_IRQn, 3);
    NVIC_EnableIRQ(GPIOTE_IRQn);
}

void GPIOTE_IRQHandler(void) {
    // Check if event on channel 0
    if (NRF_GPIOTE-&gt;EVENTS_IN[0]) {
        // Clear event
        NRF_GPIOTE-&gt;EVENTS_IN[0] = 0;

        // Handle button press
        handle_button_press();
    }
}
</code></pre>
<h3 id="circular-buffer-for-interrupt-safe-data-transfer"><a class="header" href="#circular-buffer-for-interrupt-safe-data-transfer">Circular Buffer for Interrupt-Safe Data Transfer</a></h3>
<pre><code class="language-c">#define BUFFER_SIZE 128

typedef struct {
    volatile uint8_t buffer[BUFFER_SIZE];
    volatile uint16_t head;
    volatile uint16_t tail;
} circular_buffer_t;

circular_buffer_t rx_buffer = {0};

// Called from ISR
void buffer_put(circular_buffer_t* cb, uint8_t data) {
    uint16_t next_head = (cb-&gt;head + 1) % BUFFER_SIZE;

    // Check if buffer full
    if (next_head != cb-&gt;tail) {
        cb-&gt;buffer[cb-&gt;head] = data;
        cb-&gt;head = next_head;
    }
}

// Called from main code
bool buffer_get(circular_buffer_t* cb, uint8_t* data) {
    if (cb-&gt;head == cb-&gt;tail) {
        return false;  // Buffer empty
    }

    *data = cb-&gt;buffer[cb-&gt;tail];
    cb-&gt;tail = (cb-&gt;tail + 1) % BUFFER_SIZE;
    return true;
}

// UART RX ISR
ISR(USART_RX_vect) {
    uint8_t data = UDR0;
    buffer_put(&amp;rx_buffer, data);
}

// Main loop
void main_loop(void) {
    uint8_t byte;
    while (buffer_get(&amp;rx_buffer, &amp;byte)) {
        process_byte(byte);
    }
}
</code></pre>
<h2 id="common-pitfalls-and-solutions"><a class="header" href="#common-pitfalls-and-solutions">Common Pitfalls and Solutions</a></h2>
<h3 id="pitfall-1-forgetting-to-clear-interrupt-flags"><a class="header" href="#pitfall-1-forgetting-to-clear-interrupt-flags">Pitfall 1: Forgetting to Clear Interrupt Flags</a></h3>
<pre><code class="language-c">// BAD: Flag not cleared
ISR(ADC_vect) {
    uint16_t result = ADC;
    process_result(result);
    // Flag not cleared - ISR fires continuously!
}

// GOOD: Flag cleared (automatic for many peripherals on AVR)
// But explicit for others:
void TIM2_IRQHandler(void) {
    if (TIM2-&gt;SR &amp; TIM_SR_UIF) {
        TIM2-&gt;SR &amp;= ~TIM_SR_UIF;  // Clear flag explicitly
        handle_timer();
    }
}
</code></pre>
<h3 id="pitfall-2-non-atomic-operations-on-shared-variables"><a class="header" href="#pitfall-2-non-atomic-operations-on-shared-variables">Pitfall 2: Non-Atomic Operations on Shared Variables</a></h3>
<pre><code class="language-c">// BAD: Non-atomic 16-bit increment on 8-bit AVR
volatile uint16_t counter = 0;

ISR(TIMER_vect) {
    counter++;  // Two instructions: low byte, then high byte
}

void main(void) {
    uint16_t local = counter;  // Can read inconsistent value!
}

// GOOD: Atomic access
uint16_t read_counter(void) {
    uint16_t temp;
    cli();
    temp = counter;
    sei();
    return temp;
}
</code></pre>
<h3 id="pitfall-3-function-calls-in-isr-without-considering-side-effects"><a class="header" href="#pitfall-3-function-calls-in-isr-without-considering-side-effects">Pitfall 3: Function Calls in ISR Without Considering Side Effects</a></h3>
<pre><code class="language-c">// BAD: printf in ISR (slow, uses interrupts internally)
ISR(UART_RX_vect) {
    printf("Received: %c\n", UDR0);  // NEVER do this!
}

// GOOD: Set flag, process in main
volatile bool data_received = false;
volatile uint8_t received_byte;

ISR(UART_RX_vect) {
    received_byte = UDR0;
    data_received = true;
}
</code></pre>
<h3 id="pitfall-4-incorrect-interrupt-priority-configuration"><a class="header" href="#pitfall-4-incorrect-interrupt-priority-configuration">Pitfall 4: Incorrect Interrupt Priority Configuration</a></h3>
<pre><code class="language-c">// BAD: Critical interrupt with low priority
NVIC_SetPriority(MOTOR_CONTROL_IRQn, 15);  // Lowest priority
NVIC_SetPriority(DEBUG_UART_IRQn, 0);      // Highest priority

// GOOD: Priority matches criticality
NVIC_SetPriority(MOTOR_CONTROL_IRQn, 2);   // High priority - time critical
NVIC_SetPriority(DEBUG_UART_IRQn, 10);     // Low priority - not critical
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Interrupts are essential for responsive embedded systems. Key takeaways:</p>
<ol>
<li><strong>Keep ISRs short</strong> - Defer complex processing to main loop or RTOS tasks</li>
<li><strong>Use <code>volatile</code></strong> - For all variables shared between ISR and main code</li>
<li><strong>Protect critical sections</strong> - Use interrupt disable/enable or RTOS primitives</li>
<li><strong>Clear interrupt flags</strong> - Always clear flags to prevent repeated interrupts</li>
<li><strong>Understand your architecture</strong> - ARM Cortex-M has sophisticated NVIC; AVR is simpler but effective</li>
<li><strong>Configure priorities correctly</strong> - Critical interrupts get higher priority</li>
<li><strong>Use RTOS-safe functions</strong> - Always use <code>FromISR</code> variants in RTOS environments</li>
<li><strong>Test thoroughly</strong> - Race conditions and timing bugs are hard to reproduce</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../embedded/gpio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../embedded/timers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../embedded/gpio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../embedded/timers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
