<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Distributed Consensus - My Notes</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="distributed-consensus"><a class="header" href="#distributed-consensus">Distributed Consensus</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Distributed consensus is the challenge of getting multiple nodes in a distributed system to agree on a shared state, even in the presence of failures.</p>
<h2 id="the-cap-theorem"><a class="header" href="#the-cap-theorem">The CAP Theorem</a></h2>
<p>You can only guarantee 2 out of 3:</p>
<pre><code>       Consistency
          /  \
         /    \
        /  ??  \
       /________\
Availability   Partition
              Tolerance
</code></pre>
<h3 id="consistency-c"><a class="header" href="#consistency-c">Consistency (C)</a></h3>
<p>All nodes see the same data at the same time:</p>
<pre><code>Write X=5 to Node A
  ↓
Node A, B, C all show X=5 immediately
</code></pre>
<h3 id="availability-a"><a class="header" href="#availability-a">Availability (A)</a></h3>
<p>Every request gets a response (success or failure):</p>
<pre><code>Request → Node → Response (always)
(even if stale data)
</code></pre>
<h3 id="partition-tolerance-p"><a class="header" href="#partition-tolerance-p">Partition Tolerance (P)</a></h3>
<p>System continues operating despite network failures:</p>
<pre><code>Network Split:
  [Node A, B]  |  [Node C, D]
     ↑                  ↑
  Can't communicate but both keep running
</code></pre>
<h2 id="cap-trade-offs"><a class="header" href="#cap-trade-offs">CAP Trade-offs</a></h2>
<h3 id="cp-consistency--partition-tolerance"><a class="header" href="#cp-consistency--partition-tolerance">CP (Consistency + Partition Tolerance)</a></h3>
<p>Sacrifice availability for consistency:</p>
<pre><code>Network partition detected
  ↓
System becomes unavailable (refuse requests)
  ↓
Maintain consistency (no stale reads)
</code></pre>
<p><strong>Examples</strong>: HBase, MongoDB (with majority writes), Redis (with wait)</p>
<p><strong>Use Case</strong>: Financial systems, inventory management</p>
<h3 id="ap-availability--partition-tolerance"><a class="header" href="#ap-availability--partition-tolerance">AP (Availability + Partition Tolerance)</a></h3>
<p>Sacrifice consistency for availability:</p>
<pre><code>Network partition detected
  ↓
Both partitions keep serving requests
  ↓
Data diverges (eventually consistent)
</code></pre>
<p><strong>Examples</strong>: Cassandra, DynamoDB, Riak</p>
<p><strong>Use Case</strong>: Social media, shopping carts, session storage</p>
<h3 id="ca-consistency--availability"><a class="header" href="#ca-consistency--availability">CA (Consistency + Availability)</a></h3>
<p>Only works without network partitions:</p>
<pre><code>Single datacenter, reliable network
  ↓
All nodes always agree
  ↓
(Not realistic for distributed systems)
</code></pre>
<p><strong>Examples</strong>: PostgreSQL (single instance), MySQL (single instance)</p>
<p><strong>Reality</strong>: Network partitions always happen, must choose CP or AP</p>
<h2 id="consistency-models"><a class="header" href="#consistency-models">Consistency Models</a></h2>
<h3 id="strong-consistency"><a class="header" href="#strong-consistency">Strong Consistency</a></h3>
<p>Reads always return latest write:</p>
<pre><code>Time 0: Write X=5 to Node A
Time 1: Read from Node B → Returns X=5 (latest)
Time 2: Write X=10 to Node A
Time 3: Read from Node B → Returns X=10 (latest)
</code></pre>
<p><strong>Implementation</strong>: Wait for all replicas to acknowledge</p>
<pre><code class="language-python">def write(key, value):
    # Write to all nodes
    for node in nodes:
        node.write(key, value)
        wait_for_ack(node)  # Block until confirmed

    return success

def read(key):
    # Read from majority
    values = []
    for node in majority_nodes:
        values.append(node.read(key))

    # Return latest version
    return max(values, key=lambda v: v.timestamp)
</code></pre>
<h3 id="eventual-consistency"><a class="header" href="#eventual-consistency">Eventual Consistency</a></h3>
<p>Reads may return stale data, but eventually converge:</p>
<pre><code>Time 0: Write X=5 to Node A
Time 1: Read from Node B → Returns X=1 (stale, not replicated yet)
Time 2: Replication completes
Time 3: Read from Node B → Returns X=5 (consistent)
</code></pre>
<p><strong>Implementation</strong>: Asynchronous replication</p>
<pre><code class="language-python">def write(key, value):
    # Write to primary
    primary.write(key, value)

    # Async replicate to others
    async_replicate(key, value)

    return success  # Don't wait

def async_replicate(key, value):
    for node in replica_nodes:
        background_task.queue({
            'action': 'replicate',
            'node': node,
            'key': key,
            'value': value
        })
</code></pre>
<h3 id="causal-consistency"><a class="header" href="#causal-consistency">Causal Consistency</a></h3>
<p>Causally related writes are seen in order:</p>
<pre><code>User A writes Post → User B reads Post → User B writes Comment
  ↓                      ↓                       ↓
All nodes see Post before Comment
</code></pre>
<pre><code class="language-python"># Vector clocks for causality
class VectorClock:
    def __init__(self):
        self.clocks = {}  # {node_id: counter}

    def increment(self, node_id):
        self.clocks[node_id] = self.clocks.get(node_id, 0) + 1

    def merge(self, other):
        for node_id, counter in other.clocks.items():
            self.clocks[node_id] = max(
                self.clocks.get(node_id, 0),
                counter
            )

    def happens_before(self, other):
        # True if self happened before other
        return all(
            self.clocks.get(k, 0) &lt;= other.clocks.get(k, 0)
            for k in set(self.clocks) | set(other.clocks)
        )
</code></pre>
<h3 id="read-after-write-consistency"><a class="header" href="#read-after-write-consistency">Read-After-Write Consistency</a></h3>
<p>Your writes are immediately visible to you:</p>
<pre><code>User writes X=5
  ↓
Same user reads → Gets X=5 (consistent)
  ↓
Other users read → May get old value (eventual)
</code></pre>
<pre><code class="language-python">def write(key, value, user_id):
    version = primary.write(key, value)

    # Cache user's write version
    user_versions[user_id][key] = version

    return success

def read(key, user_id):
    # Check if user has written this key
    if key in user_versions.get(user_id, {}):
        # Read from primary to get latest
        return primary.read(key)
    else:
        # Can read from any replica
        return random.choice(replicas).read(key)
</code></pre>
<h3 id="monotonic-reads"><a class="header" href="#monotonic-reads">Monotonic Reads</a></h3>
<p>Once you read a value, you never read older values:</p>
<pre><code>Time 1: Read X=5
Time 2: Read X=10 (newer) ✓
Time 3: Read X=5 (older) ✗ Not allowed
</code></pre>
<pre><code class="language-python"># Sticky sessions - always read from same replica
def read(key, session_id):
    replica = get_sticky_replica(session_id)
    return replica.read(key)

def get_sticky_replica(session_id):
    # Hash session to consistent replica
    replica_id = hash(session_id) % num_replicas
    return replicas[replica_id]
</code></pre>
<h2 id="consensus-algorithms"><a class="header" href="#consensus-algorithms">Consensus Algorithms</a></h2>
<h3 id="two-phase-commit-2pc"><a class="header" href="#two-phase-commit-2pc">Two-Phase Commit (2PC)</a></h3>
<p>Distributed transaction protocol:</p>
<pre><code>Phase 1: PREPARE
Coordinator → All Participants: "Can you commit?"
Participants → Coordinator: "Yes" or "No"

Phase 2: COMMIT
If all "Yes":
  Coordinator → All: "Commit!"
  Participants commit
Else:
  Coordinator → All: "Abort!"
  Participants rollback
</code></pre>
<pre><code class="language-python">class TwoPhaseCommit:
    def __init__(self, coordinator, participants):
        self.coordinator = coordinator
        self.participants = participants

    def execute_transaction(self, transaction):
        # Phase 1: Prepare
        votes = []
        for participant in self.participants:
            vote = participant.prepare(transaction)
            votes.append(vote)

        # Phase 2: Commit or Abort
        if all(votes):
            # All voted yes - commit
            for participant in self.participants:
                participant.commit(transaction)
            return "committed"
        else:
            # Someone voted no - abort
            for participant in self.participants:
                participant.abort(transaction)
            return "aborted"
</code></pre>
<p><strong>Pros</strong>: Strong consistency
<strong>Cons</strong>: Blocking (if coordinator fails), not partition-tolerant</p>
<h3 id="three-phase-commit-3pc"><a class="header" href="#three-phase-commit-3pc">Three-Phase Commit (3PC)</a></h3>
<p>Non-blocking version of 2PC:</p>
<pre><code>Phase 1: PREPARE (can commit?)
Phase 2: PRE-COMMIT (will commit)
Phase 3: COMMIT (do commit)
</code></pre>
<p><strong>Advantage</strong>: Can timeout and continue if coordinator fails</p>
<h3 id="paxos"><a class="header" href="#paxos">Paxos</a></h3>
<p>Consensus algorithm for distributed systems:</p>
<pre><code>Proposer → Prepare(N)
  ↓
Acceptors → Promise(N, LastValue)
  ↓
Proposer → Accept(N, Value)
  ↓
Acceptors → Accepted(N, Value)
  ↓
Learners learn chosen value
</code></pre>
<p><strong>Simplified</strong>:</p>
<ol>
<li>Proposer suggests value with sequence number</li>
<li>Acceptors promise to not accept older proposals</li>
<li>If majority accepts, value is chosen</li>
</ol>
<p><strong>Pros</strong>: Proven correct, fault-tolerant
<strong>Cons</strong>: Complex, hard to implement</p>
<h3 id="raft"><a class="header" href="#raft">Raft</a></h3>
<p>Easier-to-understand consensus algorithm:</p>
<pre><code>1. Leader Election
   Nodes elect a leader via voting

2. Log Replication
   Leader receives writes
   Leader replicates to followers
   Commits once majority acknowledges

3. Safety
   Only nodes with up-to-date logs can be leader
</code></pre>
<pre><code class="language-python">class RaftNode:
    def __init__(self):
        self.state = "follower"  # follower, candidate, leader
        self.current_term = 0
        self.voted_for = None
        self.log = []

    def start_election(self):
        self.state = "candidate"
        self.current_term += 1
        self.voted_for = self.id

        votes = 1  # Vote for self
        for peer in self.peers:
            if peer.request_vote(self.current_term, self.id):
                votes += 1

        if votes &gt; len(self.peers) / 2:
            self.become_leader()

    def become_leader(self):
        self.state = "leader"
        # Send heartbeats to maintain leadership

    def append_entry(self, entry):
        if self.state != "leader":
            return redirect_to_leader()

        self.log.append(entry)

        # Replicate to majority
        acks = 1  # Self
        for peer in self.peers:
            if peer.append_entries(self.current_term, entry):
                acks += 1

        if acks &gt; len(self.peers) / 2:
            # Committed
            return success
        else:
            return failure
</code></pre>
<p><strong>Pros</strong>: Understandable, proven correct, widely used
<strong>Cons</strong>: Requires majority for writes (not available during partition)</p>
<p><strong>Used by</strong>: etcd, Consul, TiKV</p>
<h2 id="quorum-readswrites"><a class="header" href="#quorum-readswrites">Quorum Reads/Writes</a></h2>
<p>Read and write from majority:</p>
<pre><code>N = 5 nodes
W = 3 (write quorum - must write to 3)
R = 3 (read quorum - must read from 3)

W + R &gt; N ensures read sees latest write
</code></pre>
<pre><code class="language-python">class QuorumStore:
    def __init__(self, nodes, write_quorum, read_quorum):
        self.nodes = nodes
        self.W = write_quorum
        self.R = read_quorum

    def write(self, key, value):
        version = get_next_version()

        acks = 0
        for node in self.nodes:
            if node.write(key, value, version):
                acks += 1
                if acks &gt;= self.W:
                    return success

        return failure  # Couldn't reach quorum

    def read(self, key):
        values = []

        for node in self.nodes:
            result = node.read(key)
            if result:
                values.append(result)
                if len(values) &gt;= self.R:
                    break

        if len(values) &lt; self.R:
            return failure

        # Return value with highest version
        return max(values, key=lambda v: v.version)
</code></pre>
<p><strong>Examples</strong>: Cassandra (configurable), DynamoDB</p>
<h2 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h2>
<h3 id="last-write-wins-lww"><a class="header" href="#last-write-wins-lww">Last-Write-Wins (LWW)</a></h3>
<p>Keep value with latest timestamp:</p>
<pre><code>Node A: Write X=5 at time=100
Node B: Write X=10 at time=105
  ↓
Merge: Keep X=10 (latest timestamp)
</code></pre>
<p><strong>Pros</strong>: Simple
<strong>Cons</strong>: Requires synchronized clocks, data loss</p>
<h3 id="vector-clocks"><a class="header" href="#vector-clocks">Vector Clocks</a></h3>
<p>Track causality to detect conflicts:</p>
<pre><code>Node A writes: X=5, Clock={A:1}
Node B writes: X=10, Clock={B:1}
  ↓
Conflict detected (concurrent writes)
  ↓
Application resolves (merge, last-write-wins, etc.)
</code></pre>
<pre><code class="language-python"># Detect conflict with vector clocks
def is_concurrent(clock1, clock2):
    not_before = any(
        clock1.get(k, 0) &gt; clock2.get(k, 0)
        for k in clock1
    )
    not_after = any(
        clock2.get(k, 0) &gt; clock1.get(k, 0)
        for k in clock2
    )
    return not_before and not_after

# Example
v1 = {A: 1, B: 2}
v2 = {A: 1, B: 3}
is_concurrent(v1, v2)  # False (v2 after v1)

v1 = {A: 2, B: 1}
v2 = {A: 1, B: 2}
is_concurrent(v1, v2)  # True (concurrent)
</code></pre>
<h3 id="crdts-conflict-free-replicated-data-types"><a class="header" href="#crdts-conflict-free-replicated-data-types">CRDTs (Conflict-free Replicated Data Types)</a></h3>
<p>Data structures that automatically resolve conflicts:</p>
<p><strong>G-Counter (Grow-only Counter)</strong>:</p>
<pre><code class="language-python">class GCounter:
    def __init__(self, node_id):
        self.node_id = node_id
        self.counts = {}  # {node_id: count}

    def increment(self):
        self.counts[self.node_id] = self.counts.get(self.node_id, 0) + 1

    def value(self):
        return sum(self.counts.values())

    def merge(self, other):
        for node_id, count in other.counts.items():
            self.counts[node_id] = max(
                self.counts.get(node_id, 0),
                count
            )
</code></pre>
<p><strong>PN-Counter (Positive-Negative Counter)</strong>:</p>
<pre><code class="language-python">class PNCounter:
    def __init__(self, node_id):
        self.increments = GCounter(node_id)
        self.decrements = GCounter(node_id)

    def increment(self):
        self.increments.increment()

    def decrement(self):
        self.decrements.increment()

    def value(self):
        return self.increments.value() - self.decrements.value()

    def merge(self, other):
        self.increments.merge(other.increments)
        self.decrements.merge(other.decrements)
</code></pre>
<p><strong>OR-Set (Observed-Remove Set)</strong>:</p>
<pre><code class="language-python">class ORSet:
    def __init__(self):
        self.elements = {}  # {element: {unique_tags}}

    def add(self, element, unique_tag):
        if element not in self.elements:
            self.elements[element] = set()
        self.elements[element].add(unique_tag)

    def remove(self, element):
        if element in self.elements:
            # Remember tags to remove during merge
            self.removed_tags = self.elements[element].copy()
            del self.elements[element]

    def contains(self, element):
        return element in self.elements

    def merge(self, other):
        for element, tags in other.elements.items():
            if element not in self.elements:
                self.elements[element] = set()
            self.elements[element] |= tags
</code></pre>
<h2 id="distributed-locks"><a class="header" href="#distributed-locks">Distributed Locks</a></h2>
<h3 id="simple-lock-with-ttl"><a class="header" href="#simple-lock-with-ttl">Simple Lock with TTL</a></h3>
<pre><code class="language-python">import redis

def acquire_lock(lock_name, timeout=10):
    lock_key = f"lock:{lock_name}"
    acquired = redis.set(
        lock_key,
        "locked",
        nx=True,  # Only if not exists
        ex=timeout  # Expires in timeout seconds
    )
    return acquired

def release_lock(lock_name):
    redis.delete(f"lock:{lock_name}")

# Usage
if acquire_lock("process-order-123"):
    try:
        process_order(123)
    finally:
        release_lock("process-order-123")
</code></pre>
<p><strong>Problem</strong>: Lock holder crashes, lock expires, another process acquires</p>
<h3 id="redlock-algorithm"><a class="header" href="#redlock-algorithm">Redlock Algorithm</a></h3>
<p>Acquire locks from majority of independent Redis instances:</p>
<pre><code class="language-python">def acquire_redlock(lock_name, redis_instances):
    token = random_token()
    start_time = time.time()

    acquired = 0
    for redis in redis_instances:
        if redis.set(lock_name, token, nx=True, px=10000):
            acquired += 1

    elapsed = time.time() - start_time
    validity_time = 10000 - elapsed

    if acquired &gt;= len(redis_instances) // 2 + 1 and validity_time &gt; 0:
        return token, validity_time
    else:
        # Couldn't acquire majority, release all
        for redis in redis_instances:
            if redis.get(lock_name) == token:
                redis.delete(lock_name)
        return None
</code></pre>
<h3 id="fencing-tokens"><a class="header" href="#fencing-tokens">Fencing Tokens</a></h3>
<p>Prevent old lock holders from causing issues:</p>
<pre><code>Process A acquires lock with token=1
Process A pauses (GC, network delay)
Lock expires
Process B acquires lock with token=2
Process B writes to resource
Process A wakes up, tries to write
Resource rejects (token 1 &lt; current token 2)
</code></pre>
<pre><code class="language-python">current_token = 0

def write_with_token(data, token):
    global current_token

    if token &gt; current_token:
        current_token = token
        do_write(data)
        return success
    else:
        return failure  # Stale token
</code></pre>
<h2 id="split-brain-problem"><a class="header" href="#split-brain-problem">Split-Brain Problem</a></h2>
<p>Network partition causes multiple leaders:</p>
<pre><code>Before partition:
[Leader A] --- [Follower B] --- [Follower C]

After partition:
[Leader A]  |  [Leader B, Follower C]
             |
        Network split
</code></pre>
<p><strong>Solutions</strong>:</p>
<p><strong>Quorum</strong>: Require majority for leader election</p>
<pre><code class="language-python"># Side with 2 nodes can elect leader
# Side with 1 node cannot (no majority)
[Leader A]  |  [Leader B, Follower C] ← Can elect new leader
</code></pre>
<p><strong>Fencing</strong>: Isolate old leader</p>
<pre><code class="language-python"># Tell storage to reject writes from old leader
storage.fence(old_leader_id)
</code></pre>
<h2 id="consistency-guarantees-comparison"><a class="header" href="#consistency-guarantees-comparison">Consistency Guarantees Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Model</th><th>Staleness</th><th>Performance</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Strong</strong></td><td>None</td><td>Slow</td><td>Banking, inventory</td></tr>
<tr><td><strong>Eventual</strong></td><td>Temporary</td><td>Fast</td><td>Social media, caching</td></tr>
<tr><td><strong>Causal</strong></td><td>Related events ordered</td><td>Medium</td><td>Collaborative editing</td></tr>
<tr><td><strong>Read-after-write</strong></td><td>Own writes visible</td><td>Medium</td><td>User profiles</td></tr>
<tr><td><strong>Monotonic</strong></td><td>No going back in time</td><td>Medium</td><td>Feeds, timelines</td></tr>
</tbody></table>
</div>
<h2 id="eli10"><a class="header" href="#eli10">ELI10</a></h2>
<p>Distributed consensus is like a group of friends deciding where to eat:</p>
<ul>
<li><strong>Strong consistency</strong>: Everyone must agree before choosing (slow but fair)</li>
<li><strong>Eventual consistency</strong>: Everyone decides separately, sort it out later (fast but messy)</li>
<li><strong>CAP theorem</strong>: Can't have fast decisions (A), everyone agrees (C), and handle people not responding (P)</li>
<li><strong>Quorum</strong>: Majority decides (more than half agree = decision made)</li>
<li><strong>Split-brain</strong>: Group splits, both sides think they're in charge (need quorum to prevent)</li>
</ul>
<p><strong>Paxos/Raft</strong>: Formal voting systems that guarantee everyone eventually agrees</p>
<p>Getting distributed systems to agree is hard!</p>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<ul>
<li><a href="https://dataintensive.app/">Designing Data-Intensive Applications (DDIA)</a></li>
<li><a href="https://raft.github.io/">Raft Consensus Algorithm</a></li>
<li><a href="https://jepsen.io/">Jepsen: Distributed Systems Safety Research</a></li>
<li><a href="https://www.ibm.com/topics/cap-theorem">CAP Theorem Explained</a></li>
<li><a href="https://crdt.tech/">CRDTs: Conflict-free Replicated Data Types</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../system_design/design_patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../system_design/message_queues.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../system_design/design_patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../system_design/message_queues.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
