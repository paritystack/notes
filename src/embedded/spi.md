# SPI (Serial Peripheral Interface)

## Overview

SPI (Serial Peripheral Interface) is a synchronous serial communication protocol used for short-distance communication between microcontrollers and peripheral devices like sensors, displays, SD cards, and flash memory. Developed by Motorola in the 1980s, SPI is known for its high-speed, full-duplex communication capabilities.

## Key Features

- **Full-Duplex Communication**: SPI can send and receive data simultaneously on separate lines
- **High Speed**: Typically operates at speeds from 1 MHz to over 50 MHz
- **Master-Slave Architecture**: Always has one master device controlling one or more slave devices
- **Four-Wire Interface**: Uses separate lines for clock, data in, data out, and chip select
- **No Addressing**: Slave selection is done via dedicated chip select lines

## Signal Lines

SPI uses four main signal lines:

| Signal | Alternative Names | Description |
|--------|------------------|-------------|
| **SCLK** | SCK, CLK | Serial Clock - Generated by master to synchronize data transfer |
| **MOSI** | SDO, DO, SIMO | Master Out Slave In - Data from master to slave |
| **MISO** | SDI, DI, SOMI | Master In Slave Out - Data from slave to master |
| **SS** | CS, NSS | Slave Select/Chip Select - Selects which slave is active |

### Why Four Wires?

Unlike I2C's two-wire design, SPI uses separate data lines for sending and receiving, enabling full-duplex communication. Each slave device needs its own chip select line, which can increase pin count when multiple slaves are used.

## How It Works

### Basic Communication Flow

1. **Master selects slave**: Pulls the slave's CS line LOW (active)
2. **Master generates clock**: Starts toggling the SCLK line
3. **Data exchange**: On each clock cycle:
   - Master shifts data out on MOSI
   - Slave shifts data out on MISO
   - Both shift data in simultaneously
4. **Master deselects slave**: Pulls CS line HIGH (inactive)

### Clock Polarity and Phase (CPOL/CPHA)

SPI has four modes determined by two settings:

- **CPOL (Clock Polarity)**: Determines the idle state of the clock
  - CPOL = 0: Clock idles LOW
  - CPOL = 1: Clock idles HIGH

- **CPHA (Clock Phase)**: Determines when data is sampled
  - CPHA = 0: Data sampled on leading edge, shifted on trailing edge
  - CPHA = 1: Data sampled on trailing edge, shifted on leading edge

| Mode | CPOL | CPHA | Clock Idle | Data Sampled |
|------|------|------|------------|--------------|
| 0 | 0 | 0 | LOW | Leading (rising) edge |
| 1 | 0 | 1 | LOW | Trailing (falling) edge |
| 2 | 1 | 0 | HIGH | Leading (falling) edge |
| 3 | 1 | 1 | HIGH | Trailing (rising) edge |

**Important**: Master and slave must use the same mode for successful communication!

## Code Examples

### Arduino SPI Communication

```cpp
#include <SPI.h>

const int chipSelectPin = 10;

void setup() {
  // Initialize SPI pins
  pinMode(chipSelectPin, OUTPUT);
  digitalWrite(chipSelectPin, HIGH);  // Deselect slave initially

  // Initialize SPI library
  SPI.begin();

  // Configure SPI settings
  // Max speed: 4 MHz, MSB first, Mode 0
  SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE0));
}

void loop() {
  // Select slave device
  digitalWrite(chipSelectPin, LOW);

  // Send a byte and receive response simultaneously
  byte command = 0x3A;  // Example command
  byte response = SPI.transfer(command);

  // Send multiple bytes
  byte dataToSend[] = {0x01, 0x02, 0x03};
  for (int i = 0; i < 3; i++) {
    byte receivedByte = SPI.transfer(dataToSend[i]);
  }

  // Deselect slave
  digitalWrite(chipSelectPin, HIGH);

  delay(1000);
}
```

### STM32 HAL SPI Example

```c
#include "stm32f4xx_hal.h"

SPI_HandleTypeDef hspi1;

void SPI_Init(void) {
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;    // CPOL = 0
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;        // CPHA = 0
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    HAL_SPI_Init(&hspi1);
}

void SPI_Write_Read(uint8_t *txData, uint8_t *rxData, uint16_t size) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);  // CS LOW
    HAL_SPI_TransmitReceive(&hspi1, txData, rxData, size, 100);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);    // CS HIGH
}
```

### ESP32 SPI Example

```cpp
#include <SPI.h>

SPIClass spi(HSPI);  // Use HSPI bus
const int CS_PIN = 15;

void setup() {
  spi.begin(14, 12, 13, CS_PIN);  // SCLK, MISO, MOSI, SS
  pinMode(CS_PIN, OUTPUT);
  digitalWrite(CS_PIN, HIGH);
}

uint8_t readRegister(uint8_t reg) {
  digitalWrite(CS_PIN, LOW);
  spi.transfer(reg | 0x80);  // Read bit set
  uint8_t value = spi.transfer(0x00);  // Dummy byte to read
  digitalWrite(CS_PIN, HIGH);
  return value;
}

void writeRegister(uint8_t reg, uint8_t value) {
  digitalWrite(CS_PIN, LOW);
  spi.transfer(reg & 0x7F);  // Write bit clear
  spi.transfer(value);
  digitalWrite(CS_PIN, HIGH);
}
```

## Common Use Cases

### 1. SD Card Communication
- High-speed file I/O
- Supports both SPI and SDIO modes
- Ideal for data logging applications

### 2. Display Interfaces
- TFT LCD displays (ILI9341, ST7735)
- OLED displays
- E-ink displays
- Fast refresh rates for graphics

### 3. Sensor Communication
- Digital accelerometers (ADXL345)
- Gyroscopes (MPU6050 in SPI mode)
- Pressure sensors (BMP280)

### 4. Memory Devices
- Flash memory (W25Q128)
- EEPROM chips
- FRAM (Ferroelectric RAM)

### 5. Wireless Modules
- NRF24L01+ (2.4GHz transceiver)
- LoRa modules (SX1278)
- WiFi modules

## SPI vs I2C Comparison

| Feature | SPI | I2C |
|---------|-----|-----|
| **Wires** | 4 (+ 1 per additional slave) | 2 |
| **Speed** | Up to 50+ MHz | Up to 3.4 MHz |
| **Duplex** | Full-duplex | Half-duplex |
| **Addressing** | Hardware (CS pins) | Software (7/10-bit addresses) |
| **Distance** | Short (< 1 meter) | Short (< 1 meter) |
| **Complexity** | Simple protocol | More complex protocol |
| **Multi-master** | No (typically) | Yes |
| **Pins required** | Increases with slaves | Constant |

## Best Practices

### 1. Wire Length and Speed
- Keep wires short (< 30cm) for high speeds
- Reduce speed for longer connections
- Use twisted pairs for MOSI/MISO on longer runs

### 2. Pull-up Resistors
- MISO should have a pull-up resistor (~10k©)
- Prevents floating when no slave is selected
- Some slave devices have built-in pull-ups

### 3. Chip Select Management
```cpp
// Always wrap transfers in CS control
digitalWrite(CS, LOW);
// ... SPI operations ...
digitalWrite(CS, HIGH);

// For critical timing, disable interrupts
noInterrupts();
digitalWrite(CS, LOW);
SPI.transfer(data);
digitalWrite(CS, HIGH);
interrupts();
```

### 4. Power Considerations
- Ensure all devices share a common ground
- Check voltage levels (3.3V vs 5V)
- Use level shifters if needed

### 5. Multiple Slave Devices
```cpp
// Daisy chain method (saves CS pins)
// Data flows through all slaves
digitalWrite(CS_SHARED, LOW);
SPI.transfer(dataForSlave1);
SPI.transfer(dataForSlave2);
SPI.transfer(dataForSlave3);
digitalWrite(CS_SHARED, HIGH);

// Individual CS method (parallel addressing)
digitalWrite(CS_SLAVE1, LOW);
SPI.transfer(dataForSlave1);
digitalWrite(CS_SLAVE1, HIGH);
```

## Common Issues and Debugging

### Problem: No Data Received
- Check CPOL/CPHA mode matches between master and slave
- Verify wiring (MOSI to MOSI, MISO to MISO)
- Ensure CS is properly toggled
- Check clock frequency is within slave's range

### Problem: Corrupted Data
- Reduce SPI clock speed
- Check for loose connections
- Add small capacitors (10nF) near slave devices
- Ensure proper ground connections

### Problem: Multiple Slaves Interfering
- Verify only one CS is active at a time
- Check for proper tri-state behavior on MISO
- Add pull-up on MISO line

## ELI10 (Explain Like I'm 10)

Imagine you're playing a game with your friend where you both pass notes at the same time:

- **The master** is like the teacher who decides when to pass notes (controls the clock)
- **MOSI** is the note you pass to your friend
- **MISO** is the note your friend passes back to you
- **Chip Select** is like tapping your friend's shoulder to say "Hey, I'm talking to you!"
- **Clock** is like a metronome that keeps everyone in sync - you both write and read at the same time

The cool part? You can both write notes to each other at the exact same time! That's why SPI is called "full-duplex" - it's like talking and listening simultaneously.

## Further Resources

- [SPI Wikipedia](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface) - Detailed technical overview
- [Analog Devices SPI Tutorial](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html)
- [SparkFun SPI Tutorial](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi)
- [Arduino SPI Library Reference](https://www.arduino.cc/en/reference/SPI)
- Application notes from your microcontroller manufacturer
